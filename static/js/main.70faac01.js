/*! For license information please see main.70faac01.js.LICENSE.txt */
(()=>{var e={270:(e,t,n)=>{"use strict";var r=n(520),a={"text/plain":"Text","text/html":"Url",default:"Text"};e.exports=function(e,t){var n,o,i,s,c,l,u=!1;t||(t={}),n=t.debug||!1;try{if(i=r(),s=document.createRange(),c=document.getSelection(),(l=document.createElement("span")).textContent=e,l.ariaHidden="true",l.style.all="unset",l.style.position="fixed",l.style.top=0,l.style.clip="rect(0, 0, 0, 0)",l.style.whiteSpace="pre",l.style.webkitUserSelect="text",l.style.MozUserSelect="text",l.style.msUserSelect="text",l.style.userSelect="text",l.addEventListener("copy",(function(r){if(r.stopPropagation(),t.format)if(r.preventDefault(),"undefined"===typeof r.clipboardData){n&&console.warn("unable to use e.clipboardData"),n&&console.warn("trying IE specific stuff"),window.clipboardData.clearData();var o=a[t.format]||a.default;window.clipboardData.setData(o,e)}else r.clipboardData.clearData(),r.clipboardData.setData(t.format,e);t.onCopy&&(r.preventDefault(),t.onCopy(r.clipboardData))})),document.body.appendChild(l),s.selectNodeContents(l),c.addRange(s),!document.execCommand("copy"))throw new Error("copy command was unsuccessful");u=!0}catch(d){n&&console.error("unable to copy using execCommand: ",d),n&&console.warn("trying IE specific stuff");try{window.clipboardData.setData(t.format||"text",e),t.onCopy&&t.onCopy(window.clipboardData),u=!0}catch(d){n&&console.error("unable to copy using clipboardData: ",d),n&&console.error("falling back to prompt"),o=function(e){var t=(/mac os x/i.test(navigator.userAgent)?"\u2318":"Ctrl")+"+C";return e.replace(/#{\s*key\s*}/g,t)}("message"in t?t.message:"Copy to clipboard: #{key}, Enter"),window.prompt(o,e)}}finally{c&&("function"==typeof c.removeRange?c.removeRange(s):c.removeAllRanges()),l&&document.body.removeChild(l),i()}return u}},353:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(I){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},o={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=o[e])?r:(n=c(e,(0|e)<0?-1:0,!0),i&&(o[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=a[e])?r:(n=c(e,e<0?-1:0,!1),i&&(a[e]=n),n)}function s(e,t){if(isNaN(e))return t?v:m;if(t){if(e<0)return v;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?s(-e,t).neg():c(e%h|0,e/h|0,t)}function c(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=s,n.fromBits=c;var l=Math.pow;function u(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return m;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return u(e.substring(1),t,n).neg();for(var a=s(l(n,8)),o=m,i=0;i<e.length;i+=8){var c=Math.min(8,e.length-i),d=parseInt(e.substring(i,i+c),n);if(c<8){var h=s(l(n,c));o=o.mul(h).add(s(d))}else o=(o=o.mul(a)).add(s(d))}return o.unsigned=t,o}function d(e,t){return"number"===typeof e?s(e,t):"string"===typeof e?u(e,t):c(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=u,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,g=i(1<<24),m=i(0);n.ZERO=m;var v=i(0,!0);n.UZERO=v;var b=i(1);n.ONE=b;var y=i(1,!0);n.UONE=y;var x=i(-1);n.NEG_ONE=x;var w=c(-1,2147483647,!1);n.MAX_VALUE=w;var k=c(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=c(0,-2147483648,!1);n.MIN_VALUE=S;var C=n.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},C.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=s(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=s(l(e,6),this.unsigned),o=this,i="";;){var c=o.div(a),u=(o.sub(c.mul(a)).toInt()>>>0).toString(e);if((o=c).isZero())return u+i;for(;u.length<6;)u="0"+u;i=""+u+i}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1===(1&this.low)},C.isEven=function(){return 0===(1&this.low)},C.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return this.comp(e)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return this.comp(e)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},C.neg=C.negate,C.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,a=this.low>>>16,o=65535&this.low,i=e.high>>>16,s=65535&e.high,l=e.low>>>16,u=0,h=0,p=0,f=0;return p+=(f+=o+(65535&e.low))>>>16,h+=(p+=a+l)>>>16,u+=(h+=n+s)>>>16,u+=t+i,c((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(h&=65535),this.unsigned)},C.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return m;if(r(e)||(e=d(e)),t)return c(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return m;if(this.eq(S))return e.isOdd()?S:m;if(e.eq(S))return this.isOdd()?S:m;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return s(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,a=65535&this.high,o=this.low>>>16,i=65535&this.low,l=e.high>>>16,u=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,v=0,b=0,y=0;return b+=(y+=i*p)>>>16,v+=(b+=o*p)>>>16,b&=65535,v+=(b+=i*h)>>>16,f+=(v+=a*p)>>>16,v&=65535,f+=(v+=o*h)>>>16,v&=65535,f+=(v+=i*u)>>>16,f+=n*p+a*h+o*u+i*l,c((b&=65535)<<16|(y&=65535),(f&=65535)<<16|(v&=65535),this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,a,o;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?c((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?v:m;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return v;if(e.gt(this.shru(1)))return y;o=v}else{if(this.eq(S))return e.eq(b)||e.eq(x)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(m)?e.isNegative()?b:x:(a=this.sub(e.mul(n)),o=n.add(a.div(e)));if(e.eq(S))return this.unsigned?v:m;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=m}for(a=this;a.gte(e);){n=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),u=i<=48?1:l(2,i-48),h=s(n),p=h.mul(e);p.isNegative()||p.gt(a);)p=(h=s(n-=u,this.unsigned)).mul(e);h.isZero()&&(h=b),o=o.add(h),a=a.sub(p)}return o},C.div=C.divide,C.modulo=function(e){return r(e)||(e=d(e)),t?c((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return c(~this.low,~this.high,this.unsigned)},C.and=function(e){return r(e)||(e=d(e)),c(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return r(e)||(e=d(e)),c(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return r(e)||(e=d(e)),c(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):c(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):c(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?c(this.low>>>e|t<<32-e,t>>>e,this.unsigned):c(32===e?t:t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},132:(e,t)=>{"use strict";var n,r=Symbol.for("react.element"),a=Symbol.for("react.portal"),o=Symbol.for("react.fragment"),i=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),c=Symbol.for("react.provider"),l=Symbol.for("react.context"),u=Symbol.for("react.server_context"),d=Symbol.for("react.forward_ref"),h=Symbol.for("react.suspense"),p=Symbol.for("react.suspense_list"),f=Symbol.for("react.memo"),g=Symbol.for("react.lazy"),m=Symbol.for("react.offscreen");function v(e){if("object"===typeof e&&null!==e){var t=e.$$typeof;switch(t){case r:switch(e=e.type){case o:case s:case i:case h:case p:return e;default:switch(e=e&&e.$$typeof){case u:case l:case d:case g:case f:case c:return e;default:return t}}case a:return t}}}n=Symbol.for("react.module.reference"),t.ForwardRef=d,t.isFragment=function(e){return v(e)===o},t.isMemo=function(e){return v(e)===f}},816:(e,t,n)=>{"use strict";e.exports=n(132)},730:(e,t,n)=>{"use strict";var r=n(43),a=n(853);function o(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,s={};function c(e,t){l(e,t),l(e+"Capture",t)}function l(e,t){for(s[e]=t,e=0;e<t.length;e++)i.add(t[e])}var u=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),d=Object.prototype.hasOwnProperty,h=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function g(e,t,n,r,a,o,i){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=r,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=o,this.removeEmptyString=i}var m={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){m[e]=new g(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];m[t]=new g(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){m[e]=new g(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){m[e]=new g(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){m[e]=new g(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){m[e]=new g(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){m[e]=new g(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){m[e]=new g(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){m[e]=new g(e,5,!1,e.toLowerCase(),null,!1,!1)}));var v=/[\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function y(e,t,n,r){var a=m.hasOwnProperty(t)?m[t]:null;(null!==a?0!==a.type:r||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,r){if(null===t||"undefined"===typeof t||function(e,t,n,r){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,a,r)&&(n=null),r||null===a?function(e){return!!d.call(f,e)||!d.call(p,e)&&(h.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):a.mustUseProperty?e[a.propertyName]=null===n?3!==a.type&&"":n:(t=a.attributeName,r=a.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(a=a.type)||4===a&&!0===n?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(v,b);m[t]=new g(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(v,b);m[t]=new g(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(v,b);m[t]=new g(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){m[e]=new g(e,1,!1,e.toLowerCase(),null,!1,!1)})),m.xlinkHref=new g("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){m[e]=new g(e,1,!1,e.toLowerCase(),null,!0,!0)}));var x=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),C=Symbol.for("react.strict_mode"),I=Symbol.for("react.profiler"),E=Symbol.for("react.provider"),N=Symbol.for("react.context"),T=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),A=Symbol.for("react.suspense_list"),O=Symbol.for("react.memo"),F=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var _=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var D=Symbol.iterator;function M(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=D&&e[D]||e["@@iterator"])?e:null}var P,L=Object.assign;function z(e){if(void 0===P)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);P=t&&t[1]||""}return"\n"+P+e}var B=!1;function W(e,t){if(!e||B)return"";B=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(l){var r=l}Reflect.construct(e,[],t)}else{try{t.call()}catch(l){r=l}e.call(t.prototype)}else{try{throw Error()}catch(l){r=l}e()}}catch(l){if(l&&r&&"string"===typeof l.stack){for(var a=l.stack.split("\n"),o=r.stack.split("\n"),i=a.length-1,s=o.length-1;1<=i&&0<=s&&a[i]!==o[s];)s--;for(;1<=i&&0<=s;i--,s--)if(a[i]!==o[s]){if(1!==i||1!==s)do{if(i--,0>--s||a[i]!==o[s]){var c="\n"+a[i].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}}while(1<=i&&0<=s);break}}}finally{B=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?z(e):""}function U(e){switch(e.tag){case 5:return z(e.type);case 16:return z("Lazy");case 13:return z("Suspense");case 19:return z("SuspenseList");case 0:case 2:case 15:return e=W(e.type,!1);case 11:return e=W(e.type.render,!1);case 1:return e=W(e.type,!0);default:return""}}function V(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case S:return"Fragment";case k:return"Portal";case I:return"Profiler";case C:return"StrictMode";case R:return"Suspense";case A:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case N:return(e.displayName||"Context")+".Consumer";case E:return(e._context.displayName||"Context")+".Provider";case T:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case O:return null!==(t=e.displayName||null)?t:V(e.type)||"Memo";case F:t=e._payload,e=e._init;try{return V(e(t))}catch(n){}}return null}function j(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return V(t);case 8:return t===C?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function H(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function G(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function q(e){e._valueTracker||(e._valueTracker=function(e){var t=G(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var a=n.get,o=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(e){r=""+e,o.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function K(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=G(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function X(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function $(e,t){var n=t.checked;return L({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Y(e,t){var n=null==t.defaultValue?"":t.defaultValue,r=null!=t.checked?t.checked:t.defaultChecked;n=H(null!=t.value?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Q(e,t){null!=(t=t.checked)&&y(e,"checked",t,!1)}function Z(e,t){Q(e,t);var n=H(t.value),r=t.type;if(null!=n)"number"===r?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===r||"reset"===r)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,H(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function J(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!("submit"!==r&&"reset"!==r||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&X(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,r){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&r&&(e[n].defaultSelected=!0)}else{for(n=""+H(n),t=null,a=0;a<e.length;a++){if(e[a].value===n)return e[a].selected=!0,void(r&&(e[a].defaultSelected=!0));null!==t||e[a].disabled||(t=e[a])}null!==t&&(t.selected=!0)}}function re(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(o(91));return L({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function ae(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(o(92));if(te(n)){if(1<n.length)throw Error(o(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:H(n)}}function oe(e,t){var n=H(t.value),r=H(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=r&&(e.defaultValue=""+r)}function ie(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function se(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ce(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?se(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var le,ue,de=(ue=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((le=le||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=le.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,r){MSApp.execUnsafeLocalFunction((function(){return ue(e,t)}))}:ue);function he(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function ge(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function me(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var r=0===n.indexOf("--"),a=ge(n,t[n],r);"float"===n&&(n="cssFloat"),r?e.setProperty(n,a):e[n]=a}}Object.keys(pe).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]}))}));var ve=L({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function be(e,t){if(t){if(ve[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(o(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(o(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(o(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(o(62))}}function ye(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var xe=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Se=null,Ce=null;function Ie(e){if(e=ya(e)){if("function"!==typeof ke)throw Error(o(280));var t=e.stateNode;t&&(t=wa(t),ke(e.stateNode,e.type,t))}}function Ee(e){Se?Ce?Ce.push(e):Ce=[e]:Se=e}function Ne(){if(Se){var e=Se,t=Ce;if(Ce=Se=null,Ie(e),t)for(e=0;e<t.length;e++)Ie(t[e])}}function Te(e,t){return e(t)}function Re(){}var Ae=!1;function Oe(e,t,n){if(Ae)return e(t,n);Ae=!0;try{return Te(e,t,n)}finally{Ae=!1,(null!==Se||null!==Ce)&&(Re(),Ne())}}function Fe(e,t){var n=e.stateNode;if(null===n)return null;var r=wa(n);if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(o(231,t,typeof n));return n}var _e=!1;if(u)try{var De={};Object.defineProperty(De,"passive",{get:function(){_e=!0}}),window.addEventListener("test",De,De),window.removeEventListener("test",De,De)}catch(ue){_e=!1}function Me(e,t,n,r,a,o,i,s,c){var l=Array.prototype.slice.call(arguments,3);try{t.apply(n,l)}catch(u){this.onError(u)}}var Pe=!1,Le=null,ze=!1,Be=null,We={onError:function(e){Pe=!0,Le=e}};function Ue(e,t,n,r,a,o,i,s,c){Pe=!1,Le=null,Me.apply(We,arguments)}function Ve(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function je(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function He(e){if(Ve(e)!==e)throw Error(o(188))}function Ge(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ve(e)))throw Error(o(188));return t!==e?null:e}for(var n=e,r=t;;){var a=n.return;if(null===a)break;var i=a.alternate;if(null===i){if(null!==(r=a.return)){n=r;continue}break}if(a.child===i.child){for(i=a.child;i;){if(i===n)return He(a),e;if(i===r)return He(a),t;i=i.sibling}throw Error(o(188))}if(n.return!==r.return)n=a,r=i;else{for(var s=!1,c=a.child;c;){if(c===n){s=!0,n=a,r=i;break}if(c===r){s=!0,r=a,n=i;break}c=c.sibling}if(!s){for(c=i.child;c;){if(c===n){s=!0,n=i,r=a;break}if(c===r){s=!0,r=i,n=a;break}c=c.sibling}if(!s)throw Error(o(189))}}if(n.alternate!==r)throw Error(o(190))}if(3!==n.tag)throw Error(o(188));return n.stateNode.current===n?e:t}(e))?qe(e):null}function qe(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=qe(e);if(null!==t)return t;e=e.sibling}return null}var Ke=a.unstable_scheduleCallback,Xe=a.unstable_cancelCallback,$e=a.unstable_shouldYield,Ye=a.unstable_requestPaint,Qe=a.unstable_now,Ze=a.unstable_getCurrentPriorityLevel,Je=a.unstable_ImmediatePriority,et=a.unstable_UserBlockingPriority,tt=a.unstable_NormalPriority,nt=a.unstable_LowPriority,rt=a.unstable_IdlePriority,at=null,ot=null;var it=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(st(e)/ct|0)|0},st=Math.log,ct=Math.LN2;var lt=64,ut=4194304;function dt(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function ht(e,t){var n=e.pendingLanes;if(0===n)return 0;var r=0,a=e.suspendedLanes,o=e.pingedLanes,i=268435455&n;if(0!==i){var s=i&~a;0!==s?r=dt(s):0!==(o&=i)&&(r=dt(o))}else 0!==(i=n&~a)?r=dt(i):0!==o&&(r=dt(o));if(0===r)return 0;if(0!==t&&t!==r&&0===(t&a)&&((a=r&-r)>=(o=t&-t)||16===a&&0!==(4194240&o)))return t;if(0!==(4&r)&&(r|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=r;0<t;)a=1<<(n=31-it(t)),r|=e[n],t&=~a;return r}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function gt(){var e=lt;return 0===(4194240&(lt<<=1))&&(lt=64),e}function mt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function vt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-it(t)]=n}function bt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-it(n),a=1<<r;a&t|e[r]&t&&(e[r]|=t),n&=~a}}var yt=0;function xt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var wt,kt,St,Ct,It,Et=!1,Nt=[],Tt=null,Rt=null,At=null,Ot=new Map,Ft=new Map,_t=[],Dt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Mt(e,t){switch(e){case"focusin":case"focusout":Tt=null;break;case"dragenter":case"dragleave":Rt=null;break;case"mouseover":case"mouseout":At=null;break;case"pointerover":case"pointerout":Ot.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ft.delete(t.pointerId)}}function Pt(e,t,n,r,a,o){return null===e||e.nativeEvent!==o?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:o,targetContainers:[a]},null!==t&&(null!==(t=ya(t))&&kt(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==a&&-1===t.indexOf(a)&&t.push(a),e)}function Lt(e){var t=ba(e.target);if(null!==t){var n=Ve(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=je(n)))return e.blockedOn=t,void It(e.priority,(function(){St(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function zt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=$t(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=ya(n))&&kt(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);xe=r,n.target.dispatchEvent(r),xe=null,t.shift()}return!0}function Bt(e,t,n){zt(e)&&n.delete(t)}function Wt(){Et=!1,null!==Tt&&zt(Tt)&&(Tt=null),null!==Rt&&zt(Rt)&&(Rt=null),null!==At&&zt(At)&&(At=null),Ot.forEach(Bt),Ft.forEach(Bt)}function Ut(e,t){e.blockedOn===t&&(e.blockedOn=null,Et||(Et=!0,a.unstable_scheduleCallback(a.unstable_NormalPriority,Wt)))}function Vt(e){function t(t){return Ut(t,e)}if(0<Nt.length){Ut(Nt[0],e);for(var n=1;n<Nt.length;n++){var r=Nt[n];r.blockedOn===e&&(r.blockedOn=null)}}for(null!==Tt&&Ut(Tt,e),null!==Rt&&Ut(Rt,e),null!==At&&Ut(At,e),Ot.forEach(t),Ft.forEach(t),n=0;n<_t.length;n++)(r=_t[n]).blockedOn===e&&(r.blockedOn=null);for(;0<_t.length&&null===(n=_t[0]).blockedOn;)Lt(n),null===n.blockedOn&&_t.shift()}var jt=x.ReactCurrentBatchConfig,Ht=!0;function Gt(e,t,n,r){var a=yt,o=jt.transition;jt.transition=null;try{yt=1,Kt(e,t,n,r)}finally{yt=a,jt.transition=o}}function qt(e,t,n,r){var a=yt,o=jt.transition;jt.transition=null;try{yt=4,Kt(e,t,n,r)}finally{yt=a,jt.transition=o}}function Kt(e,t,n,r){if(Ht){var a=$t(e,t,n,r);if(null===a)Hr(e,t,r,Xt,n),Mt(e,r);else if(function(e,t,n,r,a){switch(t){case"focusin":return Tt=Pt(Tt,e,t,n,r,a),!0;case"dragenter":return Rt=Pt(Rt,e,t,n,r,a),!0;case"mouseover":return At=Pt(At,e,t,n,r,a),!0;case"pointerover":var o=a.pointerId;return Ot.set(o,Pt(Ot.get(o)||null,e,t,n,r,a)),!0;case"gotpointercapture":return o=a.pointerId,Ft.set(o,Pt(Ft.get(o)||null,e,t,n,r,a)),!0}return!1}(a,e,t,n,r))r.stopPropagation();else if(Mt(e,r),4&t&&-1<Dt.indexOf(e)){for(;null!==a;){var o=ya(a);if(null!==o&&wt(o),null===(o=$t(e,t,n,r))&&Hr(e,t,r,Xt,n),o===a)break;a=o}null!==a&&r.stopPropagation()}else Hr(e,t,r,null,n)}}var Xt=null;function $t(e,t,n,r){if(Xt=null,null!==(e=ba(e=we(r))))if(null===(t=Ve(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=je(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Xt=e,null}function Yt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Ze()){case Je:return 1;case et:return 4;case tt:case nt:return 16;case rt:return 536870912;default:return 16}default:return 16}}var Qt=null,Zt=null,Jt=null;function en(){if(Jt)return Jt;var e,t,n=Zt,r=n.length,a="value"in Qt?Qt.value:Qt.textContent,o=a.length;for(e=0;e<r&&n[e]===a[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===a[o-t];t++);return Jt=a.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function rn(){return!1}function an(e){function t(t,n,r,a,o){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=a,this.target=o,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(a):a[i]);return this.isDefaultPrevented=(null!=a.defaultPrevented?a.defaultPrevented:!1===a.returnValue)?nn:rn,this.isPropagationStopped=rn,this}return L(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var on,sn,cn,ln={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},un=an(ln),dn=L({},ln,{view:0,detail:0}),hn=an(dn),pn=L({},dn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:In,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==cn&&(cn&&"mousemove"===e.type?(on=e.screenX-cn.screenX,sn=e.screenY-cn.screenY):sn=on=0,cn=e),on)},movementY:function(e){return"movementY"in e?e.movementY:sn}}),fn=an(pn),gn=an(L({},pn,{dataTransfer:0})),mn=an(L({},dn,{relatedTarget:0})),vn=an(L({},ln,{animationName:0,elapsedTime:0,pseudoElement:0})),bn=L({},ln,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),yn=an(bn),xn=an(L({},ln,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Cn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sn[e])&&!!t[e]}function In(){return Cn}var En=L({},dn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:In,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Nn=an(En),Tn=an(L({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Rn=an(L({},dn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:In})),An=an(L({},ln,{propertyName:0,elapsedTime:0,pseudoElement:0})),On=L({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Fn=an(On),_n=[9,13,27,32],Dn=u&&"CompositionEvent"in window,Mn=null;u&&"documentMode"in document&&(Mn=document.documentMode);var Pn=u&&"TextEvent"in window&&!Mn,Ln=u&&(!Dn||Mn&&8<Mn&&11>=Mn),zn=String.fromCharCode(32),Bn=!1;function Wn(e,t){switch(e){case"keyup":return-1!==_n.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Un(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Vn=!1;var jn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Hn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!jn[e.type]:"textarea"===t}function Gn(e,t,n,r){Ee(r),0<(t=qr(t,"onChange")).length&&(n=new un("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var qn=null,Kn=null;function Xn(e){zr(e,0)}function $n(e){if(K(xa(e)))return e}function Yn(e,t){if("change"===e)return t}var Qn=!1;if(u){var Zn;if(u){var Jn="oninput"in document;if(!Jn){var er=document.createElement("div");er.setAttribute("oninput","return;"),Jn="function"===typeof er.oninput}Zn=Jn}else Zn=!1;Qn=Zn&&(!document.documentMode||9<document.documentMode)}function tr(){qn&&(qn.detachEvent("onpropertychange",nr),Kn=qn=null)}function nr(e){if("value"===e.propertyName&&$n(Kn)){var t=[];Gn(t,Kn,e,we(e)),Oe(Xn,t)}}function rr(e,t,n){"focusin"===e?(tr(),Kn=n,(qn=t).attachEvent("onpropertychange",nr)):"focusout"===e&&tr()}function ar(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return $n(Kn)}function or(e,t){if("click"===e)return $n(t)}function ir(e,t){if("input"===e||"change"===e)return $n(t)}var sr="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function cr(e,t){if(sr(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!d.call(t,a)||!sr(e[a],t[a]))return!1}return!0}function lr(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ur(e,t){var n,r=lr(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=lr(r)}}function dr(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?dr(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function hr(){for(var e=window,t=X();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(r){n=!1}if(!n)break;t=X((e=t.contentWindow).document)}return t}function pr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fr(e){var t=hr(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&dr(n.ownerDocument.documentElement,n)){if(null!==r&&pr(n))if(t=r.start,void 0===(e=r.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var a=n.textContent.length,o=Math.min(r.start,a);r=void 0===r.end?o:Math.min(r.end,a),!e.extend&&o>r&&(a=r,r=o,o=a),a=ur(n,o);var i=ur(n,r);a&&i&&(1!==e.rangeCount||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&((t=t.createRange()).setStart(a.node,a.offset),e.removeAllRanges(),o>r?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var gr=u&&"documentMode"in document&&11>=document.documentMode,mr=null,vr=null,br=null,yr=!1;function xr(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;yr||null==mr||mr!==X(r)||("selectionStart"in(r=mr)&&pr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},br&&cr(br,r)||(br=r,0<(r=qr(vr,"onSelect")).length&&(t=new un("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=mr)))}function wr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var kr={animationend:wr("Animation","AnimationEnd"),animationiteration:wr("Animation","AnimationIteration"),animationstart:wr("Animation","AnimationStart"),transitionend:wr("Transition","TransitionEnd")},Sr={},Cr={};function Ir(e){if(Sr[e])return Sr[e];if(!kr[e])return e;var t,n=kr[e];for(t in n)if(n.hasOwnProperty(t)&&t in Cr)return Sr[e]=n[t];return e}u&&(Cr=document.createElement("div").style,"AnimationEvent"in window||(delete kr.animationend.animation,delete kr.animationiteration.animation,delete kr.animationstart.animation),"TransitionEvent"in window||delete kr.transitionend.transition);var Er=Ir("animationend"),Nr=Ir("animationiteration"),Tr=Ir("animationstart"),Rr=Ir("transitionend"),Ar=new Map,Or="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Fr(e,t){Ar.set(e,t),c(t,[e])}for(var _r=0;_r<Or.length;_r++){var Dr=Or[_r];Fr(Dr.toLowerCase(),"on"+(Dr[0].toUpperCase()+Dr.slice(1)))}Fr(Er,"onAnimationEnd"),Fr(Nr,"onAnimationIteration"),Fr(Tr,"onAnimationStart"),Fr("dblclick","onDoubleClick"),Fr("focusin","onFocus"),Fr("focusout","onBlur"),Fr(Rr,"onTransitionEnd"),l("onMouseEnter",["mouseout","mouseover"]),l("onMouseLeave",["mouseout","mouseover"]),l("onPointerEnter",["pointerout","pointerover"]),l("onPointerLeave",["pointerout","pointerover"]),c("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),c("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),c("onBeforeInput",["compositionend","keypress","textInput","paste"]),c("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Mr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pr=new Set("cancel close invalid load scroll toggle".split(" ").concat(Mr));function Lr(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,r,a,i,s,c,l){if(Ue.apply(this,arguments),Pe){if(!Pe)throw Error(o(198));var u=Le;Pe=!1,Le=null,ze||(ze=!0,Be=u)}}(r,t,void 0,e),e.currentTarget=null}function zr(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var r=e[n],a=r.event;r=r.listeners;e:{var o=void 0;if(t)for(var i=r.length-1;0<=i;i--){var s=r[i],c=s.instance,l=s.currentTarget;if(s=s.listener,c!==o&&a.isPropagationStopped())break e;Lr(a,s,l),o=c}else for(i=0;i<r.length;i++){if(c=(s=r[i]).instance,l=s.currentTarget,s=s.listener,c!==o&&a.isPropagationStopped())break e;Lr(a,s,l),o=c}}}if(ze)throw e=Be,ze=!1,Be=null,e}function Br(e,t){var n=t[ga];void 0===n&&(n=t[ga]=new Set);var r=e+"__bubble";n.has(r)||(jr(t,e,2,!1),n.add(r))}function Wr(e,t,n){var r=0;t&&(r|=4),jr(n,e,r,t)}var Ur="_reactListening"+Math.random().toString(36).slice(2);function Vr(e){if(!e[Ur]){e[Ur]=!0,i.forEach((function(t){"selectionchange"!==t&&(Pr.has(t)||Wr(t,!1,e),Wr(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Ur]||(t[Ur]=!0,Wr("selectionchange",!1,t))}}function jr(e,t,n,r){switch(Yt(t)){case 1:var a=Gt;break;case 4:a=qt;break;default:a=Kt}n=a.bind(null,t,n,e),a=void 0,!_e||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(a=!0),r?void 0!==a?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):void 0!==a?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function Hr(e,t,n,r,a){var o=r;if(0===(1&t)&&0===(2&t)&&null!==r)e:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var s=r.stateNode.containerInfo;if(s===a||8===s.nodeType&&s.parentNode===a)break;if(4===i)for(i=r.return;null!==i;){var c=i.tag;if((3===c||4===c)&&((c=i.stateNode.containerInfo)===a||8===c.nodeType&&c.parentNode===a))return;i=i.return}for(;null!==s;){if(null===(i=ba(s)))return;if(5===(c=i.tag)||6===c){r=o=i;continue e}s=s.parentNode}}r=r.return}Oe((function(){var r=o,a=we(n),i=[];e:{var s=Ar.get(e);if(void 0!==s){var c=un,l=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":c=Nn;break;case"focusin":l="focus",c=mn;break;case"focusout":l="blur",c=mn;break;case"beforeblur":case"afterblur":c=mn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":c=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":c=gn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":c=Rn;break;case Er:case Nr:case Tr:c=vn;break;case Rr:c=An;break;case"scroll":c=hn;break;case"wheel":c=Fn;break;case"copy":case"cut":case"paste":c=yn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":c=Tn}var u=0!==(4&t),d=!u&&"scroll"===e,h=u?null!==s?s+"Capture":null:s;u=[];for(var p,f=r;null!==f;){var g=(p=f).stateNode;if(5===p.tag&&null!==g&&(p=g,null!==h&&(null!=(g=Fe(f,h))&&u.push(Gr(f,g,p)))),d)break;f=f.return}0<u.length&&(s=new c(s,l,null,n,a),i.push({event:s,listeners:u}))}}if(0===(7&t)){if(c="mouseout"===e||"pointerout"===e,(!(s="mouseover"===e||"pointerover"===e)||n===xe||!(l=n.relatedTarget||n.fromElement)||!ba(l)&&!l[fa])&&(c||s)&&(s=a.window===a?a:(s=a.ownerDocument)?s.defaultView||s.parentWindow:window,c?(c=r,null!==(l=(l=n.relatedTarget||n.toElement)?ba(l):null)&&(l!==(d=Ve(l))||5!==l.tag&&6!==l.tag)&&(l=null)):(c=null,l=r),c!==l)){if(u=fn,g="onMouseLeave",h="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(u=Tn,g="onPointerLeave",h="onPointerEnter",f="pointer"),d=null==c?s:xa(c),p=null==l?s:xa(l),(s=new u(g,f+"leave",c,n,a)).target=d,s.relatedTarget=p,g=null,ba(a)===r&&((u=new u(h,f+"enter",l,n,a)).target=p,u.relatedTarget=d,g=u),d=g,c&&l)e:{for(h=l,f=0,p=u=c;p;p=Kr(p))f++;for(p=0,g=h;g;g=Kr(g))p++;for(;0<f-p;)u=Kr(u),f--;for(;0<p-f;)h=Kr(h),p--;for(;f--;){if(u===h||null!==h&&u===h.alternate)break e;u=Kr(u),h=Kr(h)}u=null}else u=null;null!==c&&Xr(i,s,c,u,!1),null!==l&&null!==d&&Xr(i,d,l,u,!0)}if("select"===(c=(s=r?xa(r):window).nodeName&&s.nodeName.toLowerCase())||"input"===c&&"file"===s.type)var m=Yn;else if(Hn(s))if(Qn)m=ir;else{m=ar;var v=rr}else(c=s.nodeName)&&"input"===c.toLowerCase()&&("checkbox"===s.type||"radio"===s.type)&&(m=or);switch(m&&(m=m(e,r))?Gn(i,m,n,a):(v&&v(e,s,r),"focusout"===e&&(v=s._wrapperState)&&v.controlled&&"number"===s.type&&ee(s,"number",s.value)),v=r?xa(r):window,e){case"focusin":(Hn(v)||"true"===v.contentEditable)&&(mr=v,vr=r,br=null);break;case"focusout":br=vr=mr=null;break;case"mousedown":yr=!0;break;case"contextmenu":case"mouseup":case"dragend":yr=!1,xr(i,n,a);break;case"selectionchange":if(gr)break;case"keydown":case"keyup":xr(i,n,a)}var b;if(Dn)e:{switch(e){case"compositionstart":var y="onCompositionStart";break e;case"compositionend":y="onCompositionEnd";break e;case"compositionupdate":y="onCompositionUpdate";break e}y=void 0}else Vn?Wn(e,n)&&(y="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(y="onCompositionStart");y&&(Ln&&"ko"!==n.locale&&(Vn||"onCompositionStart"!==y?"onCompositionEnd"===y&&Vn&&(b=en()):(Zt="value"in(Qt=a)?Qt.value:Qt.textContent,Vn=!0)),0<(v=qr(r,y)).length&&(y=new xn(y,e,null,n,a),i.push({event:y,listeners:v}),b?y.data=b:null!==(b=Un(n))&&(y.data=b))),(b=Pn?function(e,t){switch(e){case"compositionend":return Un(t);case"keypress":return 32!==t.which?null:(Bn=!0,zn);case"textInput":return(e=t.data)===zn&&Bn?null:e;default:return null}}(e,n):function(e,t){if(Vn)return"compositionend"===e||!Dn&&Wn(e,t)?(e=en(),Jt=Zt=Qt=null,Vn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Ln&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(r=qr(r,"onBeforeInput")).length&&(a=new xn("onBeforeInput","beforeinput",null,n,a),i.push({event:a,listeners:r}),a.data=b))}zr(i,t)}))}function Gr(e,t,n){return{instance:e,listener:t,currentTarget:n}}function qr(e,t){for(var n=t+"Capture",r=[];null!==e;){var a=e,o=a.stateNode;5===a.tag&&null!==o&&(a=o,null!=(o=Fe(e,n))&&r.unshift(Gr(e,o,a)),null!=(o=Fe(e,t))&&r.push(Gr(e,o,a))),e=e.return}return r}function Kr(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Xr(e,t,n,r,a){for(var o=t._reactName,i=[];null!==n&&n!==r;){var s=n,c=s.alternate,l=s.stateNode;if(null!==c&&c===r)break;5===s.tag&&null!==l&&(s=l,a?null!=(c=Fe(n,o))&&i.unshift(Gr(n,c,s)):a||null!=(c=Fe(n,o))&&i.push(Gr(n,c,s))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var $r=/\r\n?/g,Yr=/\u0000|\uFFFD/g;function Qr(e){return("string"===typeof e?e:""+e).replace($r,"\n").replace(Yr,"")}function Zr(e,t,n){if(t=Qr(t),Qr(e)!==t&&n)throw Error(o(425))}function Jr(){}var ea=null,ta=null;function na(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ra="function"===typeof setTimeout?setTimeout:void 0,aa="function"===typeof clearTimeout?clearTimeout:void 0,oa="function"===typeof Promise?Promise:void 0,ia="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof oa?function(e){return oa.resolve(null).then(e).catch(sa)}:ra;function sa(e){setTimeout((function(){throw e}))}function ca(e,t){var n=t,r=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0===r)return e.removeChild(a),void Vt(t);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=a}while(n);Vt(t)}function la(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function ua(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var da=Math.random().toString(36).slice(2),ha="__reactFiber$"+da,pa="__reactProps$"+da,fa="__reactContainer$"+da,ga="__reactEvents$"+da,ma="__reactListeners$"+da,va="__reactHandles$"+da;function ba(e){var t=e[ha];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fa]||n[ha]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=ua(e);null!==e;){if(n=e[ha])return n;e=ua(e)}return t}n=(e=n).parentNode}return null}function ya(e){return!(e=e[ha]||e[fa])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function xa(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(o(33))}function wa(e){return e[pa]||null}var ka=[],Sa=-1;function Ca(e){return{current:e}}function Ia(e){0>Sa||(e.current=ka[Sa],ka[Sa]=null,Sa--)}function Ea(e,t){Sa++,ka[Sa]=e.current,e.current=t}var Na={},Ta=Ca(Na),Ra=Ca(!1),Aa=Na;function Oa(e,t){var n=e.type.contextTypes;if(!n)return Na;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var a,o={};for(a in n)o[a]=t[a];return r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=o),o}function Fa(e){return null!==(e=e.childContextTypes)&&void 0!==e}function _a(){Ia(Ra),Ia(Ta)}function Da(e,t,n){if(Ta.current!==Na)throw Error(o(168));Ea(Ta,t),Ea(Ra,n)}function Ma(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,"function"!==typeof r.getChildContext)return n;for(var a in r=r.getChildContext())if(!(a in t))throw Error(o(108,j(e)||"Unknown",a));return L({},n,r)}function Pa(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Na,Aa=Ta.current,Ea(Ta,e),Ea(Ra,Ra.current),!0}function La(e,t,n){var r=e.stateNode;if(!r)throw Error(o(169));n?(e=Ma(e,t,Aa),r.__reactInternalMemoizedMergedChildContext=e,Ia(Ra),Ia(Ta),Ea(Ta,e)):Ia(Ra),Ea(Ra,n)}var za=null,Ba=!1,Wa=!1;function Ua(e){null===za?za=[e]:za.push(e)}function Va(){if(!Wa&&null!==za){Wa=!0;var e=0,t=yt;try{var n=za;for(yt=1;e<n.length;e++){var r=n[e];do{r=r(!0)}while(null!==r)}za=null,Ba=!1}catch(a){throw null!==za&&(za=za.slice(e+1)),Ke(Je,Va),a}finally{yt=t,Wa=!1}}return null}var ja=[],Ha=0,Ga=null,qa=0,Ka=[],Xa=0,$a=null,Ya=1,Qa="";function Za(e,t){ja[Ha++]=qa,ja[Ha++]=Ga,Ga=e,qa=t}function Ja(e,t,n){Ka[Xa++]=Ya,Ka[Xa++]=Qa,Ka[Xa++]=$a,$a=e;var r=Ya;e=Qa;var a=32-it(r)-1;r&=~(1<<a),n+=1;var o=32-it(t)+a;if(30<o){var i=a-a%5;o=(r&(1<<i)-1).toString(32),r>>=i,a-=i,Ya=1<<32-it(t)+a|n<<a|r,Qa=o+e}else Ya=1<<o|n<<a|r,Qa=e}function eo(e){null!==e.return&&(Za(e,1),Ja(e,1,0))}function to(e){for(;e===Ga;)Ga=ja[--Ha],ja[Ha]=null,qa=ja[--Ha],ja[Ha]=null;for(;e===$a;)$a=Ka[--Xa],Ka[Xa]=null,Qa=Ka[--Xa],Ka[Xa]=null,Ya=Ka[--Xa],Ka[Xa]=null}var no=null,ro=null,ao=!1,oo=null;function io(e,t){var n=Ol(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function so(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,no=e,ro=la(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,no=e,ro=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==$a?{id:Ya,overflow:Qa}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=Ol(18,null,null,0)).stateNode=t,n.return=e,e.child=n,no=e,ro=null,!0);default:return!1}}function co(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function lo(e){if(ao){var t=ro;if(t){var n=t;if(!so(e,t)){if(co(e))throw Error(o(418));t=la(n.nextSibling);var r=no;t&&so(e,t)?io(r,n):(e.flags=-4097&e.flags|2,ao=!1,no=e)}}else{if(co(e))throw Error(o(418));e.flags=-4097&e.flags|2,ao=!1,no=e}}}function uo(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;no=e}function ho(e){if(e!==no)return!1;if(!ao)return uo(e),ao=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!na(e.type,e.memoizedProps)),t&&(t=ro)){if(co(e))throw po(),Error(o(418));for(;t;)io(e,t),t=la(t.nextSibling)}if(uo(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(o(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){ro=la(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}ro=null}}else ro=no?la(e.stateNode.nextSibling):null;return!0}function po(){for(var e=ro;e;)e=la(e.nextSibling)}function fo(){ro=no=null,ao=!1}function go(e){null===oo?oo=[e]:oo.push(e)}var mo=x.ReactCurrentBatchConfig;function vo(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(o(309));var r=n.stateNode}if(!r)throw Error(o(147,e));var a=r,i=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===i?t.ref:(t=function(e){var t=a.refs;null===e?delete t[i]:t[i]=e},t._stringRef=i,t)}if("string"!==typeof e)throw Error(o(284));if(!n._owner)throw Error(o(290,e))}return e}function bo(e,t){throw e=Object.prototype.toString.call(t),Error(o(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function yo(e){return(0,e._init)(e._payload)}function xo(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function a(e,t){return(e=_l(e,t)).index=0,e.sibling=null,e}function i(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=2,n):r:(t.flags|=2,n):(t.flags|=1048576,n)}function s(t){return e&&null===t.alternate&&(t.flags|=2),t}function c(e,t,n,r){return null===t||6!==t.tag?((t=Ll(n,e.mode,r)).return=e,t):((t=a(t,n)).return=e,t)}function l(e,t,n,r){var o=n.type;return o===S?d(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===o||"object"===typeof o&&null!==o&&o.$$typeof===F&&yo(o)===t.type)?((r=a(t,n.props)).ref=vo(e,t,n),r.return=e,r):((r=Dl(n.type,n.key,n.props,null,e.mode,r)).ref=vo(e,t,n),r.return=e,r)}function u(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=zl(n,e.mode,r)).return=e,t):((t=a(t,n.children||[])).return=e,t)}function d(e,t,n,r,o){return null===t||7!==t.tag?((t=Ml(n,e.mode,r,o)).return=e,t):((t=a(t,n)).return=e,t)}function h(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=Ll(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Dl(t.type,t.key,t.props,null,e.mode,n)).ref=vo(e,null,t),n.return=e,n;case k:return(t=zl(t,e.mode,n)).return=e,t;case F:return h(e,(0,t._init)(t._payload),n)}if(te(t)||M(t))return(t=Ml(t,e.mode,n,null)).return=e,t;bo(e,t)}return null}function p(e,t,n,r){var a=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==a?null:c(e,t,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===a?l(e,t,n,r):null;case k:return n.key===a?u(e,t,n,r):null;case F:return p(e,t,(a=n._init)(n._payload),r)}if(te(n)||M(n))return null!==a?null:d(e,t,n,r,null);bo(e,n)}return null}function f(e,t,n,r,a){if("string"===typeof r&&""!==r||"number"===typeof r)return c(t,e=e.get(n)||null,""+r,a);if("object"===typeof r&&null!==r){switch(r.$$typeof){case w:return l(t,e=e.get(null===r.key?n:r.key)||null,r,a);case k:return u(t,e=e.get(null===r.key?n:r.key)||null,r,a);case F:return f(e,t,n,(0,r._init)(r._payload),a)}if(te(r)||M(r))return d(t,e=e.get(n)||null,r,a,null);bo(t,r)}return null}function g(a,o,s,c){for(var l=null,u=null,d=o,g=o=0,m=null;null!==d&&g<s.length;g++){d.index>g?(m=d,d=null):m=d.sibling;var v=p(a,d,s[g],c);if(null===v){null===d&&(d=m);break}e&&d&&null===v.alternate&&t(a,d),o=i(v,o,g),null===u?l=v:u.sibling=v,u=v,d=m}if(g===s.length)return n(a,d),ao&&Za(a,g),l;if(null===d){for(;g<s.length;g++)null!==(d=h(a,s[g],c))&&(o=i(d,o,g),null===u?l=d:u.sibling=d,u=d);return ao&&Za(a,g),l}for(d=r(a,d);g<s.length;g++)null!==(m=f(d,a,g,s[g],c))&&(e&&null!==m.alternate&&d.delete(null===m.key?g:m.key),o=i(m,o,g),null===u?l=m:u.sibling=m,u=m);return e&&d.forEach((function(e){return t(a,e)})),ao&&Za(a,g),l}function m(a,s,c,l){var u=M(c);if("function"!==typeof u)throw Error(o(150));if(null==(c=u.call(c)))throw Error(o(151));for(var d=u=null,g=s,m=s=0,v=null,b=c.next();null!==g&&!b.done;m++,b=c.next()){g.index>m?(v=g,g=null):v=g.sibling;var y=p(a,g,b.value,l);if(null===y){null===g&&(g=v);break}e&&g&&null===y.alternate&&t(a,g),s=i(y,s,m),null===d?u=y:d.sibling=y,d=y,g=v}if(b.done)return n(a,g),ao&&Za(a,m),u;if(null===g){for(;!b.done;m++,b=c.next())null!==(b=h(a,b.value,l))&&(s=i(b,s,m),null===d?u=b:d.sibling=b,d=b);return ao&&Za(a,m),u}for(g=r(a,g);!b.done;m++,b=c.next())null!==(b=f(g,a,m,b.value,l))&&(e&&null!==b.alternate&&g.delete(null===b.key?m:b.key),s=i(b,s,m),null===d?u=b:d.sibling=b,d=b);return e&&g.forEach((function(e){return t(a,e)})),ao&&Za(a,m),u}return function e(r,o,i,c){if("object"===typeof i&&null!==i&&i.type===S&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case w:e:{for(var l=i.key,u=o;null!==u;){if(u.key===l){if((l=i.type)===S){if(7===u.tag){n(r,u.sibling),(o=a(u,i.props.children)).return=r,r=o;break e}}else if(u.elementType===l||"object"===typeof l&&null!==l&&l.$$typeof===F&&yo(l)===u.type){n(r,u.sibling),(o=a(u,i.props)).ref=vo(r,u,i),o.return=r,r=o;break e}n(r,u);break}t(r,u),u=u.sibling}i.type===S?((o=Ml(i.props.children,r.mode,c,i.key)).return=r,r=o):((c=Dl(i.type,i.key,i.props,null,r.mode,c)).ref=vo(r,o,i),c.return=r,r=c)}return s(r);case k:e:{for(u=i.key;null!==o;){if(o.key===u){if(4===o.tag&&o.stateNode.containerInfo===i.containerInfo&&o.stateNode.implementation===i.implementation){n(r,o.sibling),(o=a(o,i.children||[])).return=r,r=o;break e}n(r,o);break}t(r,o),o=o.sibling}(o=zl(i,r.mode,c)).return=r,r=o}return s(r);case F:return e(r,o,(u=i._init)(i._payload),c)}if(te(i))return g(r,o,i,c);if(M(i))return m(r,o,i,c);bo(r,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==o&&6===o.tag?(n(r,o.sibling),(o=a(o,i)).return=r,r=o):(n(r,o),(o=Ll(i,r.mode,c)).return=r,r=o),s(r)):n(r,o)}}var wo=xo(!0),ko=xo(!1),So=Ca(null),Co=null,Io=null,Eo=null;function No(){Eo=Io=Co=null}function To(e){var t=So.current;Ia(So),e._currentValue=t}function Ro(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Ao(e,t){Co=e,Eo=Io=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(ys=!0),e.firstContext=null)}function Oo(e){var t=e._currentValue;if(Eo!==e)if(e={context:e,memoizedValue:t,next:null},null===Io){if(null===Co)throw Error(o(308));Io=e,Co.dependencies={lanes:0,firstContext:e}}else Io=Io.next=e;return t}var Fo=null;function _o(e){null===Fo?Fo=[e]:Fo.push(e)}function Do(e,t,n,r){var a=t.interleaved;return null===a?(n.next=n,_o(t)):(n.next=a.next,a.next=n),t.interleaved=n,Mo(e,r)}function Mo(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Po=!1;function Lo(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function zo(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Bo(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Wo(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&Tc)){var a=r.pending;return null===a?t.next=t:(t.next=a.next,a.next=t),r.pending=t,Mo(e,n)}return null===(a=r.interleaved)?(t.next=t,_o(r)):(t.next=a.next,a.next=t),r.interleaved=t,Mo(e,n)}function Uo(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}function Vo(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var a=null,o=null;if(null!==(n=n.firstBaseUpdate)){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===o?a=o=i:o=o.next=i,n=n.next}while(null!==n);null===o?a=o=t:o=o.next=t}else a=o=t;return n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:o,shared:r.shared,effects:r.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function jo(e,t,n,r){var a=e.updateQueue;Po=!1;var o=a.firstBaseUpdate,i=a.lastBaseUpdate,s=a.shared.pending;if(null!==s){a.shared.pending=null;var c=s,l=c.next;c.next=null,null===i?o=l:i.next=l,i=c;var u=e.alternate;null!==u&&((s=(u=u.updateQueue).lastBaseUpdate)!==i&&(null===s?u.firstBaseUpdate=l:s.next=l,u.lastBaseUpdate=c))}if(null!==o){var d=a.baseState;for(i=0,u=l=c=null,s=o;;){var h=s.lane,p=s.eventTime;if((r&h)===h){null!==u&&(u=u.next={eventTime:p,lane:0,tag:s.tag,payload:s.payload,callback:s.callback,next:null});e:{var f=e,g=s;switch(h=t,p=n,g.tag){case 1:if("function"===typeof(f=g.payload)){d=f.call(p,d,h);break e}d=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(h="function"===typeof(f=g.payload)?f.call(p,d,h):f)||void 0===h)break e;d=L({},d,h);break e;case 2:Po=!0}}null!==s.callback&&0!==s.lane&&(e.flags|=64,null===(h=a.effects)?a.effects=[s]:h.push(s))}else p={eventTime:p,lane:h,tag:s.tag,payload:s.payload,callback:s.callback,next:null},null===u?(l=u=p,c=d):u=u.next=p,i|=h;if(null===(s=s.next)){if(null===(s=a.shared.pending))break;s=(h=s).next,h.next=null,a.lastBaseUpdate=h,a.shared.pending=null}}if(null===u&&(c=d),a.baseState=c,a.firstBaseUpdate=l,a.lastBaseUpdate=u,null!==(t=a.shared.interleaved)){a=t;do{i|=a.lane,a=a.next}while(a!==t)}else null===o&&(a.shared.lanes=0);Pc|=i,e.lanes=i,e.memoizedState=d}}function Ho(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var r=e[t],a=r.callback;if(null!==a){if(r.callback=null,r=n,"function"!==typeof a)throw Error(o(191,a));a.call(r)}}}var Go={},qo=Ca(Go),Ko=Ca(Go),Xo=Ca(Go);function $o(e){if(e===Go)throw Error(o(174));return e}function Yo(e,t){switch(Ea(Xo,t),Ea(Ko,e),Ea(qo,Go),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:ce(null,"");break;default:t=ce(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Ia(qo),Ea(qo,t)}function Qo(){Ia(qo),Ia(Ko),Ia(Xo)}function Zo(e){$o(Xo.current);var t=$o(qo.current),n=ce(t,e.type);t!==n&&(Ea(Ko,e),Ea(qo,n))}function Jo(e){Ko.current===e&&(Ia(qo),Ia(Ko))}var ei=Ca(0);function ti(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ni=[];function ri(){for(var e=0;e<ni.length;e++)ni[e]._workInProgressVersionPrimary=null;ni.length=0}var ai=x.ReactCurrentDispatcher,oi=x.ReactCurrentBatchConfig,ii=0,si=null,ci=null,li=null,ui=!1,di=!1,hi=0,pi=0;function fi(){throw Error(o(321))}function gi(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!sr(e[n],t[n]))return!1;return!0}function mi(e,t,n,r,a,i){if(ii=i,si=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,ai.current=null===e||null===e.memoizedState?Ji:es,e=n(r,a),di){i=0;do{if(di=!1,hi=0,25<=i)throw Error(o(301));i+=1,li=ci=null,t.updateQueue=null,ai.current=ts,e=n(r,a)}while(di)}if(ai.current=Zi,t=null!==ci&&null!==ci.next,ii=0,li=ci=si=null,ui=!1,t)throw Error(o(300));return e}function vi(){var e=0!==hi;return hi=0,e}function bi(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===li?si.memoizedState=li=e:li=li.next=e,li}function yi(){if(null===ci){var e=si.alternate;e=null!==e?e.memoizedState:null}else e=ci.next;var t=null===li?si.memoizedState:li.next;if(null!==t)li=t,ci=e;else{if(null===e)throw Error(o(310));e={memoizedState:(ci=e).memoizedState,baseState:ci.baseState,baseQueue:ci.baseQueue,queue:ci.queue,next:null},null===li?si.memoizedState=li=e:li=li.next=e}return li}function xi(e,t){return"function"===typeof t?t(e):t}function wi(e){var t=yi(),n=t.queue;if(null===n)throw Error(o(311));n.lastRenderedReducer=e;var r=ci,a=r.baseQueue,i=n.pending;if(null!==i){if(null!==a){var s=a.next;a.next=i.next,i.next=s}r.baseQueue=a=i,n.pending=null}if(null!==a){i=a.next,r=r.baseState;var c=s=null,l=null,u=i;do{var d=u.lane;if((ii&d)===d)null!==l&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),r=u.hasEagerState?u.eagerState:e(r,u.action);else{var h={lane:d,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===l?(c=l=h,s=r):l=l.next=h,si.lanes|=d,Pc|=d}u=u.next}while(null!==u&&u!==i);null===l?s=r:l.next=c,sr(r,t.memoizedState)||(ys=!0),t.memoizedState=r,t.baseState=s,t.baseQueue=l,n.lastRenderedState=r}if(null!==(e=n.interleaved)){a=e;do{i=a.lane,si.lanes|=i,Pc|=i,a=a.next}while(a!==e)}else null===a&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function ki(e){var t=yi(),n=t.queue;if(null===n)throw Error(o(311));n.lastRenderedReducer=e;var r=n.dispatch,a=n.pending,i=t.memoizedState;if(null!==a){n.pending=null;var s=a=a.next;do{i=e(i,s.action),s=s.next}while(s!==a);sr(i,t.memoizedState)||(ys=!0),t.memoizedState=i,null===t.baseQueue&&(t.baseState=i),n.lastRenderedState=i}return[i,r]}function Si(){}function Ci(e,t){var n=si,r=yi(),a=t(),i=!sr(r.memoizedState,a);if(i&&(r.memoizedState=a,ys=!0),r=r.queue,Pi(Ni.bind(null,n,r,e),[e]),r.getSnapshot!==t||i||null!==li&&1&li.memoizedState.tag){if(n.flags|=2048,Oi(9,Ei.bind(null,n,r,a,t),void 0,null),null===Rc)throw Error(o(349));0!==(30&ii)||Ii(n,t,a)}return a}function Ii(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=si.updateQueue)?(t={lastEffect:null,stores:null},si.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ei(e,t,n,r){t.value=n,t.getSnapshot=r,Ti(t)&&Ri(e)}function Ni(e,t,n){return n((function(){Ti(t)&&Ri(e)}))}function Ti(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!sr(e,n)}catch(r){return!0}}function Ri(e){var t=Mo(e,1);null!==t&&nl(t,e,1,-1)}function Ai(e){var t=bi();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:xi,lastRenderedState:e},t.queue=e,e=e.dispatch=Xi.bind(null,si,e),[t.memoizedState,e]}function Oi(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},null===(t=si.updateQueue)?(t={lastEffect:null,stores:null},si.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function Fi(){return yi().memoizedState}function _i(e,t,n,r){var a=bi();si.flags|=e,a.memoizedState=Oi(1|t,n,void 0,void 0===r?null:r)}function Di(e,t,n,r){var a=yi();r=void 0===r?null:r;var o=void 0;if(null!==ci){var i=ci.memoizedState;if(o=i.destroy,null!==r&&gi(r,i.deps))return void(a.memoizedState=Oi(t,n,o,r))}si.flags|=e,a.memoizedState=Oi(1|t,n,o,r)}function Mi(e,t){return _i(8390656,8,e,t)}function Pi(e,t){return Di(2048,8,e,t)}function Li(e,t){return Di(4,2,e,t)}function zi(e,t){return Di(4,4,e,t)}function Bi(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function Wi(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Di(4,4,Bi.bind(null,t,e),n)}function Ui(){}function Vi(e,t){var n=yi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&gi(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function ji(e,t){var n=yi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&gi(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Hi(e,t,n){return 0===(21&ii)?(e.baseState&&(e.baseState=!1,ys=!0),e.memoizedState=n):(sr(n,t)||(n=gt(),si.lanes|=n,Pc|=n,e.baseState=!0),t)}function Gi(e,t){var n=yt;yt=0!==n&&4>n?n:4,e(!0);var r=oi.transition;oi.transition={};try{e(!1),t()}finally{yt=n,oi.transition=r}}function qi(){return yi().memoizedState}function Ki(e,t,n){var r=tl(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},$i(e))Yi(t,n);else if(null!==(n=Do(e,t,n,r))){nl(n,e,r,el()),Qi(n,t,r)}}function Xi(e,t,n){var r=tl(e),a={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if($i(e))Yi(t,a);else{var o=e.alternate;if(0===e.lanes&&(null===o||0===o.lanes)&&null!==(o=t.lastRenderedReducer))try{var i=t.lastRenderedState,s=o(i,n);if(a.hasEagerState=!0,a.eagerState=s,sr(s,i)){var c=t.interleaved;return null===c?(a.next=a,_o(t)):(a.next=c.next,c.next=a),void(t.interleaved=a)}}catch(l){}null!==(n=Do(e,t,a,r))&&(nl(n,e,r,a=el()),Qi(n,t,r))}}function $i(e){var t=e.alternate;return e===si||null!==t&&t===si}function Yi(e,t){di=ui=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Qi(e,t,n){if(0!==(4194240&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}var Zi={readContext:Oo,useCallback:fi,useContext:fi,useEffect:fi,useImperativeHandle:fi,useInsertionEffect:fi,useLayoutEffect:fi,useMemo:fi,useReducer:fi,useRef:fi,useState:fi,useDebugValue:fi,useDeferredValue:fi,useTransition:fi,useMutableSource:fi,useSyncExternalStore:fi,useId:fi,unstable_isNewReconciler:!1},Ji={readContext:Oo,useCallback:function(e,t){return bi().memoizedState=[e,void 0===t?null:t],e},useContext:Oo,useEffect:Mi,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,_i(4194308,4,Bi.bind(null,t,e),n)},useLayoutEffect:function(e,t){return _i(4194308,4,e,t)},useInsertionEffect:function(e,t){return _i(4,2,e,t)},useMemo:function(e,t){var n=bi();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=bi();return t=void 0!==n?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=Ki.bind(null,si,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},bi().memoizedState=e},useState:Ai,useDebugValue:Ui,useDeferredValue:function(e){return bi().memoizedState=e},useTransition:function(){var e=Ai(!1),t=e[0];return e=Gi.bind(null,e[1]),bi().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=si,a=bi();if(ao){if(void 0===n)throw Error(o(407));n=n()}else{if(n=t(),null===Rc)throw Error(o(349));0!==(30&ii)||Ii(r,t,n)}a.memoizedState=n;var i={value:n,getSnapshot:t};return a.queue=i,Mi(Ni.bind(null,r,i,e),[e]),r.flags|=2048,Oi(9,Ei.bind(null,r,i,n,t),void 0,null),n},useId:function(){var e=bi(),t=Rc.identifierPrefix;if(ao){var n=Qa;t=":"+t+"R"+(n=(Ya&~(1<<32-it(Ya)-1)).toString(32)+n),0<(n=hi++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=pi++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},es={readContext:Oo,useCallback:Vi,useContext:Oo,useEffect:Pi,useImperativeHandle:Wi,useInsertionEffect:Li,useLayoutEffect:zi,useMemo:ji,useReducer:wi,useRef:Fi,useState:function(){return wi(xi)},useDebugValue:Ui,useDeferredValue:function(e){return Hi(yi(),ci.memoizedState,e)},useTransition:function(){return[wi(xi)[0],yi().memoizedState]},useMutableSource:Si,useSyncExternalStore:Ci,useId:qi,unstable_isNewReconciler:!1},ts={readContext:Oo,useCallback:Vi,useContext:Oo,useEffect:Pi,useImperativeHandle:Wi,useInsertionEffect:Li,useLayoutEffect:zi,useMemo:ji,useReducer:ki,useRef:Fi,useState:function(){return ki(xi)},useDebugValue:Ui,useDeferredValue:function(e){var t=yi();return null===ci?t.memoizedState=e:Hi(t,ci.memoizedState,e)},useTransition:function(){return[ki(xi)[0],yi().memoizedState]},useMutableSource:Si,useSyncExternalStore:Ci,useId:qi,unstable_isNewReconciler:!1};function ns(e,t){if(e&&e.defaultProps){for(var n in t=L({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function rs(e,t,n,r){n=null===(n=n(r,t=e.memoizedState))||void 0===n?t:L({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var as={isMounted:function(e){return!!(e=e._reactInternals)&&Ve(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=el(),a=tl(e),o=Bo(r,a);o.payload=t,void 0!==n&&null!==n&&(o.callback=n),null!==(t=Wo(e,o,a))&&(nl(t,e,a,r),Uo(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=el(),a=tl(e),o=Bo(r,a);o.tag=1,o.payload=t,void 0!==n&&null!==n&&(o.callback=n),null!==(t=Wo(e,o,a))&&(nl(t,e,a,r),Uo(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=el(),r=tl(e),a=Bo(n,r);a.tag=2,void 0!==t&&null!==t&&(a.callback=t),null!==(t=Wo(e,a,r))&&(nl(t,e,r,n),Uo(t,e,r))}};function os(e,t,n,r,a,o,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,o,i):!t.prototype||!t.prototype.isPureReactComponent||(!cr(n,r)||!cr(a,o))}function is(e,t,n){var r=!1,a=Na,o=t.contextType;return"object"===typeof o&&null!==o?o=Oo(o):(a=Fa(t)?Aa:Ta.current,o=(r=null!==(r=t.contextTypes)&&void 0!==r)?Oa(e,a):Na),t=new t(n,o),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=as,e.stateNode=t,t._reactInternals=e,r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=o),t}function ss(e,t,n,r){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&as.enqueueReplaceState(t,t.state,null)}function cs(e,t,n,r){var a=e.stateNode;a.props=n,a.state=e.memoizedState,a.refs={},Lo(e);var o=t.contextType;"object"===typeof o&&null!==o?a.context=Oo(o):(o=Fa(t)?Aa:Ta.current,a.context=Oa(e,o)),a.state=e.memoizedState,"function"===typeof(o=t.getDerivedStateFromProps)&&(rs(e,t,o,n),a.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof a.getSnapshotBeforeUpdate||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||(t=a.state,"function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),t!==a.state&&as.enqueueReplaceState(a,a.state,null),jo(e,n,a,r),a.state=e.memoizedState),"function"===typeof a.componentDidMount&&(e.flags|=4194308)}function ls(e,t){try{var n="",r=t;do{n+=U(r),r=r.return}while(r);var a=n}catch(o){a="\nError generating stack: "+o.message+"\n"+o.stack}return{value:e,source:t,stack:a,digest:null}}function us(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function ds(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}var hs="function"===typeof WeakMap?WeakMap:Map;function ps(e,t,n){(n=Bo(-1,n)).tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){Hc||(Hc=!0,Gc=r),ds(0,t)},n}function fs(e,t,n){(n=Bo(-1,n)).tag=3;var r=e.type.getDerivedStateFromError;if("function"===typeof r){var a=t.value;n.payload=function(){return r(a)},n.callback=function(){ds(0,t)}}var o=e.stateNode;return null!==o&&"function"===typeof o.componentDidCatch&&(n.callback=function(){ds(0,t),"function"!==typeof r&&(null===qc?qc=new Set([this]):qc.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function gs(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new hs;var a=new Set;r.set(t,a)}else void 0===(a=r.get(t))&&(a=new Set,r.set(t,a));a.has(n)||(a.add(n),e=Il.bind(null,e,t,n),t.then(e,e))}function ms(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function vs(e,t,n,r,a){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Bo(-1,1)).tag=2,Wo(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=a,e)}var bs=x.ReactCurrentOwner,ys=!1;function xs(e,t,n,r){t.child=null===e?ko(t,null,n,r):wo(t,e.child,n,r)}function ws(e,t,n,r,a){n=n.render;var o=t.ref;return Ao(t,a),r=mi(e,t,n,r,o,a),n=vi(),null===e||ys?(ao&&n&&eo(t),t.flags|=1,xs(e,t,r,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,Hs(e,t,a))}function ks(e,t,n,r,a){if(null===e){var o=n.type;return"function"!==typeof o||Fl(o)||void 0!==o.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Dl(n.type,null,r,t,t.mode,a)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=o,Ss(e,t,o,r,a))}if(o=e.child,0===(e.lanes&a)){var i=o.memoizedProps;if((n=null!==(n=n.compare)?n:cr)(i,r)&&e.ref===t.ref)return Hs(e,t,a)}return t.flags|=1,(e=_l(o,r)).ref=t.ref,e.return=t,t.child=e}function Ss(e,t,n,r,a){if(null!==e){var o=e.memoizedProps;if(cr(o,r)&&e.ref===t.ref){if(ys=!1,t.pendingProps=r=o,0===(e.lanes&a))return t.lanes=e.lanes,Hs(e,t,a);0!==(131072&e.flags)&&(ys=!0)}}return Es(e,t,n,r,a)}function Cs(e,t,n){var r=t.pendingProps,a=r.children,o=null!==e?e.memoizedState:null;if("hidden"===r.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ea(_c,Fc),Fc|=n;else{if(0===(1073741824&n))return e=null!==o?o.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Ea(_c,Fc),Fc|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==o?o.baseLanes:n,Ea(_c,Fc),Fc|=r}else null!==o?(r=o.baseLanes|n,t.memoizedState=null):r=n,Ea(_c,Fc),Fc|=r;return xs(e,t,a,n),t.child}function Is(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function Es(e,t,n,r,a){var o=Fa(n)?Aa:Ta.current;return o=Oa(t,o),Ao(t,a),n=mi(e,t,n,r,o,a),r=vi(),null===e||ys?(ao&&r&&eo(t),t.flags|=1,xs(e,t,n,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,Hs(e,t,a))}function Ns(e,t,n,r,a){if(Fa(n)){var o=!0;Pa(t)}else o=!1;if(Ao(t,a),null===t.stateNode)js(e,t),is(t,n,r),cs(t,n,r,a),r=!0;else if(null===e){var i=t.stateNode,s=t.memoizedProps;i.props=s;var c=i.context,l=n.contextType;"object"===typeof l&&null!==l?l=Oo(l):l=Oa(t,l=Fa(n)?Aa:Ta.current);var u=n.getDerivedStateFromProps,d="function"===typeof u||"function"===typeof i.getSnapshotBeforeUpdate;d||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(s!==r||c!==l)&&ss(t,i,r,l),Po=!1;var h=t.memoizedState;i.state=h,jo(t,r,i,a),c=t.memoizedState,s!==r||h!==c||Ra.current||Po?("function"===typeof u&&(rs(t,n,u,r),c=t.memoizedState),(s=Po||os(t,n,s,r,h,c,l))?(d||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(t.flags|=4194308)):("function"===typeof i.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=c),i.props=r,i.state=c,i.context=l,r=s):("function"===typeof i.componentDidMount&&(t.flags|=4194308),r=!1)}else{i=t.stateNode,zo(e,t),s=t.memoizedProps,l=t.type===t.elementType?s:ns(t.type,s),i.props=l,d=t.pendingProps,h=i.context,"object"===typeof(c=n.contextType)&&null!==c?c=Oo(c):c=Oa(t,c=Fa(n)?Aa:Ta.current);var p=n.getDerivedStateFromProps;(u="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(s!==d||h!==c)&&ss(t,i,r,c),Po=!1,h=t.memoizedState,i.state=h,jo(t,r,i,a);var f=t.memoizedState;s!==d||h!==f||Ra.current||Po?("function"===typeof p&&(rs(t,n,p,r),f=t.memoizedState),(l=Po||os(t,n,l,r,h,f,c)||!1)?(u||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(r,f,c),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(r,f,c)),"function"===typeof i.componentDidUpdate&&(t.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof i.componentDidUpdate||s===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||s===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),i.props=r,i.state=f,i.context=c,r=l):("function"!==typeof i.componentDidUpdate||s===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||s===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),r=!1)}return Ts(e,t,n,r,o,a)}function Ts(e,t,n,r,a,o){Is(e,t);var i=0!==(128&t.flags);if(!r&&!i)return a&&La(t,n,!1),Hs(e,t,o);r=t.stateNode,bs.current=t;var s=i&&"function"!==typeof n.getDerivedStateFromError?null:r.render();return t.flags|=1,null!==e&&i?(t.child=wo(t,e.child,null,o),t.child=wo(t,null,s,o)):xs(e,t,s,o),t.memoizedState=r.state,a&&La(t,n,!0),t.child}function Rs(e){var t=e.stateNode;t.pendingContext?Da(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Da(0,t.context,!1),Yo(e,t.containerInfo)}function As(e,t,n,r,a){return fo(),go(a),t.flags|=256,xs(e,t,n,r),t.child}var Os,Fs,_s,Ds,Ms={dehydrated:null,treeContext:null,retryLane:0};function Ps(e){return{baseLanes:e,cachePool:null,transitions:null}}function Ls(e,t,n){var r,a=t.pendingProps,i=ei.current,s=!1,c=0!==(128&t.flags);if((r=c)||(r=(null===e||null!==e.memoizedState)&&0!==(2&i)),r?(s=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(i|=1),Ea(ei,1&i),null===e)return lo(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(c=a.children,e=a.fallback,s?(a=t.mode,s=t.child,c={mode:"hidden",children:c},0===(1&a)&&null!==s?(s.childLanes=0,s.pendingProps=c):s=Pl(c,a,0,null),e=Ml(e,a,n,null),s.return=t,e.return=t,s.sibling=e,t.child=s,t.child.memoizedState=Ps(n),t.memoizedState=Ms,e):zs(t,c));if(null!==(i=e.memoizedState)&&null!==(r=i.dehydrated))return function(e,t,n,r,a,i,s){if(n)return 256&t.flags?(t.flags&=-257,Bs(e,t,s,r=us(Error(o(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(i=r.fallback,a=t.mode,r=Pl({mode:"visible",children:r.children},a,0,null),(i=Ml(i,a,s,null)).flags|=2,r.return=t,i.return=t,r.sibling=i,t.child=r,0!==(1&t.mode)&&wo(t,e.child,null,s),t.child.memoizedState=Ps(s),t.memoizedState=Ms,i);if(0===(1&t.mode))return Bs(e,t,s,null);if("$!"===a.data){if(r=a.nextSibling&&a.nextSibling.dataset)var c=r.dgst;return r=c,Bs(e,t,s,r=us(i=Error(o(419)),r,void 0))}if(c=0!==(s&e.childLanes),ys||c){if(null!==(r=Rc)){switch(s&-s){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}0!==(a=0!==(a&(r.suspendedLanes|s))?0:a)&&a!==i.retryLane&&(i.retryLane=a,Mo(e,a),nl(r,e,a,-1))}return gl(),Bs(e,t,s,r=us(Error(o(421))))}return"$?"===a.data?(t.flags|=128,t.child=e.child,t=Nl.bind(null,e),a._reactRetry=t,null):(e=i.treeContext,ro=la(a.nextSibling),no=t,ao=!0,oo=null,null!==e&&(Ka[Xa++]=Ya,Ka[Xa++]=Qa,Ka[Xa++]=$a,Ya=e.id,Qa=e.overflow,$a=t),t=zs(t,r.children),t.flags|=4096,t)}(e,t,c,a,r,i,n);if(s){s=a.fallback,c=t.mode,r=(i=e.child).sibling;var l={mode:"hidden",children:a.children};return 0===(1&c)&&t.child!==i?((a=t.child).childLanes=0,a.pendingProps=l,t.deletions=null):(a=_l(i,l)).subtreeFlags=14680064&i.subtreeFlags,null!==r?s=_l(r,s):(s=Ml(s,c,n,null)).flags|=2,s.return=t,a.return=t,a.sibling=s,t.child=a,a=s,s=t.child,c=null===(c=e.child.memoizedState)?Ps(n):{baseLanes:c.baseLanes|n,cachePool:null,transitions:c.transitions},s.memoizedState=c,s.childLanes=e.childLanes&~n,t.memoizedState=Ms,a}return e=(s=e.child).sibling,a=_l(s,{mode:"visible",children:a.children}),0===(1&t.mode)&&(a.lanes=n),a.return=t,a.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=a,t.memoizedState=null,a}function zs(e,t){return(t=Pl({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function Bs(e,t,n,r){return null!==r&&go(r),wo(t,e.child,null,n),(e=zs(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Ws(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),Ro(e.return,t,n)}function Us(e,t,n,r,a){var o=e.memoizedState;null===o?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(o.isBackwards=t,o.rendering=null,o.renderingStartTime=0,o.last=r,o.tail=n,o.tailMode=a)}function Vs(e,t,n){var r=t.pendingProps,a=r.revealOrder,o=r.tail;if(xs(e,t,r.children,n),0!==(2&(r=ei.current)))r=1&r|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Ws(e,n,t);else if(19===e.tag)Ws(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Ea(ei,r),0===(1&t.mode))t.memoizedState=null;else switch(a){case"forwards":for(n=t.child,a=null;null!==n;)null!==(e=n.alternate)&&null===ti(e)&&(a=n),n=n.sibling;null===(n=a)?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),Us(t,!1,a,n,o);break;case"backwards":for(n=null,a=t.child,t.child=null;null!==a;){if(null!==(e=a.alternate)&&null===ti(e)){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}Us(t,!0,n,null,o);break;case"together":Us(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function js(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Hs(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Pc|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(o(153));if(null!==t.child){for(n=_l(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=_l(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Gs(e,t){if(!ao)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function qs(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=14680064&a.subtreeFlags,r|=14680064&a.flags,a.return=e,a=a.sibling;else for(a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function Ks(e,t,n){var r=t.pendingProps;switch(to(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return qs(t),null;case 1:case 17:return Fa(t.type)&&_a(),qs(t),null;case 3:return r=t.stateNode,Qo(),Ia(Ra),Ia(Ta),ri(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==e&&null!==e.child||(ho(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==oo&&(il(oo),oo=null))),Fs(e,t),qs(t),null;case 5:Jo(t);var a=$o(Xo.current);if(n=t.type,null!==e&&null!=t.stateNode)_s(e,t,n,r,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(null===t.stateNode)throw Error(o(166));return qs(t),null}if(e=$o(qo.current),ho(t)){r=t.stateNode,n=t.type;var i=t.memoizedProps;switch(r[ha]=t,r[pa]=i,e=0!==(1&t.mode),n){case"dialog":Br("cancel",r),Br("close",r);break;case"iframe":case"object":case"embed":Br("load",r);break;case"video":case"audio":for(a=0;a<Mr.length;a++)Br(Mr[a],r);break;case"source":Br("error",r);break;case"img":case"image":case"link":Br("error",r),Br("load",r);break;case"details":Br("toggle",r);break;case"input":Y(r,i),Br("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!i.multiple},Br("invalid",r);break;case"textarea":ae(r,i),Br("invalid",r)}for(var c in be(n,i),a=null,i)if(i.hasOwnProperty(c)){var l=i[c];"children"===c?"string"===typeof l?r.textContent!==l&&(!0!==i.suppressHydrationWarning&&Zr(r.textContent,l,e),a=["children",l]):"number"===typeof l&&r.textContent!==""+l&&(!0!==i.suppressHydrationWarning&&Zr(r.textContent,l,e),a=["children",""+l]):s.hasOwnProperty(c)&&null!=l&&"onScroll"===c&&Br("scroll",r)}switch(n){case"input":q(r),J(r,i,!0);break;case"textarea":q(r),ie(r);break;case"select":case"option":break;default:"function"===typeof i.onClick&&(r.onclick=Jr)}r=a,t.updateQueue=r,null!==r&&(t.flags|=4)}else{c=9===a.nodeType?a:a.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=se(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=c.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof r.is?e=c.createElement(n,{is:r.is}):(e=c.createElement(n),"select"===n&&(c=e,r.multiple?c.multiple=!0:r.size&&(c.size=r.size))):e=c.createElementNS(e,n),e[ha]=t,e[pa]=r,Os(e,t,!1,!1),t.stateNode=e;e:{switch(c=ye(n,r),n){case"dialog":Br("cancel",e),Br("close",e),a=r;break;case"iframe":case"object":case"embed":Br("load",e),a=r;break;case"video":case"audio":for(a=0;a<Mr.length;a++)Br(Mr[a],e);a=r;break;case"source":Br("error",e),a=r;break;case"img":case"image":case"link":Br("error",e),Br("load",e),a=r;break;case"details":Br("toggle",e),a=r;break;case"input":Y(e,r),a=$(e,r),Br("invalid",e);break;case"option":default:a=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},a=L({},r,{value:void 0}),Br("invalid",e);break;case"textarea":ae(e,r),a=re(e,r),Br("invalid",e)}for(i in be(n,a),l=a)if(l.hasOwnProperty(i)){var u=l[i];"style"===i?me(e,u):"dangerouslySetInnerHTML"===i?null!=(u=u?u.__html:void 0)&&de(e,u):"children"===i?"string"===typeof u?("textarea"!==n||""!==u)&&he(e,u):"number"===typeof u&&he(e,""+u):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(s.hasOwnProperty(i)?null!=u&&"onScroll"===i&&Br("scroll",e):null!=u&&y(e,i,u,c))}switch(n){case"input":q(e),J(e,r,!1);break;case"textarea":q(e),ie(e);break;case"option":null!=r.value&&e.setAttribute("value",""+H(r.value));break;case"select":e.multiple=!!r.multiple,null!=(i=r.value)?ne(e,!!r.multiple,i,!1):null!=r.defaultValue&&ne(e,!!r.multiple,r.defaultValue,!0);break;default:"function"===typeof a.onClick&&(e.onclick=Jr)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return qs(t),null;case 6:if(e&&null!=t.stateNode)Ds(e,t,e.memoizedProps,r);else{if("string"!==typeof r&&null===t.stateNode)throw Error(o(166));if(n=$o(Xo.current),$o(qo.current),ho(t)){if(r=t.stateNode,n=t.memoizedProps,r[ha]=t,(i=r.nodeValue!==n)&&null!==(e=no))switch(e.tag){case 3:Zr(r.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Zr(r.nodeValue,n,0!==(1&e.mode))}i&&(t.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[ha]=t,t.stateNode=r}return qs(t),null;case 13:if(Ia(ei),r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(ao&&null!==ro&&0!==(1&t.mode)&&0===(128&t.flags))po(),fo(),t.flags|=98560,i=!1;else if(i=ho(t),null!==r&&null!==r.dehydrated){if(null===e){if(!i)throw Error(o(318));if(!(i=null!==(i=t.memoizedState)?i.dehydrated:null))throw Error(o(317));i[ha]=t}else fo(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;qs(t),i=!1}else null!==oo&&(il(oo),oo=null),i=!0;if(!i)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((r=null!==r)!==(null!==e&&null!==e.memoizedState)&&r&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&ei.current)?0===Dc&&(Dc=3):gl())),null!==t.updateQueue&&(t.flags|=4),qs(t),null);case 4:return Qo(),Fs(e,t),null===e&&Vr(t.stateNode.containerInfo),qs(t),null;case 10:return To(t.type._context),qs(t),null;case 19:if(Ia(ei),null===(i=t.memoizedState))return qs(t),null;if(r=0!==(128&t.flags),null===(c=i.rendering))if(r)Gs(i,!1);else{if(0!==Dc||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(c=ti(e))){for(t.flags|=128,Gs(i,!1),null!==(r=c.updateQueue)&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;null!==n;)e=r,(i=n).flags&=14680066,null===(c=i.alternate)?(i.childLanes=0,i.lanes=e,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=c.childLanes,i.lanes=c.lanes,i.child=c.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=c.memoizedProps,i.memoizedState=c.memoizedState,i.updateQueue=c.updateQueue,i.type=c.type,e=c.dependencies,i.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Ea(ei,1&ei.current|2),t.child}e=e.sibling}null!==i.tail&&Qe()>Vc&&(t.flags|=128,r=!0,Gs(i,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=ti(c))){if(t.flags|=128,r=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Gs(i,!0),null===i.tail&&"hidden"===i.tailMode&&!c.alternate&&!ao)return qs(t),null}else 2*Qe()-i.renderingStartTime>Vc&&1073741824!==n&&(t.flags|=128,r=!0,Gs(i,!1),t.lanes=4194304);i.isBackwards?(c.sibling=t.child,t.child=c):(null!==(n=i.last)?n.sibling=c:t.child=c,i.last=c)}return null!==i.tail?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.renderingStartTime=Qe(),t.sibling=null,n=ei.current,Ea(ei,r?1&n|2:1&n),t):(qs(t),null);case 22:case 23:return dl(),r=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==r&&(t.flags|=8192),r&&0!==(1&t.mode)?0!==(1073741824&Fc)&&(qs(t),6&t.subtreeFlags&&(t.flags|=8192)):qs(t),null;case 24:case 25:return null}throw Error(o(156,t.tag))}function Xs(e,t){switch(to(t),t.tag){case 1:return Fa(t.type)&&_a(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Qo(),Ia(Ra),Ia(Ta),ri(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return Jo(t),null;case 13:if(Ia(ei),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(o(340));fo()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Ia(ei),null;case 4:return Qo(),null;case 10:return To(t.type._context),null;case 22:case 23:return dl(),null;default:return null}}Os=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Fs=function(){},_s=function(e,t,n,r){var a=e.memoizedProps;if(a!==r){e=t.stateNode,$o(qo.current);var o,i=null;switch(n){case"input":a=$(e,a),r=$(e,r),i=[];break;case"select":a=L({},a,{value:void 0}),r=L({},r,{value:void 0}),i=[];break;case"textarea":a=re(e,a),r=re(e,r),i=[];break;default:"function"!==typeof a.onClick&&"function"===typeof r.onClick&&(e.onclick=Jr)}for(u in be(n,r),n=null,a)if(!r.hasOwnProperty(u)&&a.hasOwnProperty(u)&&null!=a[u])if("style"===u){var c=a[u];for(o in c)c.hasOwnProperty(o)&&(n||(n={}),n[o]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(s.hasOwnProperty(u)?i||(i=[]):(i=i||[]).push(u,null));for(u in r){var l=r[u];if(c=null!=a?a[u]:void 0,r.hasOwnProperty(u)&&l!==c&&(null!=l||null!=c))if("style"===u)if(c){for(o in c)!c.hasOwnProperty(o)||l&&l.hasOwnProperty(o)||(n||(n={}),n[o]="");for(o in l)l.hasOwnProperty(o)&&c[o]!==l[o]&&(n||(n={}),n[o]=l[o])}else n||(i||(i=[]),i.push(u,n)),n=l;else"dangerouslySetInnerHTML"===u?(l=l?l.__html:void 0,c=c?c.__html:void 0,null!=l&&c!==l&&(i=i||[]).push(u,l)):"children"===u?"string"!==typeof l&&"number"!==typeof l||(i=i||[]).push(u,""+l):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(s.hasOwnProperty(u)?(null!=l&&"onScroll"===u&&Br("scroll",e),i||c===l||(i=[])):(i=i||[]).push(u,l))}n&&(i=i||[]).push("style",n);var u=i;(t.updateQueue=u)&&(t.flags|=4)}},Ds=function(e,t,n,r){n!==r&&(t.flags|=4)};var $s=!1,Ys=!1,Qs="function"===typeof WeakSet?WeakSet:Set,Zs=null;function Js(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(r){Cl(e,t,r)}else n.current=null}function ec(e,t,n){try{n()}catch(r){Cl(e,t,r)}}var tc=!1;function nc(e,t,n){var r=t.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var a=r=r.next;do{if((a.tag&e)===e){var o=a.destroy;a.destroy=void 0,void 0!==o&&ec(t,n,o)}a=a.next}while(a!==r)}}function rc(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function ac(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function oc(e){var t=e.alternate;null!==t&&(e.alternate=null,oc(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[ha],delete t[pa],delete t[ga],delete t[ma],delete t[va])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function ic(e){return 5===e.tag||3===e.tag||4===e.tag}function sc(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||ic(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function cc(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Jr));else if(4!==r&&null!==(e=e.child))for(cc(e,t,n),e=e.sibling;null!==e;)cc(e,t,n),e=e.sibling}function lc(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&null!==(e=e.child))for(lc(e,t,n),e=e.sibling;null!==e;)lc(e,t,n),e=e.sibling}var uc=null,dc=!1;function hc(e,t,n){for(n=n.child;null!==n;)pc(e,t,n),n=n.sibling}function pc(e,t,n){if(ot&&"function"===typeof ot.onCommitFiberUnmount)try{ot.onCommitFiberUnmount(at,n)}catch(s){}switch(n.tag){case 5:Ys||Js(n,t);case 6:var r=uc,a=dc;uc=null,hc(e,t,n),dc=a,null!==(uc=r)&&(dc?(e=uc,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):uc.removeChild(n.stateNode));break;case 18:null!==uc&&(dc?(e=uc,n=n.stateNode,8===e.nodeType?ca(e.parentNode,n):1===e.nodeType&&ca(e,n),Vt(e)):ca(uc,n.stateNode));break;case 4:r=uc,a=dc,uc=n.stateNode.containerInfo,dc=!0,hc(e,t,n),uc=r,dc=a;break;case 0:case 11:case 14:case 15:if(!Ys&&(null!==(r=n.updateQueue)&&null!==(r=r.lastEffect))){a=r=r.next;do{var o=a,i=o.destroy;o=o.tag,void 0!==i&&(0!==(2&o)||0!==(4&o))&&ec(n,t,i),a=a.next}while(a!==r)}hc(e,t,n);break;case 1:if(!Ys&&(Js(n,t),"function"===typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(s){Cl(n,t,s)}hc(e,t,n);break;case 21:hc(e,t,n);break;case 22:1&n.mode?(Ys=(r=Ys)||null!==n.memoizedState,hc(e,t,n),Ys=r):hc(e,t,n);break;default:hc(e,t,n)}}function fc(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Qs),t.forEach((function(t){var r=Tl.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}}function gc(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var a=n[r];try{var i=e,s=t,c=s;e:for(;null!==c;){switch(c.tag){case 5:uc=c.stateNode,dc=!1;break e;case 3:case 4:uc=c.stateNode.containerInfo,dc=!0;break e}c=c.return}if(null===uc)throw Error(o(160));pc(i,s,a),uc=null,dc=!1;var l=a.alternate;null!==l&&(l.return=null),a.return=null}catch(u){Cl(a,t,u)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)mc(t,e),t=t.sibling}function mc(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(gc(t,e),vc(e),4&r){try{nc(3,e,e.return),rc(3,e)}catch(m){Cl(e,e.return,m)}try{nc(5,e,e.return)}catch(m){Cl(e,e.return,m)}}break;case 1:gc(t,e),vc(e),512&r&&null!==n&&Js(n,n.return);break;case 5:if(gc(t,e),vc(e),512&r&&null!==n&&Js(n,n.return),32&e.flags){var a=e.stateNode;try{he(a,"")}catch(m){Cl(e,e.return,m)}}if(4&r&&null!=(a=e.stateNode)){var i=e.memoizedProps,s=null!==n?n.memoizedProps:i,c=e.type,l=e.updateQueue;if(e.updateQueue=null,null!==l)try{"input"===c&&"radio"===i.type&&null!=i.name&&Q(a,i),ye(c,s);var u=ye(c,i);for(s=0;s<l.length;s+=2){var d=l[s],h=l[s+1];"style"===d?me(a,h):"dangerouslySetInnerHTML"===d?de(a,h):"children"===d?he(a,h):y(a,d,h,u)}switch(c){case"input":Z(a,i);break;case"textarea":oe(a,i);break;case"select":var p=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!i.multiple;var f=i.value;null!=f?ne(a,!!i.multiple,f,!1):p!==!!i.multiple&&(null!=i.defaultValue?ne(a,!!i.multiple,i.defaultValue,!0):ne(a,!!i.multiple,i.multiple?[]:"",!1))}a[pa]=i}catch(m){Cl(e,e.return,m)}}break;case 6:if(gc(t,e),vc(e),4&r){if(null===e.stateNode)throw Error(o(162));a=e.stateNode,i=e.memoizedProps;try{a.nodeValue=i}catch(m){Cl(e,e.return,m)}}break;case 3:if(gc(t,e),vc(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Vt(t.containerInfo)}catch(m){Cl(e,e.return,m)}break;case 4:default:gc(t,e),vc(e);break;case 13:gc(t,e),vc(e),8192&(a=e.child).flags&&(i=null!==a.memoizedState,a.stateNode.isHidden=i,!i||null!==a.alternate&&null!==a.alternate.memoizedState||(Uc=Qe())),4&r&&fc(e);break;case 22:if(d=null!==n&&null!==n.memoizedState,1&e.mode?(Ys=(u=Ys)||d,gc(t,e),Ys=u):gc(t,e),vc(e),8192&r){if(u=null!==e.memoizedState,(e.stateNode.isHidden=u)&&!d&&0!==(1&e.mode))for(Zs=e,d=e.child;null!==d;){for(h=Zs=d;null!==Zs;){switch(f=(p=Zs).child,p.tag){case 0:case 11:case 14:case 15:nc(4,p,p.return);break;case 1:Js(p,p.return);var g=p.stateNode;if("function"===typeof g.componentWillUnmount){r=p,n=p.return;try{t=r,g.props=t.memoizedProps,g.state=t.memoizedState,g.componentWillUnmount()}catch(m){Cl(r,n,m)}}break;case 5:Js(p,p.return);break;case 22:if(null!==p.memoizedState){wc(h);continue}}null!==f?(f.return=p,Zs=f):wc(h)}d=d.sibling}e:for(d=null,h=e;;){if(5===h.tag){if(null===d){d=h;try{a=h.stateNode,u?"function"===typeof(i=a.style).setProperty?i.setProperty("display","none","important"):i.display="none":(c=h.stateNode,s=void 0!==(l=h.memoizedProps.style)&&null!==l&&l.hasOwnProperty("display")?l.display:null,c.style.display=ge("display",s))}catch(m){Cl(e,e.return,m)}}}else if(6===h.tag){if(null===d)try{h.stateNode.nodeValue=u?"":h.memoizedProps}catch(m){Cl(e,e.return,m)}}else if((22!==h.tag&&23!==h.tag||null===h.memoizedState||h===e)&&null!==h.child){h.child.return=h,h=h.child;continue}if(h===e)break e;for(;null===h.sibling;){if(null===h.return||h.return===e)break e;d===h&&(d=null),h=h.return}d===h&&(d=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:gc(t,e),vc(e),4&r&&fc(e);case 21:}}function vc(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(ic(n)){var r=n;break e}n=n.return}throw Error(o(160))}switch(r.tag){case 5:var a=r.stateNode;32&r.flags&&(he(a,""),r.flags&=-33),lc(e,sc(e),a);break;case 3:case 4:var i=r.stateNode.containerInfo;cc(e,sc(e),i);break;default:throw Error(o(161))}}catch(s){Cl(e,e.return,s)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function bc(e,t,n){Zs=e,yc(e,t,n)}function yc(e,t,n){for(var r=0!==(1&e.mode);null!==Zs;){var a=Zs,o=a.child;if(22===a.tag&&r){var i=null!==a.memoizedState||$s;if(!i){var s=a.alternate,c=null!==s&&null!==s.memoizedState||Ys;s=$s;var l=Ys;if($s=i,(Ys=c)&&!l)for(Zs=a;null!==Zs;)c=(i=Zs).child,22===i.tag&&null!==i.memoizedState?kc(a):null!==c?(c.return=i,Zs=c):kc(a);for(;null!==o;)Zs=o,yc(o,t,n),o=o.sibling;Zs=a,$s=s,Ys=l}xc(e)}else 0!==(8772&a.subtreeFlags)&&null!==o?(o.return=a,Zs=o):xc(e)}}function xc(e){for(;null!==Zs;){var t=Zs;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Ys||rc(5,t);break;case 1:var r=t.stateNode;if(4&t.flags&&!Ys)if(null===n)r.componentDidMount();else{var a=t.elementType===t.type?n.memoizedProps:ns(t.type,n.memoizedProps);r.componentDidUpdate(a,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var i=t.updateQueue;null!==i&&Ho(t,i,r);break;case 3:var s=t.updateQueue;if(null!==s){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Ho(t,s,n)}break;case 5:var c=t.stateNode;if(null===n&&4&t.flags){n=c;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var u=t.alternate;if(null!==u){var d=u.memoizedState;if(null!==d){var h=d.dehydrated;null!==h&&Vt(h)}}}break;default:throw Error(o(163))}Ys||512&t.flags&&ac(t)}catch(p){Cl(t,t.return,p)}}if(t===e){Zs=null;break}if(null!==(n=t.sibling)){n.return=t.return,Zs=n;break}Zs=t.return}}function wc(e){for(;null!==Zs;){var t=Zs;if(t===e){Zs=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Zs=n;break}Zs=t.return}}function kc(e){for(;null!==Zs;){var t=Zs;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{rc(4,t)}catch(c){Cl(t,n,c)}break;case 1:var r=t.stateNode;if("function"===typeof r.componentDidMount){var a=t.return;try{r.componentDidMount()}catch(c){Cl(t,a,c)}}var o=t.return;try{ac(t)}catch(c){Cl(t,o,c)}break;case 5:var i=t.return;try{ac(t)}catch(c){Cl(t,i,c)}}}catch(c){Cl(t,t.return,c)}if(t===e){Zs=null;break}var s=t.sibling;if(null!==s){s.return=t.return,Zs=s;break}Zs=t.return}}var Sc,Cc=Math.ceil,Ic=x.ReactCurrentDispatcher,Ec=x.ReactCurrentOwner,Nc=x.ReactCurrentBatchConfig,Tc=0,Rc=null,Ac=null,Oc=0,Fc=0,_c=Ca(0),Dc=0,Mc=null,Pc=0,Lc=0,zc=0,Bc=null,Wc=null,Uc=0,Vc=1/0,jc=null,Hc=!1,Gc=null,qc=null,Kc=!1,Xc=null,$c=0,Yc=0,Qc=null,Zc=-1,Jc=0;function el(){return 0!==(6&Tc)?Qe():-1!==Zc?Zc:Zc=Qe()}function tl(e){return 0===(1&e.mode)?1:0!==(2&Tc)&&0!==Oc?Oc&-Oc:null!==mo.transition?(0===Jc&&(Jc=gt()),Jc):0!==(e=yt)?e:e=void 0===(e=window.event)?16:Yt(e.type)}function nl(e,t,n,r){if(50<Yc)throw Yc=0,Qc=null,Error(o(185));vt(e,n,r),0!==(2&Tc)&&e===Rc||(e===Rc&&(0===(2&Tc)&&(Lc|=n),4===Dc&&sl(e,Oc)),rl(e,r),1===n&&0===Tc&&0===(1&t.mode)&&(Vc=Qe()+500,Ba&&Va()))}function rl(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,a=e.expirationTimes,o=e.pendingLanes;0<o;){var i=31-it(o),s=1<<i,c=a[i];-1===c?0!==(s&n)&&0===(s&r)||(a[i]=pt(s,t)):c<=t&&(e.expiredLanes|=s),o&=~s}}(e,t);var r=ht(e,e===Rc?Oc:0);if(0===r)null!==n&&Xe(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(null!=n&&Xe(n),1===t)0===e.tag?function(e){Ba=!0,Ua(e)}(cl.bind(null,e)):Ua(cl.bind(null,e)),ia((function(){0===(6&Tc)&&Va()})),n=null;else{switch(xt(r)){case 1:n=Je;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=rt}n=Rl(n,al.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function al(e,t){if(Zc=-1,Jc=0,0!==(6&Tc))throw Error(o(327));var n=e.callbackNode;if(kl()&&e.callbackNode!==n)return null;var r=ht(e,e===Rc?Oc:0);if(0===r)return null;if(0!==(30&r)||0!==(r&e.expiredLanes)||t)t=ml(e,r);else{t=r;var a=Tc;Tc|=2;var i=fl();for(Rc===e&&Oc===t||(jc=null,Vc=Qe()+500,hl(e,t));;)try{bl();break}catch(c){pl(e,c)}No(),Ic.current=i,Tc=a,null!==Ac?t=0:(Rc=null,Oc=0,t=Dc)}if(0!==t){if(2===t&&(0!==(a=ft(e))&&(r=a,t=ol(e,a))),1===t)throw n=Mc,hl(e,0),sl(e,r),rl(e,Qe()),n;if(6===t)sl(e,r);else{if(a=e.current.alternate,0===(30&r)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var a=n[r],o=a.getSnapshot;a=a.value;try{if(!sr(o(),a))return!1}catch(s){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(a)&&(2===(t=ml(e,r))&&(0!==(i=ft(e))&&(r=i,t=ol(e,i))),1===t))throw n=Mc,hl(e,0),sl(e,r),rl(e,Qe()),n;switch(e.finishedWork=a,e.finishedLanes=r,t){case 0:case 1:throw Error(o(345));case 2:case 5:wl(e,Wc,jc);break;case 3:if(sl(e,r),(130023424&r)===r&&10<(t=Uc+500-Qe())){if(0!==ht(e,0))break;if(((a=e.suspendedLanes)&r)!==r){el(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=ra(wl.bind(null,e,Wc,jc),t);break}wl(e,Wc,jc);break;case 4:if(sl(e,r),(4194240&r)===r)break;for(t=e.eventTimes,a=-1;0<r;){var s=31-it(r);i=1<<s,(s=t[s])>a&&(a=s),r&=~i}if(r=a,10<(r=(120>(r=Qe()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Cc(r/1960))-r)){e.timeoutHandle=ra(wl.bind(null,e,Wc,jc),r);break}wl(e,Wc,jc);break;default:throw Error(o(329))}}}return rl(e,Qe()),e.callbackNode===n?al.bind(null,e):null}function ol(e,t){var n=Bc;return e.current.memoizedState.isDehydrated&&(hl(e,t).flags|=256),2!==(e=ml(e,t))&&(t=Wc,Wc=n,null!==t&&il(t)),e}function il(e){null===Wc?Wc=e:Wc.push.apply(Wc,e)}function sl(e,t){for(t&=~zc,t&=~Lc,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-it(t),r=1<<n;e[n]=-1,t&=~r}}function cl(e){if(0!==(6&Tc))throw Error(o(327));kl();var t=ht(e,0);if(0===(1&t))return rl(e,Qe()),null;var n=ml(e,t);if(0!==e.tag&&2===n){var r=ft(e);0!==r&&(t=r,n=ol(e,r))}if(1===n)throw n=Mc,hl(e,0),sl(e,t),rl(e,Qe()),n;if(6===n)throw Error(o(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wl(e,Wc,jc),rl(e,Qe()),null}function ll(e,t){var n=Tc;Tc|=1;try{return e(t)}finally{0===(Tc=n)&&(Vc=Qe()+500,Ba&&Va())}}function ul(e){null!==Xc&&0===Xc.tag&&0===(6&Tc)&&kl();var t=Tc;Tc|=1;var n=Nc.transition,r=yt;try{if(Nc.transition=null,yt=1,e)return e()}finally{yt=r,Nc.transition=n,0===(6&(Tc=t))&&Va()}}function dl(){Fc=_c.current,Ia(_c)}function hl(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,aa(n)),null!==Ac)for(n=Ac.return;null!==n;){var r=n;switch(to(r),r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&_a();break;case 3:Qo(),Ia(Ra),Ia(Ta),ri();break;case 5:Jo(r);break;case 4:Qo();break;case 13:case 19:Ia(ei);break;case 10:To(r.type._context);break;case 22:case 23:dl()}n=n.return}if(Rc=e,Ac=e=_l(e.current,null),Oc=Fc=t,Dc=0,Mc=null,zc=Lc=Pc=0,Wc=Bc=null,null!==Fo){for(t=0;t<Fo.length;t++)if(null!==(r=(n=Fo[t]).interleaved)){n.interleaved=null;var a=r.next,o=n.pending;if(null!==o){var i=o.next;o.next=a,r.next=i}n.pending=r}Fo=null}return e}function pl(e,t){for(;;){var n=Ac;try{if(No(),ai.current=Zi,ui){for(var r=si.memoizedState;null!==r;){var a=r.queue;null!==a&&(a.pending=null),r=r.next}ui=!1}if(ii=0,li=ci=si=null,di=!1,hi=0,Ec.current=null,null===n||null===n.return){Dc=1,Mc=t,Ac=null;break}e:{var i=e,s=n.return,c=n,l=t;if(t=Oc,c.flags|=32768,null!==l&&"object"===typeof l&&"function"===typeof l.then){var u=l,d=c,h=d.tag;if(0===(1&d.mode)&&(0===h||11===h||15===h)){var p=d.alternate;p?(d.updateQueue=p.updateQueue,d.memoizedState=p.memoizedState,d.lanes=p.lanes):(d.updateQueue=null,d.memoizedState=null)}var f=ms(s);if(null!==f){f.flags&=-257,vs(f,s,c,0,t),1&f.mode&&gs(i,u,t),l=u;var g=(t=f).updateQueue;if(null===g){var m=new Set;m.add(l),t.updateQueue=m}else g.add(l);break e}if(0===(1&t)){gs(i,u,t),gl();break e}l=Error(o(426))}else if(ao&&1&c.mode){var v=ms(s);if(null!==v){0===(65536&v.flags)&&(v.flags|=256),vs(v,s,c,0,t),go(ls(l,c));break e}}i=l=ls(l,c),4!==Dc&&(Dc=2),null===Bc?Bc=[i]:Bc.push(i),i=s;do{switch(i.tag){case 3:i.flags|=65536,t&=-t,i.lanes|=t,Vo(i,ps(0,l,t));break e;case 1:c=l;var b=i.type,y=i.stateNode;if(0===(128&i.flags)&&("function"===typeof b.getDerivedStateFromError||null!==y&&"function"===typeof y.componentDidCatch&&(null===qc||!qc.has(y)))){i.flags|=65536,t&=-t,i.lanes|=t,Vo(i,fs(i,c,t));break e}}i=i.return}while(null!==i)}xl(n)}catch(x){t=x,Ac===n&&null!==n&&(Ac=n=n.return);continue}break}}function fl(){var e=Ic.current;return Ic.current=Zi,null===e?Zi:e}function gl(){0!==Dc&&3!==Dc&&2!==Dc||(Dc=4),null===Rc||0===(268435455&Pc)&&0===(268435455&Lc)||sl(Rc,Oc)}function ml(e,t){var n=Tc;Tc|=2;var r=fl();for(Rc===e&&Oc===t||(jc=null,hl(e,t));;)try{vl();break}catch(a){pl(e,a)}if(No(),Tc=n,Ic.current=r,null!==Ac)throw Error(o(261));return Rc=null,Oc=0,Dc}function vl(){for(;null!==Ac;)yl(Ac)}function bl(){for(;null!==Ac&&!$e();)yl(Ac)}function yl(e){var t=Sc(e.alternate,e,Fc);e.memoizedProps=e.pendingProps,null===t?xl(e):Ac=t,Ec.current=null}function xl(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=Ks(n,t,Fc)))return void(Ac=n)}else{if(null!==(n=Xs(n,t)))return n.flags&=32767,void(Ac=n);if(null===e)return Dc=6,void(Ac=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(Ac=t);Ac=t=e}while(null!==t);0===Dc&&(Dc=5)}function wl(e,t,n){var r=yt,a=Nc.transition;try{Nc.transition=null,yt=1,function(e,t,n,r){do{kl()}while(null!==Xc);if(0!==(6&Tc))throw Error(o(327));n=e.finishedWork;var a=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(o(177));e.callbackNode=null,e.callbackPriority=0;var i=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var a=31-it(n),o=1<<a;t[a]=0,r[a]=-1,e[a]=-1,n&=~o}}(e,i),e===Rc&&(Ac=Rc=null,Oc=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||Kc||(Kc=!0,Rl(tt,(function(){return kl(),null}))),i=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||i){i=Nc.transition,Nc.transition=null;var s=yt;yt=1;var c=Tc;Tc|=4,Ec.current=null,function(e,t){if(ea=Ht,pr(e=hr())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var a=r.anchorOffset,i=r.focusNode;r=r.focusOffset;try{n.nodeType,i.nodeType}catch(w){n=null;break e}var s=0,c=-1,l=-1,u=0,d=0,h=e,p=null;t:for(;;){for(var f;h!==n||0!==a&&3!==h.nodeType||(c=s+a),h!==i||0!==r&&3!==h.nodeType||(l=s+r),3===h.nodeType&&(s+=h.nodeValue.length),null!==(f=h.firstChild);)p=h,h=f;for(;;){if(h===e)break t;if(p===n&&++u===a&&(c=s),p===i&&++d===r&&(l=s),null!==(f=h.nextSibling))break;p=(h=p).parentNode}h=f}n=-1===c||-1===l?null:{start:c,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(ta={focusedElem:e,selectionRange:n},Ht=!1,Zs=t;null!==Zs;)if(e=(t=Zs).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Zs=e;else for(;null!==Zs;){t=Zs;try{var g=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==g){var m=g.memoizedProps,v=g.memoizedState,b=t.stateNode,y=b.getSnapshotBeforeUpdate(t.elementType===t.type?m:ns(t.type,m),v);b.__reactInternalSnapshotBeforeUpdate=y}break;case 3:var x=t.stateNode.containerInfo;1===x.nodeType?x.textContent="":9===x.nodeType&&x.documentElement&&x.removeChild(x.documentElement);break;default:throw Error(o(163))}}catch(w){Cl(t,t.return,w)}if(null!==(e=t.sibling)){e.return=t.return,Zs=e;break}Zs=t.return}g=tc,tc=!1}(e,n),mc(n,e),fr(ta),Ht=!!ea,ta=ea=null,e.current=n,bc(n,e,a),Ye(),Tc=c,yt=s,Nc.transition=i}else e.current=n;if(Kc&&(Kc=!1,Xc=e,$c=a),i=e.pendingLanes,0===i&&(qc=null),function(e){if(ot&&"function"===typeof ot.onCommitFiberRoot)try{ot.onCommitFiberRoot(at,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),rl(e,Qe()),null!==t)for(r=e.onRecoverableError,n=0;n<t.length;n++)a=t[n],r(a.value,{componentStack:a.stack,digest:a.digest});if(Hc)throw Hc=!1,e=Gc,Gc=null,e;0!==(1&$c)&&0!==e.tag&&kl(),i=e.pendingLanes,0!==(1&i)?e===Qc?Yc++:(Yc=0,Qc=e):Yc=0,Va()}(e,t,n,r)}finally{Nc.transition=a,yt=r}return null}function kl(){if(null!==Xc){var e=xt($c),t=Nc.transition,n=yt;try{if(Nc.transition=null,yt=16>e?16:e,null===Xc)var r=!1;else{if(e=Xc,Xc=null,$c=0,0!==(6&Tc))throw Error(o(331));var a=Tc;for(Tc|=4,Zs=e.current;null!==Zs;){var i=Zs,s=i.child;if(0!==(16&Zs.flags)){var c=i.deletions;if(null!==c){for(var l=0;l<c.length;l++){var u=c[l];for(Zs=u;null!==Zs;){var d=Zs;switch(d.tag){case 0:case 11:case 15:nc(8,d,i)}var h=d.child;if(null!==h)h.return=d,Zs=h;else for(;null!==Zs;){var p=(d=Zs).sibling,f=d.return;if(oc(d),d===u){Zs=null;break}if(null!==p){p.return=f,Zs=p;break}Zs=f}}}var g=i.alternate;if(null!==g){var m=g.child;if(null!==m){g.child=null;do{var v=m.sibling;m.sibling=null,m=v}while(null!==m)}}Zs=i}}if(0!==(2064&i.subtreeFlags)&&null!==s)s.return=i,Zs=s;else e:for(;null!==Zs;){if(0!==(2048&(i=Zs).flags))switch(i.tag){case 0:case 11:case 15:nc(9,i,i.return)}var b=i.sibling;if(null!==b){b.return=i.return,Zs=b;break e}Zs=i.return}}var y=e.current;for(Zs=y;null!==Zs;){var x=(s=Zs).child;if(0!==(2064&s.subtreeFlags)&&null!==x)x.return=s,Zs=x;else e:for(s=y;null!==Zs;){if(0!==(2048&(c=Zs).flags))try{switch(c.tag){case 0:case 11:case 15:rc(9,c)}}catch(k){Cl(c,c.return,k)}if(c===s){Zs=null;break e}var w=c.sibling;if(null!==w){w.return=c.return,Zs=w;break e}Zs=c.return}}if(Tc=a,Va(),ot&&"function"===typeof ot.onPostCommitFiberRoot)try{ot.onPostCommitFiberRoot(at,e)}catch(k){}r=!0}return r}finally{yt=n,Nc.transition=t}}return!1}function Sl(e,t,n){e=Wo(e,t=ps(0,t=ls(n,t),1),1),t=el(),null!==e&&(vt(e,1,t),rl(e,t))}function Cl(e,t,n){if(3===e.tag)Sl(e,e,n);else for(;null!==t;){if(3===t.tag){Sl(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===qc||!qc.has(r))){t=Wo(t,e=fs(t,e=ls(n,e),1),1),e=el(),null!==t&&(vt(t,1,e),rl(t,e));break}}t=t.return}}function Il(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),t=el(),e.pingedLanes|=e.suspendedLanes&n,Rc===e&&(Oc&n)===n&&(4===Dc||3===Dc&&(130023424&Oc)===Oc&&500>Qe()-Uc?hl(e,0):zc|=n),rl(e,t)}function El(e,t){0===t&&(0===(1&e.mode)?t=1:(t=ut,0===(130023424&(ut<<=1))&&(ut=4194304)));var n=el();null!==(e=Mo(e,t))&&(vt(e,t,n),rl(e,n))}function Nl(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),El(e,n)}function Tl(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,a=e.memoizedState;null!==a&&(n=a.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(o(314))}null!==r&&r.delete(t),El(e,n)}function Rl(e,t){return Ke(e,t)}function Al(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ol(e,t,n,r){return new Al(e,t,n,r)}function Fl(e){return!(!(e=e.prototype)||!e.isReactComponent)}function _l(e,t){var n=e.alternate;return null===n?((n=Ol(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Dl(e,t,n,r,a,i){var s=2;if(r=e,"function"===typeof e)Fl(e)&&(s=1);else if("string"===typeof e)s=5;else e:switch(e){case S:return Ml(n.children,a,i,t);case C:s=8,a|=8;break;case I:return(e=Ol(12,n,t,2|a)).elementType=I,e.lanes=i,e;case R:return(e=Ol(13,n,t,a)).elementType=R,e.lanes=i,e;case A:return(e=Ol(19,n,t,a)).elementType=A,e.lanes=i,e;case _:return Pl(n,a,i,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case E:s=10;break e;case N:s=9;break e;case T:s=11;break e;case O:s=14;break e;case F:s=16,r=null;break e}throw Error(o(130,null==e?e:typeof e,""))}return(t=Ol(s,n,t,a)).elementType=e,t.type=r,t.lanes=i,t}function Ml(e,t,n,r){return(e=Ol(7,e,r,t)).lanes=n,e}function Pl(e,t,n,r){return(e=Ol(22,e,r,t)).elementType=_,e.lanes=n,e.stateNode={isHidden:!1},e}function Ll(e,t,n){return(e=Ol(6,e,null,t)).lanes=n,e}function zl(e,t,n){return(t=Ol(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Bl(e,t,n,r,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=mt(0),this.expirationTimes=mt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=mt(0),this.identifierPrefix=r,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Wl(e,t,n,r,a,o,i,s,c){return e=new Bl(e,t,n,s,c),1===t?(t=1,!0===o&&(t|=8)):t=0,o=Ol(3,null,null,t),e.current=o,o.stateNode=e,o.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Lo(o),e}function Ul(e){if(!e)return Na;e:{if(Ve(e=e._reactInternals)!==e||1!==e.tag)throw Error(o(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Fa(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(o(171))}if(1===e.tag){var n=e.type;if(Fa(n))return Ma(e,n,t)}return t}function Vl(e,t,n,r,a,o,i,s,c){return(e=Wl(n,r,!0,e,0,o,0,s,c)).context=Ul(null),n=e.current,(o=Bo(r=el(),a=tl(n))).callback=void 0!==t&&null!==t?t:null,Wo(n,o,a),e.current.lanes=a,vt(e,a,r),rl(e,r),e}function jl(e,t,n,r){var a=t.current,o=el(),i=tl(a);return n=Ul(n),null===t.context?t.context=n:t.pendingContext=n,(t=Bo(o,i)).payload={element:e},null!==(r=void 0===r?null:r)&&(t.callback=r),null!==(e=Wo(a,t,i))&&(nl(e,a,i,o),Uo(e,a,i)),i}function Hl(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Gl(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function ql(e,t){Gl(e,t),(e=e.alternate)&&Gl(e,t)}Sc=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Ra.current)ys=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return ys=!1,function(e,t,n){switch(t.tag){case 3:Rs(t),fo();break;case 5:Zo(t);break;case 1:Fa(t.type)&&Pa(t);break;case 4:Yo(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,a=t.memoizedProps.value;Ea(So,r._currentValue),r._currentValue=a;break;case 13:if(null!==(r=t.memoizedState))return null!==r.dehydrated?(Ea(ei,1&ei.current),t.flags|=128,null):0!==(n&t.child.childLanes)?Ls(e,t,n):(Ea(ei,1&ei.current),null!==(e=Hs(e,t,n))?e.sibling:null);Ea(ei,1&ei.current);break;case 19:if(r=0!==(n&t.childLanes),0!==(128&e.flags)){if(r)return Vs(e,t,n);t.flags|=128}if(null!==(a=t.memoizedState)&&(a.rendering=null,a.tail=null,a.lastEffect=null),Ea(ei,ei.current),r)break;return null;case 22:case 23:return t.lanes=0,Cs(e,t,n)}return Hs(e,t,n)}(e,t,n);ys=0!==(131072&e.flags)}else ys=!1,ao&&0!==(1048576&t.flags)&&Ja(t,qa,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;js(e,t),e=t.pendingProps;var a=Oa(t,Ta.current);Ao(t,n),a=mi(null,t,r,e,a,n);var i=vi();return t.flags|=1,"object"===typeof a&&null!==a&&"function"===typeof a.render&&void 0===a.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Fa(r)?(i=!0,Pa(t)):i=!1,t.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,Lo(t),a.updater=as,t.stateNode=a,a._reactInternals=t,cs(t,r,e,n),t=Ts(null,t,r,!0,i,n)):(t.tag=0,ao&&i&&eo(t),xs(null,t,a,n),t=t.child),t;case 16:r=t.elementType;e:{switch(js(e,t),e=t.pendingProps,r=(a=r._init)(r._payload),t.type=r,a=t.tag=function(e){if("function"===typeof e)return Fl(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===T)return 11;if(e===O)return 14}return 2}(r),e=ns(r,e),a){case 0:t=Es(null,t,r,e,n);break e;case 1:t=Ns(null,t,r,e,n);break e;case 11:t=ws(null,t,r,e,n);break e;case 14:t=ks(null,t,r,ns(r.type,e),n);break e}throw Error(o(306,r,""))}return t;case 0:return r=t.type,a=t.pendingProps,Es(e,t,r,a=t.elementType===r?a:ns(r,a),n);case 1:return r=t.type,a=t.pendingProps,Ns(e,t,r,a=t.elementType===r?a:ns(r,a),n);case 3:e:{if(Rs(t),null===e)throw Error(o(387));r=t.pendingProps,a=(i=t.memoizedState).element,zo(e,t),jo(t,r,null,n);var s=t.memoizedState;if(r=s.element,i.isDehydrated){if(i={element:r,isDehydrated:!1,cache:s.cache,pendingSuspenseBoundaries:s.pendingSuspenseBoundaries,transitions:s.transitions},t.updateQueue.baseState=i,t.memoizedState=i,256&t.flags){t=As(e,t,r,n,a=ls(Error(o(423)),t));break e}if(r!==a){t=As(e,t,r,n,a=ls(Error(o(424)),t));break e}for(ro=la(t.stateNode.containerInfo.firstChild),no=t,ao=!0,oo=null,n=ko(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(fo(),r===a){t=Hs(e,t,n);break e}xs(e,t,r,n)}t=t.child}return t;case 5:return Zo(t),null===e&&lo(t),r=t.type,a=t.pendingProps,i=null!==e?e.memoizedProps:null,s=a.children,na(r,a)?s=null:null!==i&&na(r,i)&&(t.flags|=32),Is(e,t),xs(e,t,s,n),t.child;case 6:return null===e&&lo(t),null;case 13:return Ls(e,t,n);case 4:return Yo(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=wo(t,null,r,n):xs(e,t,r,n),t.child;case 11:return r=t.type,a=t.pendingProps,ws(e,t,r,a=t.elementType===r?a:ns(r,a),n);case 7:return xs(e,t,t.pendingProps,n),t.child;case 8:case 12:return xs(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,a=t.pendingProps,i=t.memoizedProps,s=a.value,Ea(So,r._currentValue),r._currentValue=s,null!==i)if(sr(i.value,s)){if(i.children===a.children&&!Ra.current){t=Hs(e,t,n);break e}}else for(null!==(i=t.child)&&(i.return=t);null!==i;){var c=i.dependencies;if(null!==c){s=i.child;for(var l=c.firstContext;null!==l;){if(l.context===r){if(1===i.tag){(l=Bo(-1,n&-n)).tag=2;var u=i.updateQueue;if(null!==u){var d=(u=u.shared).pending;null===d?l.next=l:(l.next=d.next,d.next=l),u.pending=l}}i.lanes|=n,null!==(l=i.alternate)&&(l.lanes|=n),Ro(i.return,n,t),c.lanes|=n;break}l=l.next}}else if(10===i.tag)s=i.type===t.type?null:i.child;else if(18===i.tag){if(null===(s=i.return))throw Error(o(341));s.lanes|=n,null!==(c=s.alternate)&&(c.lanes|=n),Ro(s,n,t),s=i.sibling}else s=i.child;if(null!==s)s.return=i;else for(s=i;null!==s;){if(s===t){s=null;break}if(null!==(i=s.sibling)){i.return=s.return,s=i;break}s=s.return}i=s}xs(e,t,a.children,n),t=t.child}return t;case 9:return a=t.type,r=t.pendingProps.children,Ao(t,n),r=r(a=Oo(a)),t.flags|=1,xs(e,t,r,n),t.child;case 14:return a=ns(r=t.type,t.pendingProps),ks(e,t,r,a=ns(r.type,a),n);case 15:return Ss(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:ns(r,a),js(e,t),t.tag=1,Fa(r)?(e=!0,Pa(t)):e=!1,Ao(t,n),is(t,r,a),cs(t,r,a,n),Ts(null,t,r,!0,e,n);case 19:return Vs(e,t,n);case 22:return Cs(e,t,n)}throw Error(o(156,t.tag))};var Kl="function"===typeof reportError?reportError:function(e){console.error(e)};function Xl(e){this._internalRoot=e}function $l(e){this._internalRoot=e}function Yl(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Ql(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Zl(){}function Jl(e,t,n,r,a){var o=n._reactRootContainer;if(o){var i=o;if("function"===typeof a){var s=a;a=function(){var e=Hl(i);s.call(e)}}jl(t,i,e,a)}else i=function(e,t,n,r,a){if(a){if("function"===typeof r){var o=r;r=function(){var e=Hl(i);o.call(e)}}var i=Vl(t,r,e,0,null,!1,0,"",Zl);return e._reactRootContainer=i,e[fa]=i.current,Vr(8===e.nodeType?e.parentNode:e),ul(),i}for(;a=e.lastChild;)e.removeChild(a);if("function"===typeof r){var s=r;r=function(){var e=Hl(c);s.call(e)}}var c=Wl(e,0,!1,null,0,!1,0,"",Zl);return e._reactRootContainer=c,e[fa]=c.current,Vr(8===e.nodeType?e.parentNode:e),ul((function(){jl(t,c,n,r)})),c}(n,t,e,a,r);return Hl(i)}$l.prototype.render=Xl.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(o(409));jl(e,t,null,null)},$l.prototype.unmount=Xl.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;ul((function(){jl(null,e,null,null)})),t[fa]=null}},$l.prototype.unstable_scheduleHydration=function(e){if(e){var t=Ct();e={blockedOn:null,target:e,priority:t};for(var n=0;n<_t.length&&0!==t&&t<_t[n].priority;n++);_t.splice(n,0,e),0===n&&Lt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=dt(t.pendingLanes);0!==n&&(bt(t,1|n),rl(t,Qe()),0===(6&Tc)&&(Vc=Qe()+500,Va()))}break;case 13:ul((function(){var t=Mo(e,1);if(null!==t){var n=el();nl(t,e,1,n)}})),ql(e,1)}},kt=function(e){if(13===e.tag){var t=Mo(e,134217728);if(null!==t)nl(t,e,134217728,el());ql(e,134217728)}},St=function(e){if(13===e.tag){var t=tl(e),n=Mo(e,t);if(null!==n)nl(n,e,t,el());ql(e,t)}},Ct=function(){return yt},It=function(e,t){var n=yt;try{return yt=e,t()}finally{yt=n}},ke=function(e,t,n){switch(t){case"input":if(Z(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var a=wa(r);if(!a)throw Error(o(90));K(r),Z(r,a)}}}break;case"textarea":oe(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Te=ll,Re=ul;var eu={usingClientEntryPoint:!1,Events:[ya,xa,wa,Ee,Ne,ll]},tu={findFiberByHostInstance:ba,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},nu={bundleType:tu.bundleType,version:tu.version,rendererPackageName:tu.rendererPackageName,rendererConfig:tu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:x.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Ge(e))?null:e.stateNode},findFiberByHostInstance:tu.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var ru=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!ru.isDisabled&&ru.supportsFiber)try{at=ru.inject(nu),ot=ru}catch(ue){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=eu,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Yl(t))throw Error(o(200));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Yl(e))throw Error(o(299));var n=!1,r="",a=Kl;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onRecoverableError&&(a=t.onRecoverableError)),t=Wl(e,1,!1,null,0,n,0,r,a),e[fa]=t.current,Vr(8===e.nodeType?e.parentNode:e),new Xl(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(o(188));throw e=Object.keys(e).join(","),Error(o(268,e))}return e=null===(e=Ge(t))?null:e.stateNode},t.flushSync=function(e){return ul(e)},t.hydrate=function(e,t,n){if(!Ql(t))throw Error(o(200));return Jl(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Yl(e))throw Error(o(405));var r=null!=n&&n.hydratedSources||null,a=!1,i="",s=Kl;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(a=!0),void 0!==n.identifierPrefix&&(i=n.identifierPrefix),void 0!==n.onRecoverableError&&(s=n.onRecoverableError)),t=Vl(t,null,e,1,null!=n?n:null,a,0,i,s),e[fa]=t.current,Vr(e),r)for(e=0;e<r.length;e++)a=(a=(n=r[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,a]:t.mutableSourceEagerHydrationData.push(n,a);return new $l(t)},t.render=function(e,t,n){if(!Ql(t))throw Error(o(200));return Jl(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Ql(e))throw Error(o(40));return!!e._reactRootContainer&&(ul((function(){Jl(null,null,e,!1,(function(){e._reactRootContainer=null,e[fa]=null}))})),!0)},t.unstable_batchedUpdates=ll,t.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Ql(n))throw Error(o(200));if(null==e||void 0===e._reactInternals)throw Error(o(38));return Jl(e,t,n,!1,r)},t.version="18.3.1-next-f1338f8080-20240426"},391:(e,t,n)=>{"use strict";var r=n(950);t.createRoot=r.createRoot,t.hydrateRoot=r.hydrateRoot},950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(730)},29:function(e,t,n){var r;r=function(e){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(r,a,function(t){return e[t]}.bind(null,a));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(e,t,n){"use strict";n.r(t);var r=n("react"),a=function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function r(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),o=function(){return o=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var a in t=arguments[n])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e},o.apply(this,arguments)},i=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};function s(){return!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)}"undefined"!==typeof window&&(void 0===navigator.mediaDevices&&(navigator.mediaDevices={}),void 0===navigator.mediaDevices.getUserMedia&&(navigator.mediaDevices.getUserMedia=function(e){var t=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return t?new Promise((function(n,r){t.call(navigator,e,n,r)})):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}));var c=function(e){function t(t){var n=e.call(this,t)||this;return n.canvas=null,n.ctx=null,n.requestUserMediaId=0,n.unmounted=!1,n.state={hasUserMedia:!1},n}return a(t,e),t.prototype.componentDidMount=function(){var e=this.state,t=this.props;this.unmounted=!1,s()?(e.hasUserMedia||this.requestUserMedia(),t.children&&"function"!=typeof t.children&&console.warn("children must be a function")):t.onUserMediaError("getUserMedia not supported")},t.prototype.componentDidUpdate=function(e){var t=this.props;if(s()){var n=JSON.stringify(e.audioConstraints)!==JSON.stringify(t.audioConstraints),r=JSON.stringify(e.videoConstraints)!==JSON.stringify(t.videoConstraints),a=e.minScreenshotWidth!==t.minScreenshotWidth,o=e.minScreenshotHeight!==t.minScreenshotHeight;(r||a||o)&&(this.canvas=null,this.ctx=null),(n||r)&&(this.stopAndCleanup(),this.requestUserMedia())}else t.onUserMediaError("getUserMedia not supported")},t.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},t.stopMediaStream=function(e){e&&(e.getVideoTracks&&e.getAudioTracks?(e.getVideoTracks().map((function(t){e.removeTrack(t),t.stop()})),e.getAudioTracks().map((function(t){e.removeTrack(t),t.stop()}))):e.stop())},t.prototype.stopAndCleanup=function(){var e=this.state;e.hasUserMedia&&(t.stopMediaStream(this.stream),e.src&&window.URL.revokeObjectURL(e.src))},t.prototype.getScreenshot=function(e){var t=this.state,n=this.props;if(!t.hasUserMedia)return null;var r=this.getCanvas(e);return r&&r.toDataURL(n.screenshotFormat,n.screenshotQuality)},t.prototype.getCanvas=function(e){var t=this.state,n=this.props;if(!this.video)return null;if(!t.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var r=this.video.videoWidth,a=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var o=r/a;a=(r=n.minScreenshotWidth||this.video.clientWidth)/o,n.minScreenshotHeight&&a<n.minScreenshotHeight&&(r=(a=n.minScreenshotHeight)*o)}this.canvas=document.createElement("canvas"),this.canvas.width=(null===e||void 0===e?void 0:e.width)||r,this.canvas.height=(null===e||void 0===e?void 0:e.height)||a,this.ctx=this.canvas.getContext("2d")}var i=this.ctx,s=this.canvas;return i&&s&&(s.width=(null===e||void 0===e?void 0:e.width)||s.width,s.height=(null===e||void 0===e?void 0:e.height)||s.height,n.mirrored&&(i.translate(s.width,0),i.scale(-1,1)),i.imageSmoothingEnabled=n.imageSmoothing,i.drawImage(this.video,0,0,(null===e||void 0===e?void 0:e.width)||s.width,(null===e||void 0===e?void 0:e.height)||s.height),n.mirrored&&(i.scale(-1,1),i.translate(-s.width,0))),s},t.prototype.requestUserMedia=function(){var e=this,n=this.props,r=function(r,a){var o={video:"undefined"===typeof a||a};n.audio&&(o.audio="undefined"===typeof r||r),e.requestUserMediaId++;var i=e.requestUserMediaId;navigator.mediaDevices.getUserMedia(o).then((function(n){e.unmounted||i!==e.requestUserMediaId?t.stopMediaStream(n):e.handleUserMedia(null,n)})).catch((function(t){e.handleUserMedia(t)}))};if("mediaDevices"in navigator)r(n.audioConstraints,n.videoConstraints);else{var a=function(e){return{optional:[{sourceId:e}]}},o=function(e){var t=e.deviceId;return"string"===typeof t?t:Array.isArray(t)&&t.length>0?t[0]:"object"===typeof t&&t.ideal?t.ideal:null};MediaStreamTrack.getSources((function(e){var t=null,i=null;e.forEach((function(e){"audio"===e.kind?t=e.id:"video"===e.kind&&(i=e.id)}));var s=o(n.audioConstraints);s&&(t=s);var c=o(n.videoConstraints);c&&(i=c),r(a(t),a(i))}))}},t.prototype.handleUserMedia=function(e,t){var n=this.props;if(e||!t)return this.setState({hasUserMedia:!1}),void n.onUserMediaError(e);this.stream=t;try{this.video&&(this.video.srcObject=t),this.setState({hasUserMedia:!0})}catch(r){this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(t)})}n.onUserMedia(t)},t.prototype.render=function(){var e=this,t=this.state,n=this.props,a=n.audio,s=(n.forceScreenshotSourceSize,n.disablePictureInPicture),c=(n.onUserMedia,n.onUserMediaError,n.screenshotFormat,n.screenshotQuality,n.minScreenshotWidth,n.minScreenshotHeight,n.audioConstraints,n.videoConstraints,n.imageSmoothing,n.mirrored),l=n.style,u=void 0===l?{}:l,d=n.children,h=i(n,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),p=c?o(o({},u),{transform:(u.transform||"")+" scaleX(-1)"}):u,f={getScreenshot:this.getScreenshot.bind(this)};return r.createElement(r.Fragment,null,r.createElement("video",o({autoPlay:!0,disablePictureInPicture:s,src:t.src,muted:!a,playsInline:!0,ref:function(t){e.video=t},style:p},h)),d&&d(f))},t.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},t}(r.Component);t.default=c},react:function(t,n){t.exports=e}}).default},e.exports=r(n(43))},153:(e,t,n)=>{"use strict";var r=n(43),a=Symbol.for("react.element"),o=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,s=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,t,n){var r,o={},l=null,u=null;for(r in void 0!==n&&(l=""+n),void 0!==t.key&&(l=""+t.key),void 0!==t.ref&&(u=t.ref),t)i.call(t,r)&&!c.hasOwnProperty(r)&&(o[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps)void 0===o[r]&&(o[r]=t[r]);return{$$typeof:a,type:e,key:l,ref:u,props:o,_owner:s.current}}t.jsx=l,t.jsxs=l},202:(e,t)=>{"use strict";var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),o=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),s=Symbol.for("react.provider"),c=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,m={};function v(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}function b(){}function y(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}v.prototype.isReactComponent={},v.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},v.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=v.prototype;var x=y.prototype=new b;x.constructor=y,g(x,v.prototype),x.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},C={key:!0,ref:!0,__self:!0,__source:!0};function I(e,t,r){var a,o={},i=null,s=null;if(null!=t)for(a in void 0!==t.ref&&(s=t.ref),void 0!==t.key&&(i=""+t.key),t)k.call(t,a)&&!C.hasOwnProperty(a)&&(o[a]=t[a]);var c=arguments.length-2;if(1===c)o.children=r;else if(1<c){for(var l=Array(c),u=0;u<c;u++)l[u]=arguments[u+2];o.children=l}if(e&&e.defaultProps)for(a in c=e.defaultProps)void 0===o[a]&&(o[a]=c[a]);return{$$typeof:n,type:e,key:i,ref:s,props:o,_owner:S.current}}function E(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var N=/\/+/g;function T(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function R(e,t,a,o,i){var s=typeof e;"undefined"!==s&&"boolean"!==s||(e=null);var c=!1;if(null===e)c=!0;else switch(s){case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case n:case r:c=!0}}if(c)return i=i(c=e),e=""===o?"."+T(c,0):o,w(i)?(a="",null!=e&&(a=e.replace(N,"$&/")+"/"),R(i,t,a,"",(function(e){return e}))):null!=i&&(E(i)&&(i=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,a+(!i.key||c&&c.key===i.key?"":(""+i.key).replace(N,"$&/")+"/")+e)),t.push(i)),1;if(c=0,o=""===o?".":o+":",w(e))for(var l=0;l<e.length;l++){var u=o+T(s=e[l],l);c+=R(s,t,a,u,i)}else if(u=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"===typeof u)for(e=u.call(e),l=0;!(s=e.next()).done;)c+=R(s=s.value,t,a,u=o+T(s,l++),i);else if("object"===s)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return c}function A(e,t,n){if(null==e)return e;var r=[],a=0;return R(e,r,"","",(function(e){return t.call(n,e,a++)})),r}function O(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var F={current:null},_={transition:null},D={ReactCurrentDispatcher:F,ReactCurrentBatchConfig:_,ReactCurrentOwner:S};function M(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:A,forEach:function(e,t,n){A(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return A(e,(function(){t++})),t},toArray:function(e){return A(e,(function(e){return e}))||[]},only:function(e){if(!E(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=v,t.Fragment=a,t.Profiler=i,t.PureComponent=y,t.StrictMode=o,t.Suspense=u,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=D,t.act=M,t.cloneElement=function(e,t,r){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var a=g({},e.props),o=e.key,i=e.ref,s=e._owner;if(null!=t){if(void 0!==t.ref&&(i=t.ref,s=S.current),void 0!==t.key&&(o=""+t.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(l in t)k.call(t,l)&&!C.hasOwnProperty(l)&&(a[l]=void 0===t[l]&&void 0!==c?c[l]:t[l])}var l=arguments.length-2;if(1===l)a.children=r;else if(1<l){c=Array(l);for(var u=0;u<l;u++)c[u]=arguments[u+2];a.children=c}return{$$typeof:n,type:e.type,key:o,ref:i,props:a,_owner:s}},t.createContext=function(e){return(e={$$typeof:c,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:s,_context:e},e.Consumer=e},t.createElement=I,t.createFactory=function(e){var t=I.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:l,render:e}},t.isValidElement=E,t.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:O}},t.memo=function(e,t){return{$$typeof:d,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=_.transition;_.transition={};try{e()}finally{_.transition=t}},t.unstable_act=M,t.useCallback=function(e,t){return F.current.useCallback(e,t)},t.useContext=function(e){return F.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return F.current.useDeferredValue(e)},t.useEffect=function(e,t){return F.current.useEffect(e,t)},t.useId=function(){return F.current.useId()},t.useImperativeHandle=function(e,t,n){return F.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return F.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return F.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return F.current.useMemo(e,t)},t.useReducer=function(e,t,n){return F.current.useReducer(e,t,n)},t.useRef=function(e){return F.current.useRef(e)},t.useState=function(e){return F.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return F.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return F.current.useTransition()},t.version="18.3.1"},43:(e,t,n)=>{"use strict";e.exports=n(202)},579:(e,t,n)=>{"use strict";e.exports=n(153)},234:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,a=e[r];if(!(0<o(a,t)))break e;e[r]=t,e[n]=a,n=r}}function r(e){return 0===e.length?null:e[0]}function a(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,a=e.length,i=a>>>1;r<i;){var s=2*(r+1)-1,c=e[s],l=s+1,u=e[l];if(0>o(c,n))l<a&&0>o(u,c)?(e[r]=u,e[l]=n,r=l):(e[r]=c,e[s]=n,r=s);else{if(!(l<a&&0>o(u,n)))break e;e[r]=u,e[l]=n,r=l}}}return t}function o(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var s=Date,c=s.now();t.unstable_now=function(){return s.now()-c}}var l=[],u=[],d=1,h=null,p=3,f=!1,g=!1,m=!1,v="function"===typeof setTimeout?setTimeout:null,b="function"===typeof clearTimeout?clearTimeout:null,y="undefined"!==typeof setImmediate?setImmediate:null;function x(e){for(var t=r(u);null!==t;){if(null===t.callback)a(u);else{if(!(t.startTime<=e))break;a(u),t.sortIndex=t.expirationTime,n(l,t)}t=r(u)}}function w(e){if(m=!1,x(e),!g)if(null!==r(l))g=!0,_(k);else{var t=r(u);null!==t&&D(w,t.startTime-e)}}function k(e,n){g=!1,m&&(m=!1,b(E),E=-1),f=!0;var o=p;try{for(x(n),h=r(l);null!==h&&(!(h.expirationTime>n)||e&&!R());){var i=h.callback;if("function"===typeof i){h.callback=null,p=h.priorityLevel;var s=i(h.expirationTime<=n);n=t.unstable_now(),"function"===typeof s?h.callback=s:h===r(l)&&a(l),x(n)}else a(l);h=r(l)}if(null!==h)var c=!0;else{var d=r(u);null!==d&&D(w,d.startTime-n),c=!1}return c}finally{h=null,p=o,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,C=!1,I=null,E=-1,N=5,T=-1;function R(){return!(t.unstable_now()-T<N)}function A(){if(null!==I){var e=t.unstable_now();T=e;var n=!0;try{n=I(!0,e)}finally{n?S():(C=!1,I=null)}}else C=!1}if("function"===typeof y)S=function(){y(A)};else if("undefined"!==typeof MessageChannel){var O=new MessageChannel,F=O.port2;O.port1.onmessage=A,S=function(){F.postMessage(null)}}else S=function(){v(A,0)};function _(e){I=e,C||(C=!0,S())}function D(e,n){E=v((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){g||f||(g=!0,_(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):N=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return r(l)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,a,o){var i=t.unstable_now();switch("object"===typeof o&&null!==o?o="number"===typeof(o=o.delay)&&0<o?i+o:i:o=i,e){case 1:var s=-1;break;case 2:s=250;break;case 5:s=1073741823;break;case 4:s=1e4;break;default:s=5e3}return e={id:d++,callback:a,priorityLevel:e,startTime:o,expirationTime:s=o+s,sortIndex:-1},o>i?(e.sortIndex=o,n(u,e),null===r(l)&&e===r(u)&&(m?(b(E),E=-1):m=!0,D(w,o-i))):(e.sortIndex=s,n(l,e),g||f||(g=!0,_(k))),e},t.unstable_shouldYield=R,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},853:(e,t,n)=>{"use strict";e.exports=n(234)},334:(e,t,n)=>{var r=n(359),a=n(66),o=n(16),i=n(538),s=n(288),c=n(262),l=n(430);l.alea=r,l.xor128=a,l.xorwow=o,l.xorshift7=i,l.xor4096=s,l.tychei=c,e.exports=l},359:function(e,t,n){var r;!function(e,a,o){function i(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function c(e,t){var n=new i(e),r=t&&t.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.quick=a,r&&("object"==typeof r&&s(r,n),a.state=function(){return s(n,{})}),a}a&&a.exports?a.exports=c:n.amdD&&n.amdO?void 0===(r=function(){return c}.call(t,n,t,a))||(a.exports=r):this.alea=c}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var r;!function(e,a,o){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function c(e,t){var n=new i(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&s(r,n),a.state=function(){return s(n,{})}),a}a&&a.exports?a.exports=c:n.amdD&&n.amdO?void 0===(r=function(){return c}.call(t,n,t,a))||(a.exports=r):this.tychei=c}(0,e=n.nmd(e),n.amdD)},66:function(e,t,n){var r;!function(e,a,o){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function c(e,t){var n=new i(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&s(r,n),a.state=function(){return s(n,{})}),a}a&&a.exports?a.exports=c:n.amdD&&n.amdO?void 0===(r=function(){return c}.call(t,n,t,a))||(a.exports=r):this.xor128=c}(0,e=n.nmd(e),n.amdD)},288:function(e,t,n){var r;!function(e,a,o){function i(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,o=t.i;return t.w=r=r+1640531527|0,n=a[o+34&127],e=a[o=o+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[o]=n^e,t.i=o,n+(r^r>>>16)|0},function(e,t){var n,r,a,o,i,s=[],c=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,c=Math.max(c,t.length)),a=0,o=-32;o<c;++o)t&&(r^=t.charCodeAt((o+32)%t.length)),0===o&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,o>=0&&(i=i+1640531527|0,a=0==(n=s[127&o]^=r+i)?a+1:0);for(a>=128&&(s[127&(t&&t.length||0)]=-1),a=127,o=512;o>0;--o)r=s[a+34&127],n=s[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[a]=r^n;e.w=i,e.X=s,e.i=a}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function c(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.X&&s(r,n),a.state=function(){return s(n,{})}),a}a&&a.exports?a.exports=c:n.amdD&&n.amdO?void 0===(r=function(){return c}.call(t,n,t,a))||(a.exports=r):this.xor4096=c}(0,e=n.nmd(e),n.amdD)},538:function(e,t,n){var r;!function(e,a,o){function i(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function c(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.x&&s(r,n),a.state=function(){return s(n,{})}),a}a&&a.exports?a.exports=c:n.amdD&&n.amdO?void 0===(r=function(){return c}.call(t,n,t,a))||(a.exports=r):this.xorshift7=c}(0,e=n.nmd(e),n.amdD)},16:function(e,t,n){var r;!function(e,a,o){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function c(e,t){var n=new i(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&s(r,n),a.state=function(){return s(n,{})}),a}a&&a.exports?a.exports=c:n.amdD&&n.amdO?void 0===(r=function(){return c}.call(t,n,t,a))||(a.exports=r):this.xorwow=c}(0,e=n.nmd(e),n.amdD)},430:function(e,t,n){var r;!function(a,o,i){var s,c=256,l=i.pow(c,6),u=i.pow(2,52),d=2*u,h=c-1;function p(e,t,n){var r=[],h=v(m((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(o)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(c):(e=new Uint8Array(c),(a.crypto||a.msCrypto).getRandomValues(e)),b(e)}catch(r){var t=a.navigator,n=t&&t.plugins;return[+new Date,a,n,a.screen,b(o)]}}():e,3),r),p=new f(r),y=function(){for(var e=p.g(6),t=l,n=0;e<u;)e=(e+n)*c,t*=c,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return y.int32=function(){return 0|p.g(4)},y.quick=function(){return p.g(4)/4294967296},y.double=y,v(b(p.S),o),(t.pass||n||function(e,t,n,r){return r&&(r.S&&g(r,p),e.state=function(){return g(p,{})}),n?(i.random=e,t):e})(y,h,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,a=0,o=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);a<c;)i[a]=a++;for(a=0;a<c;a++)i[a]=i[o=h&o+e[a%n]+(t=i[a])],i[o]=t;(r.g=function(e){for(var t,n=0,a=r.i,o=r.j,i=r.S;e--;)t=i[a=h&a+1],n=n*c+i[h&(i[a]=i[o=h&o+t])+(i[o]=t)];return r.i=a,r.j=o,n})(c)}function g(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function m(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(m(e[n],t-1))}catch(o){}return r.length?r:"string"==a?e:e+"\0"}function v(e,t){for(var n,r=e+"",a=0;a<r.length;)t[h&a]=h&(n^=19*t[h&a])+r.charCodeAt(a++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),o),e.exports){e.exports=p;try{s=n(996)}catch(y){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!==typeof self?self:this,[],Math)},324:e=>{e.exports=function(e,t,n,r){var a=n?n.call(r,e,t):void 0;if(void 0!==a)return!!a;if(e===t)return!0;if("object"!==typeof e||!e||"object"!==typeof t||!t)return!1;var o=Object.keys(e),i=Object.keys(t);if(o.length!==i.length)return!1;for(var s=Object.prototype.hasOwnProperty.bind(t),c=0;c<o.length;c++){var l=o[c];if(!s(l))return!1;var u=e[l],d=t[l];if(!1===(a=n?n.call(r,u,d,l):void 0)||void 0===a&&u!==d)return!1}return!0}},520:e=>{e.exports=function(){var e=document.getSelection();if(!e.rangeCount)return function(){};for(var t=document.activeElement,n=[],r=0;r<e.rangeCount;r++)n.push(e.getRangeAt(r));switch(t.tagName.toUpperCase()){case"INPUT":case"TEXTAREA":t.blur();break;default:t=null}return e.removeAllRanges(),function(){"Caret"===e.type&&e.removeAllRanges(),e.rangeCount||n.forEach((function(t){e.addRange(t)})),t&&t.focus()}}},817:()=>{},590:()=>{},530:()=>{},108:()=>{},551:()=>{},996:()=>{},139:(e,t)=>{var n;!function(){"use strict";var r={}.hasOwnProperty;function a(){for(var e="",t=0;t<arguments.length;t++){var n=arguments[t];n&&(e=i(e,o(n)))}return e}function o(e){if("string"===typeof e||"number"===typeof e)return e;if("object"!==typeof e)return"";if(Array.isArray(e))return a.apply(null,e);if(e.toString!==Object.prototype.toString&&!e.toString.toString().includes("[native code]"))return e.toString();var t="";for(var n in e)r.call(e,n)&&e[n]&&(t=i(t,n));return t}function i(e,t){return t?e?e+" "+t:e+t:e}e.exports?(a.default=a,e.exports=a):void 0===(n=function(){return a}.apply(t,[]))||(e.exports=n)}()}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},(()=>{var e,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;n.t=function(r,a){if(1&a&&(r=this(r)),8&a)return r;if("object"===typeof r&&r){if(4&a&&r.__esModule)return r;if(16&a&&"function"===typeof r.then)return r}var o=Object.create(null);n.r(o);var i={};e=e||[null,t({}),t([]),t(t)];for(var s=2&a&&r;"object"==typeof s&&!~e.indexOf(s);s=t(s))Object.getOwnPropertyNames(s).forEach((e=>i[e]=()=>r[e]));return i.default=()=>r,n.d(o,i),o}})(),n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.f={},n.e=e=>Promise.all(Object.keys(n.f).reduce(((t,r)=>(n.f[r](e,t),t)),[])),n.u=e=>"static/js/"+e+".2baa69f7.chunk.js",n.miniCssF=e=>{},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e={},t="proctoring-app:";n.l=(r,a,o,i)=>{if(e[r])e[r].push(a);else{var s,c;if(void 0!==o)for(var l=document.getElementsByTagName("script"),u=0;u<l.length;u++){var d=l[u];if(d.getAttribute("src")==r||d.getAttribute("data-webpack")==t+o){s=d;break}}s||(c=!0,(s=document.createElement("script")).charset="utf-8",s.timeout=120,n.nc&&s.setAttribute("nonce",n.nc),s.setAttribute("data-webpack",t+o),s.src=r),e[r]=[a];var h=(t,n)=>{s.onerror=s.onload=null,clearTimeout(p);var a=e[r];if(delete e[r],s.parentNode&&s.parentNode.removeChild(s),a&&a.forEach((e=>e(n))),t)return t(n)},p=setTimeout(h.bind(null,void 0,{type:"timeout",target:s}),12e4);s.onerror=h.bind(null,s.onerror),s.onload=h.bind(null,s.onload),c&&document.head.appendChild(s)}}})(),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),n.p="/proctoring-app/",(()=>{var e={792:0};n.f.j=(t,r)=>{var a=n.o(e,t)?e[t]:void 0;if(0!==a)if(a)r.push(a[2]);else{var o=new Promise(((n,r)=>a=e[t]=[n,r]));r.push(a[2]=o);var i=n.p+n.u(t),s=new Error;n.l(i,(r=>{if(n.o(e,t)&&(0!==(a=e[t])&&(e[t]=void 0),a)){var o=r&&("load"===r.type?"missing":r.type),i=r&&r.target&&r.target.src;s.message="Loading chunk "+t+" failed.\n("+o+": "+i+")",s.name="ChunkLoadError",s.type=o,s.request=i,a[1](s)}}),"chunk-"+t,t)}};var t=(t,r)=>{var a,o,i=r[0],s=r[1],c=r[2],l=0;if(i.some((t=>0!==e[t]))){for(a in s)n.o(s,a)&&(n.m[a]=s[a]);if(c)c(n)}for(t&&t(r);l<i.length;l++)o=i[l],n.o(e,o)&&e[o]&&e[o][0](),e[o]=0},r=self.webpackChunkproctoring_app=self.webpackChunkproctoring_app||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})(),n.nc=void 0,(()=>{"use strict";var e={};n.r(e),n.d(e,{assertParamsValid:()=>HS,computeFlatOffset:()=>rC,computeOutShape:()=>qS,getNormalizedAxes:()=>YS,isSliceContinous:()=>nC,maskToAxes:()=>GS,parseSliceParams:()=>aC,sliceInfo:()=>oC,startForAxis:()=>eC,startIndicesWithElidedDims:()=>QS,stopForAxis:()=>tC,stopIndicesWithElidedDims:()=>ZS,stridesForAxis:()=>JS,stridesWithElidedDims:()=>KS});var t={};n.r(t),n.d(t,{collectGatherOpShapeInfo:()=>ST,computeOutShape:()=>kT,segOpComputeOptimalWindowSize:()=>wT});var r={};n.r(r),n.d(r,{ERF_A1:()=>BN,ERF_A2:()=>WN,ERF_A3:()=>UN,ERF_A4:()=>VN,ERF_A5:()=>jN,ERF_P:()=>zN,PARALLELIZE_THRESHOLD:()=>CN,RowPartitionType:()=>yN,SELU_SCALE:()=>LN,SELU_SCALEALPHA:()=>PN,applyActivation:()=>kE,assertAndGetBroadcastShape:()=>NS,assertAxesAreInnerMostDims:()=>gI,assertParamsConsistent:()=>vN,assignToTypedArray:()=>$N,axesAreInnerMostDims:()=>dI,calculateShapes:()=>MN,checkEinsumDimSizes:()=>aT,checkPadOnDimRoundingMode:()=>CC,combineLocations:()=>hI,combineRaggedTensorToTensorShapes:()=>xN,complexWithEvenIndex:()=>qN,complexWithOddIndex:()=>KN,computeConv2DInfo:()=>pC,computeConv3DInfo:()=>fC,computeDefaultPad:()=>gC,computeDilation2DInfo:()=>uC,computeOptimalWindowSize:()=>IN,computeOutAndReduceShapes:()=>pI,computeOutShape:()=>bN,computePool2DInfo:()=>dC,computePool3DInfo:()=>hC,convertConv2DDataFormat:()=>SC,decodeEinsumEquation:()=>nT,eitherStridesOrDilationsAreOne:()=>wC,expandShapeToKeepDim:()=>fI,exponent:()=>QN,exponents:()=>YN,fromStringArrayToUint8:()=>IT,fromUint8ToStringArray:()=>CT,getAxesPermutation:()=>mI,getBroadcastDims:()=>IS,getComplexWithIndex:()=>XN,getEinsumComputePath:()=>oT,getEinsumPermutation:()=>rT,getFusedBiasGradient:()=>wE,getFusedDyActivation:()=>xE,getImageCenter:()=>EN,getInnerMostAxes:()=>bI,getPermuted:()=>TN,getRaggedRank:()=>kN,getReductionAxes:()=>ES,getReshaped:()=>NN,getReshapedPermuted:()=>RN,getRowPartitionTypesHelper:()=>wN,getSliceBeginCoords:()=>AN,getSliceSize:()=>ON,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>lT,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>uT,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>dT,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>fT,getSparseReshapeInputOutputMismatchErrorMessage:()=>mT,getSparseReshapeInputOutputMultipleErrorMessage:()=>gT,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>hT,getSparseReshapeNegativeOutputDimErrorMessage:()=>pT,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>xT,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>vT,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>bT,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>yT,getUndoAxesPermutation:()=>vI,isIdentityPermutation:()=>iT,log:()=>Dx,mergeRealAndImagArrays:()=>HN,prepareAndValidate:()=>FN,prepareSplitSize:()=>cT,segment_util:()=>t,shouldFuse:()=>SE,slice_util:()=>e,splitRealAndImagArrays:()=>GN,stridesOrDilationsArePositive:()=>kC,tupleValuesAreOne:()=>xC,upcastType:()=>Mw,validateDefaultValueShape:()=>SN,validateInput:()=>DN,validateUpdateShape:()=>_N,warn:()=>_x});var a={};n.r(a),n.d(a,{mx:()=>Sz,XI:()=>gB,Nk:()=>mB,f6:()=>bB,ct:()=>bz,YG:()=>wB,hH:()=>NB,z3:()=>dW,sG:()=>kW,uM:()=>NW,vS:()=>HW,qB:()=>ZW,GG:()=>eU,lg:()=>oU,rq:()=>nU,cu:()=>bU,WR:()=>gU,GE:()=>wU,px:()=>SU,jC:()=>zU,He:()=>UU,hE:()=>QU,BF:()=>rW,Dk:()=>sV,cl:()=>gV,_B:()=>TV,ub:()=>_V,_f:()=>PV,Ku:()=>VV,qy:()=>HV,Zy:()=>nj,bu:()=>oj,zv:()=>lz,dH:()=>Fz,HS:()=>dB,yH:()=>Ij,l3:()=>Nj,z9:()=>Rj,x6:()=>Dj,_m:()=>Uj,eW:()=>qj,GK:()=>$j,SP:()=>Zj,yr:()=>eH,dl:()=>_W,Dw:()=>iH,xT:()=>uH,_X:()=>Bz,wz:()=>vH});var o=n(43),i=n.t(o,2),s=n(391);var c,l=n(950),u=n.t(l,2);function d(){return d=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},d.apply(this,arguments)}!function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"}(c||(c={}));const h="popstate";function p(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function f(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(n){}}}function g(e,t){return{usr:e.state,key:e.key,idx:t}}function m(e,t,n,r){return void 0===n&&(n=null),d({pathname:"string"===typeof e?e:e.pathname,search:"",hash:""},"string"===typeof t?b(t):t,{state:n,key:t&&t.key||r||Math.random().toString(36).substr(2,8)})}function v(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(t+="#"===r.charAt(0)?r:"#"+r),t}function b(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substr(r),e=e.substr(0,r)),e&&(t.pathname=e)}return t}function y(e,t,n,r){void 0===r&&(r={});let{window:a=document.defaultView,v5Compat:o=!1}=r,i=a.history,s=c.Pop,l=null,u=f();function f(){return(i.state||{idx:null}).idx}function b(){s=c.Pop;let e=f(),t=null==e?null:e-u;u=e,l&&l({action:s,location:x.location,delta:t})}function y(e){let t="null"!==a.location.origin?a.location.origin:a.location.href,n="string"===typeof e?e:v(e);return n=n.replace(/ $/,"%20"),p(t,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,t)}null==u&&(u=0,i.replaceState(d({},i.state,{idx:u}),""));let x={get action(){return s},get location(){return e(a,i)},listen(e){if(l)throw new Error("A history only accepts one active listener");return a.addEventListener(h,b),l=e,()=>{a.removeEventListener(h,b),l=null}},createHref:e=>t(a,e),createURL:y,encodeLocation(e){let t=y(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){s=c.Push;let r=m(x.location,e,t);n&&n(r,e),u=f()+1;let d=g(r,u),h=x.createHref(r);try{i.pushState(d,"",h)}catch(p){if(p instanceof DOMException&&"DataCloneError"===p.name)throw p;a.location.assign(h)}o&&l&&l({action:s,location:x.location,delta:1})},replace:function(e,t){s=c.Replace;let r=m(x.location,e,t);n&&n(r,e),u=f();let a=g(r,u),d=x.createHref(r);i.replaceState(a,"",d),o&&l&&l({action:s,location:x.location,delta:0})},go:e=>i.go(e)};return x}var x;!function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"}(x||(x={}));new Set(["lazy","caseSensitive","path","id","index","children"]);function w(e,t,n){void 0===n&&(n="/");let r=M(("string"===typeof t?b(t):t).pathname||"/",n);if(null==r)return null;let a=k(e);!function(e){e.sort(((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every(((e,n)=>e===t[n]));return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map((e=>e.childrenIndex)),t.routesMeta.map((e=>e.childrenIndex)))))}(a);let o=null;for(let i=0;null==o&&i<a.length;++i){let e=D(r);o=F(a[i],e)}return o}function k(e,t,n,r){void 0===t&&(t=[]),void 0===n&&(n=[]),void 0===r&&(r="");let a=(e,a,o)=>{let i={relativePath:void 0===o?e.path||"":o,caseSensitive:!0===e.caseSensitive,childrenIndex:a,route:e};i.relativePath.startsWith("/")&&(p(i.relativePath.startsWith(r),'Absolute route path "'+i.relativePath+'" nested under path "'+r+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),i.relativePath=i.relativePath.slice(r.length));let s=P([r,i.relativePath]),c=n.concat(i);e.children&&e.children.length>0&&(p(!0!==e.index,'Index routes must not have child routes. Please remove all child routes from route path "'+s+'".'),k(e.children,t,c,s)),(null!=e.path||e.index)&&t.push({path:s,score:O(s,e.index),routesMeta:c})};return e.forEach(((e,t)=>{var n;if(""!==e.path&&null!=(n=e.path)&&n.includes("?"))for(let r of S(e.path))a(e,t,r);else a(e,t)})),t}function S(e){let t=e.split("/");if(0===t.length)return[];let[n,...r]=t,a=n.endsWith("?"),o=n.replace(/\?$/,"");if(0===r.length)return a?[o,""]:[o];let i=S(r.join("/")),s=[];return s.push(...i.map((e=>""===e?o:[o,e].join("/")))),a&&s.push(...i),s.map((t=>e.startsWith("/")&&""===t?"/":t))}const C=/^:[\w-]+$/,I=3,E=2,N=1,T=10,R=-2,A=e=>"*"===e;function O(e,t){let n=e.split("/"),r=n.length;return n.some(A)&&(r+=R),t&&(r+=E),n.filter((e=>!A(e))).reduce(((e,t)=>e+(C.test(t)?I:""===t?N:T)),r)}function F(e,t){let{routesMeta:n}=e,r={},a="/",o=[];for(let i=0;i<n.length;++i){let e=n[i],s=i===n.length-1,c="/"===a?t:t.slice(a.length)||"/",l=_({path:e.relativePath,caseSensitive:e.caseSensitive,end:s},c);if(!l)return null;Object.assign(r,l.params);let u=e.route;o.push({params:r,pathname:P([a,l.pathname]),pathnameBase:L(P([a,l.pathnameBase])),route:u}),"/"!==l.pathnameBase&&(a=P([a,l.pathnameBase]))}return o}function _(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=!0);f("*"===e||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were "'+e.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+e.replace(/\*$/,"/*")+'".');let r=[],a="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((e,t,n)=>(r.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));e.endsWith("*")?(r.push({paramName:"*"}),a+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?a+="\\/*$":""!==e&&"/"!==e&&(a+="(?:(?=\\/|$))");let o=new RegExp(a,t?void 0:"i");return[o,r]}(e.path,e.caseSensitive,e.end),a=t.match(n);if(!a)return null;let o=a[0],i=o.replace(/(.)\/+$/,"$1"),s=a.slice(1),c=r.reduce(((e,t,n)=>{let{paramName:r,isOptional:a}=t;if("*"===r){let e=s[n]||"";i=o.slice(0,o.length-e.length).replace(/(.)\/+$/,"$1")}const c=s[n];return e[r]=a&&!c?void 0:(c||"").replace(/%2F/g,"/"),e}),{});return{params:c,pathname:o,pathnameBase:i,pattern:e}}function D(e){try{return e.split("/").map((e=>decodeURIComponent(e).replace(/\//g,"%2F"))).join("/")}catch(t){return f(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+t+")."),e}}function M(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&"/"!==r?null:e.slice(n)||"/"}const P=e=>e.join("/").replace(/\/\/+/g,"/"),L=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/");Error;function z(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}const B=["post","put","patch","delete"],W=(new Set(B),["get",...B]);new Set(W),new Set([301,302,303,307,308]),new Set([307,308]);Symbol("deferred");function U(){return U=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},U.apply(this,arguments)}const V=o.createContext(null);const j=o.createContext(null);const H=o.createContext(null);const G=o.createContext(null);const q=o.createContext({outlet:null,matches:[],isDataRoute:!1});const K=o.createContext(null);function X(){return null!=o.useContext(G)}function $(){return X()||p(!1),o.useContext(G).location}function Y(e,t,n,r){X()||p(!1);let{navigator:a}=o.useContext(H),{matches:i}=o.useContext(q),s=i[i.length-1],l=s?s.params:{},u=(s&&s.pathname,s?s.pathnameBase:"/");s&&s.route;let d,h=$();if(t){var f;let e="string"===typeof t?b(t):t;"/"===u||(null==(f=e.pathname)?void 0:f.startsWith(u))||p(!1),d=e}else d=h;let g=d.pathname||"/",m=g;if("/"!==u){let e=u.replace(/^\//,"").split("/");m="/"+g.replace(/^\//,"").split("/").slice(e.length).join("/")}let v=w(e,{pathname:m});let y=te(v&&v.map((e=>Object.assign({},e,{params:Object.assign({},l,e.params),pathname:P([u,a.encodeLocation?a.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?u:P([u,a.encodeLocation?a.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])}))),i,n,r);return t&&y?o.createElement(G.Provider,{value:{location:U({pathname:"/",search:"",hash:"",state:null,key:"default"},d),navigationType:c.Pop}},y):y}function Q(){let e=function(){var e;let t=o.useContext(K),n=re(ne.UseRouteError),r=ae(ne.UseRouteError);if(void 0!==t)return t;return null==(e=n.errors)?void 0:e[r]}(),t=z(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,r="rgba(200,200,200, 0.5)",a={padding:"0.5rem",backgroundColor:r};return o.createElement(o.Fragment,null,o.createElement("h2",null,"Unexpected Application Error!"),o.createElement("h3",{style:{fontStyle:"italic"}},t),n?o.createElement("pre",{style:a},n):null,null)}const Z=o.createElement(Q,null);class J extends o.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?o.createElement(q.Provider,{value:this.props.routeContext},o.createElement(K.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function ee(e){let{routeContext:t,match:n,children:r}=e,a=o.useContext(V);return a&&a.static&&a.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=n.route.id),o.createElement(q.Provider,{value:t},r)}function te(e,t,n,r){var a;if(void 0===t&&(t=[]),void 0===n&&(n=null),void 0===r&&(r=null),null==e){var i;if(null==(i=n)||!i.errors)return null;e=n.matches}let s=e,c=null==(a=n)?void 0:a.errors;if(null!=c){let e=s.findIndex((e=>e.route.id&&void 0!==(null==c?void 0:c[e.route.id])));e>=0||p(!1),s=s.slice(0,Math.min(s.length,e+1))}let l=!1,u=-1;if(n&&r&&r.v7_partialHydration)for(let o=0;o<s.length;o++){let e=s[o];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(u=o),e.route.id){let{loaderData:t,errors:r}=n,a=e.route.loader&&void 0===t[e.route.id]&&(!r||void 0===r[e.route.id]);if(e.route.lazy||a){l=!0,s=u>=0?s.slice(0,u+1):[s[0]];break}}}return s.reduceRight(((e,r,a)=>{let i,d=!1,h=null,p=null;var f;n&&(i=c&&r.route.id?c[r.route.id]:void 0,h=r.route.errorElement||Z,l&&(u<0&&0===a?(f="route-fallback",!1||oe[f]||(oe[f]=!0),d=!0,p=null):u===a&&(d=!0,p=r.route.hydrateFallbackElement||null)));let g=t.concat(s.slice(0,a+1)),m=()=>{let t;return t=i?h:d?p:r.route.Component?o.createElement(r.route.Component,null):r.route.element?r.route.element:e,o.createElement(ee,{match:r,routeContext:{outlet:e,matches:g,isDataRoute:null!=n},children:t})};return n&&(r.route.ErrorBoundary||r.route.errorElement||0===a)?o.createElement(J,{location:n.location,revalidation:n.revalidation,component:h,error:i,children:m(),routeContext:{outlet:null,matches:g,isDataRoute:!0}}):m()}),null)}var ne=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(ne||{});function re(e){let t=o.useContext(j);return t||p(!1),t}function ae(e){let t=function(e){let t=o.useContext(q);return t||p(!1),t}(),n=t.matches[t.matches.length-1];return n.route.id||p(!1),n.route.id}const oe={};i.startTransition;function ie(e){p(!1)}function se(e){let{basename:t="/",children:n=null,location:r,navigationType:a=c.Pop,navigator:i,static:s=!1,future:l}=e;X()&&p(!1);let u=t.replace(/^\/*/,"/"),d=o.useMemo((()=>({basename:u,navigator:i,static:s,future:U({v7_relativeSplatPath:!1},l)})),[u,l,i,s]);"string"===typeof r&&(r=b(r));let{pathname:h="/",search:f="",hash:g="",state:m=null,key:v="default"}=r,y=o.useMemo((()=>{let e=M(h,u);return null==e?null:{location:{pathname:e,search:f,hash:g,state:m,key:v},navigationType:a}}),[u,h,f,g,m,v,a]);return null==y?null:o.createElement(H.Provider,{value:d},o.createElement(G.Provider,{children:n,value:y}))}function ce(e){let{children:t,location:n}=e;return Y(le(t),n)}new Promise((()=>{}));o.Component;function le(e,t){void 0===t&&(t=[]);let n=[];return o.Children.forEach(e,((e,r)=>{if(!o.isValidElement(e))return;let a=[...t,r];if(e.type===o.Fragment)return void n.push.apply(n,le(e.props.children,a));e.type!==ie&&p(!1),e.props.index&&e.props.children&&p(!1);let i={id:e.props.id||a.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(i.children=le(e.props.children,a)),n.push(i)})),n}new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);try{window.__reactRouterVersion="6"}catch(f0){}new Map;const ue=i.startTransition;u.flushSync,i.useId;function de(e){let{basename:t,children:n,future:r,window:a}=e,i=o.useRef();var s;null==i.current&&(i.current=(void 0===(s={window:a,v5Compat:!0})&&(s={}),y((function(e,t){let{pathname:n,search:r,hash:a}=e.location;return m("",{pathname:n,search:r,hash:a},t.state&&t.state.usr||null,t.state&&t.state.key||"default")}),(function(e,t){return"string"===typeof t?t:v(t)}),null,s)));let c=i.current,[l,u]=o.useState({action:c.action,location:c.location}),{v7_startTransition:d}=r||{},h=o.useCallback((e=>{d&&ue?ue((()=>u(e))):u(e)}),[u,d]);return o.useLayoutEffect((()=>c.listen(h)),[c,h]),o.createElement(se,{basename:t,children:n,location:l.location,navigationType:l.action,navigator:c,future:r})}"undefined"!==typeof window&&"undefined"!==typeof window.document&&window.document.createElement;var he,pe;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(he||(he={})),function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"}(pe||(pe={}));var fe=function(){return fe=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var a in t=arguments[n])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e},fe.apply(this,arguments)};Object.create;function ge(e,t,n){if(n||2===arguments.length)for(var r,a=0,o=t.length;a<o;a++)!r&&a in t||(r||(r=Array.prototype.slice.call(t,0,a)),r[a]=t[a]);return e.concat(r||Array.prototype.slice.call(t))}Object.create;"function"===typeof SuppressedError&&SuppressedError;var me=n(324),ve=n.n(me),be="-ms-",ye="-moz-",xe="-webkit-",we="comm",ke="rule",Se="decl",Ce="@import",Ie="@keyframes",Ee="@layer",Ne=Math.abs,Te=String.fromCharCode,Re=Object.assign;function Ae(e){return e.trim()}function Oe(e,t){return(e=t.exec(e))?e[0]:e}function Fe(e,t,n){return e.replace(t,n)}function _e(e,t,n){return e.indexOf(t,n)}function De(e,t){return 0|e.charCodeAt(t)}function Me(e,t,n){return e.slice(t,n)}function Pe(e){return e.length}function Le(e){return e.length}function ze(e,t){return t.push(e),e}function Be(e,t){return e.filter((function(e){return!Oe(e,t)}))}var We=1,Ue=1,Ve=0,je=0,He=0,Ge="";function qe(e,t,n,r,a,o,i,s){return{value:e,root:t,parent:n,type:r,props:a,children:o,line:We,column:Ue,length:i,return:"",siblings:s}}function Ke(e,t){return Re(qe("",null,null,"",null,null,0,e.siblings),e,{length:-e.length},t)}function Xe(e){for(;e.root;)e=Ke(e.root,{children:[e]});ze(e,e.siblings)}function $e(){return He=je>0?De(Ge,--je):0,Ue--,10===He&&(Ue=1,We--),He}function Ye(){return He=je<Ve?De(Ge,je++):0,Ue++,10===He&&(Ue=1,We++),He}function Qe(){return De(Ge,je)}function Ze(){return je}function Je(e,t){return Me(Ge,e,t)}function et(e){switch(e){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function tt(e){return We=Ue=1,Ve=Pe(Ge=e),je=0,[]}function nt(e){return Ge="",e}function rt(e){return Ae(Je(je-1,it(91===e?e+2:40===e?e+1:e)))}function at(e){for(;(He=Qe())&&He<33;)Ye();return et(e)>2||et(He)>3?"":" "}function ot(e,t){for(;--t&&Ye()&&!(He<48||He>102||He>57&&He<65||He>70&&He<97););return Je(e,Ze()+(t<6&&32==Qe()&&32==Ye()))}function it(e){for(;Ye();)switch(He){case e:return je;case 34:case 39:34!==e&&39!==e&&it(He);break;case 40:41===e&&it(e);break;case 92:Ye()}return je}function st(e,t){for(;Ye()&&e+He!==57&&(e+He!==84||47!==Qe()););return"/*"+Je(t,je-1)+"*"+Te(47===e?e:Ye())}function ct(e){for(;!et(Qe());)Ye();return Je(e,je)}function lt(e,t){for(var n="",r=0;r<e.length;r++)n+=t(e[r],r,e,t)||"";return n}function ut(e,t,n,r){switch(e.type){case Ee:if(e.children.length)break;case Ce:case Se:return e.return=e.return||e.value;case we:return"";case Ie:return e.return=e.value+"{"+lt(e.children,r)+"}";case ke:if(!Pe(e.value=e.props.join(",")))return""}return Pe(n=lt(e.children,r))?e.return=e.value+"{"+n+"}":""}function dt(e,t,n){switch(function(e,t){return 45^De(e,0)?(((t<<2^De(e,0))<<2^De(e,1))<<2^De(e,2))<<2^De(e,3):0}(e,t)){case 5103:return xe+"print-"+e+e;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return xe+e+e;case 4789:return ye+e+e;case 5349:case 4246:case 4810:case 6968:case 2756:return xe+e+ye+e+be+e+e;case 5936:switch(De(e,t+11)){case 114:return xe+e+be+Fe(e,/[svh]\w+-[tblr]{2}/,"tb")+e;case 108:return xe+e+be+Fe(e,/[svh]\w+-[tblr]{2}/,"tb-rl")+e;case 45:return xe+e+be+Fe(e,/[svh]\w+-[tblr]{2}/,"lr")+e}case 6828:case 4268:case 2903:return xe+e+be+e+e;case 6165:return xe+e+be+"flex-"+e+e;case 5187:return xe+e+Fe(e,/(\w+).+(:[^]+)/,xe+"box-$1$2"+be+"flex-$1$2")+e;case 5443:return xe+e+be+"flex-item-"+Fe(e,/flex-|-self/g,"")+(Oe(e,/flex-|baseline/)?"":be+"grid-row-"+Fe(e,/flex-|-self/g,""))+e;case 4675:return xe+e+be+"flex-line-pack"+Fe(e,/align-content|flex-|-self/g,"")+e;case 5548:return xe+e+be+Fe(e,"shrink","negative")+e;case 5292:return xe+e+be+Fe(e,"basis","preferred-size")+e;case 6060:return xe+"box-"+Fe(e,"-grow","")+xe+e+be+Fe(e,"grow","positive")+e;case 4554:return xe+Fe(e,/([^-])(transform)/g,"$1"+xe+"$2")+e;case 6187:return Fe(Fe(Fe(e,/(zoom-|grab)/,xe+"$1"),/(image-set)/,xe+"$1"),e,"")+e;case 5495:case 3959:return Fe(e,/(image-set\([^]*)/,xe+"$1$`$1");case 4968:return Fe(Fe(e,/(.+:)(flex-)?(.*)/,xe+"box-pack:$3"+be+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+xe+e+e;case 4200:if(!Oe(e,/flex-|baseline/))return be+"grid-column-align"+Me(e,t)+e;break;case 2592:case 3360:return be+Fe(e,"template-","")+e;case 4384:case 3616:return n&&n.some((function(e,n){return t=n,Oe(e.props,/grid-\w+-end/)}))?~_e(e+(n=n[t].value),"span",0)?e:be+Fe(e,"-start","")+e+be+"grid-row-span:"+(~_e(n,"span",0)?Oe(n,/\d+/):+Oe(n,/\d+/)-+Oe(e,/\d+/))+";":be+Fe(e,"-start","")+e;case 4896:case 4128:return n&&n.some((function(e){return Oe(e.props,/grid-\w+-start/)}))?e:be+Fe(Fe(e,"-end","-span"),"span ","")+e;case 4095:case 3583:case 4068:case 2532:return Fe(e,/(.+)-inline(.+)/,xe+"$1$2")+e;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(Pe(e)-1-t>6)switch(De(e,t+1)){case 109:if(45!==De(e,t+4))break;case 102:return Fe(e,/(.+:)(.+)-([^]+)/,"$1"+xe+"$2-$3$1"+ye+(108==De(e,t+3)?"$3":"$2-$3"))+e;case 115:return~_e(e,"stretch",0)?dt(Fe(e,"stretch","fill-available"),t,n)+e:e}break;case 5152:case 5920:return Fe(e,/(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/,(function(t,n,r,a,o,i,s){return be+n+":"+r+s+(a?be+n+"-span:"+(o?i:+i-+r)+s:"")+e}));case 4949:if(121===De(e,t+6))return Fe(e,":",":"+xe)+e;break;case 6444:switch(De(e,45===De(e,14)?18:11)){case 120:return Fe(e,/(.+:)([^;\s!]+)(;|(\s+)?!.+)?/,"$1"+xe+(45===De(e,14)?"inline-":"")+"box$3$1"+xe+"$2$3$1"+be+"$2box$3")+e;case 100:return Fe(e,":",":"+be)+e}break;case 5719:case 2647:case 2135:case 3927:case 2391:return Fe(e,"scroll-","scroll-snap-")+e}return e}function ht(e,t,n,r){if(e.length>-1&&!e.return)switch(e.type){case Se:return void(e.return=dt(e.value,e.length,n));case Ie:return lt([Ke(e,{value:Fe(e.value,"@","@"+xe)})],r);case ke:if(e.length)return function(e,t){return e.map(t).join("")}(n=e.props,(function(t){switch(Oe(t,r=/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":Xe(Ke(e,{props:[Fe(t,/:(read-\w+)/,":"+ye+"$1")]})),Xe(Ke(e,{props:[t]})),Re(e,{props:Be(n,r)});break;case"::placeholder":Xe(Ke(e,{props:[Fe(t,/:(plac\w+)/,":"+xe+"input-$1")]})),Xe(Ke(e,{props:[Fe(t,/:(plac\w+)/,":"+ye+"$1")]})),Xe(Ke(e,{props:[Fe(t,/:(plac\w+)/,be+"input-$1")]})),Xe(Ke(e,{props:[t]})),Re(e,{props:Be(n,r)})}return""}))}}function pt(e){return nt(ft("",null,null,null,[""],e=tt(e),0,[0],e))}function ft(e,t,n,r,a,o,i,s,c){for(var l=0,u=0,d=i,h=0,p=0,f=0,g=1,m=1,v=1,b=0,y="",x=a,w=o,k=r,S=y;m;)switch(f=b,b=Ye()){case 40:if(108!=f&&58==De(S,d-1)){-1!=_e(S+=Fe(rt(b),"&","&\f"),"&\f",Ne(l?s[l-1]:0))&&(v=-1);break}case 34:case 39:case 91:S+=rt(b);break;case 9:case 10:case 13:case 32:S+=at(f);break;case 92:S+=ot(Ze()-1,7);continue;case 47:switch(Qe()){case 42:case 47:ze(mt(st(Ye(),Ze()),t,n,c),c);break;default:S+="/"}break;case 123*g:s[l++]=Pe(S)*v;case 125*g:case 59:case 0:switch(b){case 0:case 125:m=0;case 59+u:-1==v&&(S=Fe(S,/\f/g,"")),p>0&&Pe(S)-d&&ze(p>32?vt(S+";",r,n,d-1,c):vt(Fe(S," ","")+";",r,n,d-2,c),c);break;case 59:S+=";";default:if(ze(k=gt(S,t,n,l,u,a,s,y,x=[],w=[],d,o),o),123===b)if(0===u)ft(S,t,k,k,x,o,d,s,w);else switch(99===h&&110===De(S,3)?100:h){case 100:case 108:case 109:case 115:ft(e,k,k,r&&ze(gt(e,k,k,0,0,a,s,y,a,x=[],d,w),w),a,w,d,s,r?x:w);break;default:ft(S,k,k,k,[""],w,0,s,w)}}l=u=p=0,g=v=1,y=S="",d=i;break;case 58:d=1+Pe(S),p=f;default:if(g<1)if(123==b)--g;else if(125==b&&0==g++&&125==$e())continue;switch(S+=Te(b),b*g){case 38:v=u>0?1:(S+="\f",-1);break;case 44:s[l++]=(Pe(S)-1)*v,v=1;break;case 64:45===Qe()&&(S+=rt(Ye())),h=Qe(),u=d=Pe(y=S+=ct(Ze())),b++;break;case 45:45===f&&2==Pe(S)&&(g=0)}}return o}function gt(e,t,n,r,a,o,i,s,c,l,u,d){for(var h=a-1,p=0===a?o:[""],f=Le(p),g=0,m=0,v=0;g<r;++g)for(var b=0,y=Me(e,h+1,h=Ne(m=i[g])),x=e;b<f;++b)(x=Ae(m>0?p[b]+" "+y:Fe(y,/&\f/g,p[b])))&&(c[v++]=x);return qe(e,t,n,0===a?ke:s,c,l,u,d)}function mt(e,t,n,r){return qe(e,t,n,we,Te(He),Me(e,2,-2),0,r)}function vt(e,t,n,r,a){return qe(e,t,n,Se,Me(e,0,r),Me(e,r+1,-1),r,a)}var bt={animationIterationCount:1,aspectRatio:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},yt="undefined"!=typeof process&&void 0!=={NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}&&({NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.REACT_APP_SC_ATTR||{NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.SC_ATTR)||"data-styled",xt="active",wt="data-styled-version",kt="6.1.11",St="/*!sc*/\n",Ct="undefined"!=typeof window&&"HTMLElement"in window,It=Boolean("boolean"==typeof SC_DISABLE_SPEEDY?SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!=={NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}&&void 0!=={NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.REACT_APP_SC_DISABLE_SPEEDY&&""!=={NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.REACT_APP_SC_DISABLE_SPEEDY?"false"!=={NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.REACT_APP_SC_DISABLE_SPEEDY&&{NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.REACT_APP_SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!=={NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}&&void 0!=={NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.SC_DISABLE_SPEEDY&&""!=={NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.SC_DISABLE_SPEEDY&&("false"!=={NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.SC_DISABLE_SPEEDY&&{NODE_ENV:"production",PUBLIC_URL:"/proctoring-app",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.SC_DISABLE_SPEEDY)),Et=(new Set,Object.freeze([])),Nt=Object.freeze({});function Tt(e,t,n){return void 0===n&&(n=Nt),e.theme!==n.theme&&e.theme||t||n.theme}var Rt=new Set(["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","tr","track","u","ul","use","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","marker","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"]),At=/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,Ot=/(^-|-$)/g;function Ft(e){return e.replace(At,"-").replace(Ot,"")}var _t=/(a)(d)/gi,Dt=52,Mt=function(e){return String.fromCharCode(e+(e>25?39:97))};function Pt(e){var t,n="";for(t=Math.abs(e);t>Dt;t=t/Dt|0)n=Mt(t%Dt)+n;return(Mt(t%Dt)+n).replace(_t,"$1-$2")}var Lt,zt=5381,Bt=function(e,t){for(var n=t.length;n;)e=33*e^t.charCodeAt(--n);return e},Wt=function(e){return Bt(zt,e)};function Ut(e){return Pt(Wt(e)>>>0)}function Vt(e){return e.displayName||e.name||"Component"}function jt(e){return"string"==typeof e&&!0}var Ht="function"==typeof Symbol&&Symbol.for,Gt=Ht?Symbol.for("react.memo"):60115,qt=Ht?Symbol.for("react.forward_ref"):60112,Kt={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},Xt={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},$t={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},Yt=((Lt={})[qt]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},Lt[Gt]=$t,Lt);function Qt(e){return("type"in(t=e)&&t.type.$$typeof)===Gt?$t:"$$typeof"in e?Yt[e.$$typeof]:Kt;var t}var Zt=Object.defineProperty,Jt=Object.getOwnPropertyNames,en=Object.getOwnPropertySymbols,tn=Object.getOwnPropertyDescriptor,nn=Object.getPrototypeOf,rn=Object.prototype;function an(e,t,n){if("string"!=typeof t){if(rn){var r=nn(t);r&&r!==rn&&an(e,r,n)}var a=Jt(t);en&&(a=a.concat(en(t)));for(var o=Qt(e),i=Qt(t),s=0;s<a.length;++s){var c=a[s];if(!(c in Xt||n&&n[c]||i&&c in i||o&&c in o)){var l=tn(t,c);try{Zt(e,c,l)}catch(e){}}}}return e}function on(e){return"function"==typeof e}function sn(e){return"object"==typeof e&&"styledComponentId"in e}function cn(e,t){return e&&t?"".concat(e," ").concat(t):e||t||""}function ln(e,t){if(0===e.length)return"";for(var n=e[0],r=1;r<e.length;r++)n+=t?t+e[r]:e[r];return n}function un(e){return null!==e&&"object"==typeof e&&e.constructor.name===Object.name&&!("props"in e&&e.$$typeof)}function dn(e,t,n){if(void 0===n&&(n=!1),!n&&!un(e)&&!Array.isArray(e))return t;if(Array.isArray(t))for(var r=0;r<t.length;r++)e[r]=dn(e[r],t[r]);else if(un(t))for(var r in t)e[r]=dn(e[r],t[r]);return e}function hn(e,t){Object.defineProperty(e,"toString",{value:t})}function pn(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(e," for more information.").concat(t.length>0?" Args: ".concat(t.join(", ")):""))}var fn=function(){function e(e){this.groupSizes=new Uint32Array(512),this.length=512,this.tag=e}return e.prototype.indexOfGroup=function(e){for(var t=0,n=0;n<e;n++)t+=this.groupSizes[n];return t},e.prototype.insertRules=function(e,t){if(e>=this.groupSizes.length){for(var n=this.groupSizes,r=n.length,a=r;e>=a;)if((a<<=1)<0)throw pn(16,"".concat(e));this.groupSizes=new Uint32Array(a),this.groupSizes.set(n),this.length=a;for(var o=r;o<a;o++)this.groupSizes[o]=0}for(var i=this.indexOfGroup(e+1),s=(o=0,t.length);o<s;o++)this.tag.insertRule(i,t[o])&&(this.groupSizes[e]++,i++)},e.prototype.clearGroup=function(e){if(e<this.length){var t=this.groupSizes[e],n=this.indexOfGroup(e),r=n+t;this.groupSizes[e]=0;for(var a=n;a<r;a++)this.tag.deleteRule(n)}},e.prototype.getGroup=function(e){var t="";if(e>=this.length||0===this.groupSizes[e])return t;for(var n=this.groupSizes[e],r=this.indexOfGroup(e),a=r+n,o=r;o<a;o++)t+="".concat(this.tag.getRule(o)).concat(St);return t},e}(),gn=new Map,mn=new Map,vn=1,bn=function(e){if(gn.has(e))return gn.get(e);for(;mn.has(vn);)vn++;var t=vn++;return gn.set(e,t),mn.set(t,e),t},yn=function(e,t){vn=t+1,gn.set(e,t),mn.set(t,e)},xn="style[".concat(yt,"][").concat(wt,'="').concat(kt,'"]'),wn=new RegExp("^".concat(yt,'\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')),kn=function(e,t,n){for(var r,a=n.split(","),o=0,i=a.length;o<i;o++)(r=a[o])&&e.registerName(t,r)},Sn=function(e,t){for(var n,r=(null!==(n=t.textContent)&&void 0!==n?n:"").split(St),a=[],o=0,i=r.length;o<i;o++){var s=r[o].trim();if(s){var c=s.match(wn);if(c){var l=0|parseInt(c[1],10),u=c[2];0!==l&&(yn(u,l),kn(e,u,c[3]),e.getTag().insertRules(l,a)),a.length=0}else a.push(s)}}};function Cn(){return n.nc}var In=function(e){var t=document.head,n=e||t,r=document.createElement("style"),a=function(e){var t=Array.from(e.querySelectorAll("style[".concat(yt,"]")));return t[t.length-1]}(n),o=void 0!==a?a.nextSibling:null;r.setAttribute(yt,xt),r.setAttribute(wt,kt);var i=Cn();return i&&r.setAttribute("nonce",i),n.insertBefore(r,o),r},En=function(){function e(e){this.element=In(e),this.element.appendChild(document.createTextNode("")),this.sheet=function(e){if(e.sheet)return e.sheet;for(var t=document.styleSheets,n=0,r=t.length;n<r;n++){var a=t[n];if(a.ownerNode===e)return a}throw pn(17)}(this.element),this.length=0}return e.prototype.insertRule=function(e,t){try{return this.sheet.insertRule(t,e),this.length++,!0}catch(e){return!1}},e.prototype.deleteRule=function(e){this.sheet.deleteRule(e),this.length--},e.prototype.getRule=function(e){var t=this.sheet.cssRules[e];return t&&t.cssText?t.cssText:""},e}(),Nn=function(){function e(e){this.element=In(e),this.nodes=this.element.childNodes,this.length=0}return e.prototype.insertRule=function(e,t){if(e<=this.length&&e>=0){var n=document.createTextNode(t);return this.element.insertBefore(n,this.nodes[e]||null),this.length++,!0}return!1},e.prototype.deleteRule=function(e){this.element.removeChild(this.nodes[e]),this.length--},e.prototype.getRule=function(e){return e<this.length?this.nodes[e].textContent:""},e}(),Tn=function(){function e(e){this.rules=[],this.length=0}return e.prototype.insertRule=function(e,t){return e<=this.length&&(this.rules.splice(e,0,t),this.length++,!0)},e.prototype.deleteRule=function(e){this.rules.splice(e,1),this.length--},e.prototype.getRule=function(e){return e<this.length?this.rules[e]:""},e}(),Rn=Ct,An={isServer:!Ct,useCSSOMInjection:!It},On=function(){function e(e,t,n){void 0===e&&(e=Nt),void 0===t&&(t={});var r=this;this.options=fe(fe({},An),e),this.gs=t,this.names=new Map(n),this.server=!!e.isServer,!this.server&&Ct&&Rn&&(Rn=!1,function(e){for(var t=document.querySelectorAll(xn),n=0,r=t.length;n<r;n++){var a=t[n];a&&a.getAttribute(yt)!==xt&&(Sn(e,a),a.parentNode&&a.parentNode.removeChild(a))}}(this)),hn(this,(function(){return function(e){for(var t=e.getTag(),n=t.length,r="",a=function(n){var a=function(e){return mn.get(e)}(n);if(void 0===a)return"continue";var o=e.names.get(a),i=t.getGroup(n);if(void 0===o||0===i.length)return"continue";var s="".concat(yt,".g").concat(n,'[id="').concat(a,'"]'),c="";void 0!==o&&o.forEach((function(e){e.length>0&&(c+="".concat(e,","))})),r+="".concat(i).concat(s,'{content:"').concat(c,'"}').concat(St)},o=0;o<n;o++)a(o);return r}(r)}))}return e.registerId=function(e){return bn(e)},e.prototype.reconstructWithOptions=function(t,n){return void 0===n&&(n=!0),new e(fe(fe({},this.options),t),this.gs,n&&this.names||void 0)},e.prototype.allocateGSInstance=function(e){return this.gs[e]=(this.gs[e]||0)+1},e.prototype.getTag=function(){return this.tag||(this.tag=(e=function(e){var t=e.useCSSOMInjection,n=e.target;return e.isServer?new Tn(n):t?new En(n):new Nn(n)}(this.options),new fn(e)));var e},e.prototype.hasNameForId=function(e,t){return this.names.has(e)&&this.names.get(e).has(t)},e.prototype.registerName=function(e,t){if(bn(e),this.names.has(e))this.names.get(e).add(t);else{var n=new Set;n.add(t),this.names.set(e,n)}},e.prototype.insertRules=function(e,t,n){this.registerName(e,t),this.getTag().insertRules(bn(e),n)},e.prototype.clearNames=function(e){this.names.has(e)&&this.names.get(e).clear()},e.prototype.clearRules=function(e){this.getTag().clearGroup(bn(e)),this.clearNames(e)},e.prototype.clearTag=function(){this.tag=void 0},e}(),Fn=/&/g,_n=/^\s*\/\/.*$/gm;function Dn(e,t){return e.map((function(e){return"rule"===e.type&&(e.value="".concat(t," ").concat(e.value),e.value=e.value.replaceAll(",",",".concat(t," ")),e.props=e.props.map((function(e){return"".concat(t," ").concat(e)}))),Array.isArray(e.children)&&"@keyframes"!==e.type&&(e.children=Dn(e.children,t)),e}))}function Mn(e){var t,n,r,a=void 0===e?Nt:e,o=a.options,i=void 0===o?Nt:o,s=a.plugins,c=void 0===s?Et:s,l=function(e,r,a){return a.startsWith(n)&&a.endsWith(n)&&a.replaceAll(n,"").length>0?".".concat(t):e},u=c.slice();u.push((function(e){e.type===ke&&e.value.includes("&")&&(e.props[0]=e.props[0].replace(Fn,n).replace(r,l))})),i.prefix&&u.push(ht),u.push(ut);var d=function(e,a,o,s){void 0===a&&(a=""),void 0===o&&(o=""),void 0===s&&(s="&"),t=s,n=a,r=new RegExp("\\".concat(n,"\\b"),"g");var c=e.replace(_n,""),l=pt(o||a?"".concat(o," ").concat(a," { ").concat(c," }"):c);i.namespace&&(l=Dn(l,i.namespace));var d,h=[];return lt(l,function(e){var t=Le(e);return function(n,r,a,o){for(var i="",s=0;s<t;s++)i+=e[s](n,r,a,o)||"";return i}}(u.concat((d=function(e){return h.push(e)},function(e){e.root||(e=e.return)&&d(e)})))),h};return d.hash=c.length?c.reduce((function(e,t){return t.name||pn(15),Bt(e,t.name)}),zt).toString():"",d}var Pn=new On,Ln=Mn(),zn=o.createContext({shouldForwardProp:void 0,styleSheet:Pn,stylis:Ln}),Bn=(zn.Consumer,o.createContext(void 0));function Wn(){return(0,o.useContext)(zn)}function Un(e){var t=(0,o.useState)(e.stylisPlugins),n=t[0],r=t[1],a=Wn().styleSheet,i=(0,o.useMemo)((function(){var t=a;return e.sheet?t=e.sheet:e.target&&(t=t.reconstructWithOptions({target:e.target},!1)),e.disableCSSOMInjection&&(t=t.reconstructWithOptions({useCSSOMInjection:!1})),t}),[e.disableCSSOMInjection,e.sheet,e.target,a]),s=(0,o.useMemo)((function(){return Mn({options:{namespace:e.namespace,prefix:e.enableVendorPrefixes},plugins:n})}),[e.enableVendorPrefixes,e.namespace,n]);(0,o.useEffect)((function(){ve()(n,e.stylisPlugins)||r(e.stylisPlugins)}),[e.stylisPlugins]);var c=(0,o.useMemo)((function(){return{shouldForwardProp:e.shouldForwardProp,styleSheet:i,stylis:s}}),[e.shouldForwardProp,i,s]);return o.createElement(zn.Provider,{value:c},o.createElement(Bn.Provider,{value:s},e.children))}var Vn=function(){function e(e,t){var n=this;this.inject=function(e,t){void 0===t&&(t=Ln);var r=n.name+t.hash;e.hasNameForId(n.id,r)||e.insertRules(n.id,r,t(n.rules,r,"@keyframes"))},this.name=e,this.id="sc-keyframes-".concat(e),this.rules=t,hn(this,(function(){throw pn(12,String(n.name))}))}return e.prototype.getName=function(e){return void 0===e&&(e=Ln),this.name+e.hash},e}(),jn=function(e){return e>="A"&&e<="Z"};function Hn(e){for(var t="",n=0;n<e.length;n++){var r=e[n];if(1===n&&"-"===r&&"-"===e[0])return e;jn(r)?t+="-"+r.toLowerCase():t+=r}return t.startsWith("ms-")?"-"+t:t}var Gn=function(e){return null==e||!1===e||""===e},qn=function(e){var t,n,r=[];for(var a in e){var o=e[a];e.hasOwnProperty(a)&&!Gn(o)&&(Array.isArray(o)&&o.isCss||on(o)?r.push("".concat(Hn(a),":"),o,";"):un(o)?r.push.apply(r,ge(ge(["".concat(a," {")],qn(o),!1),["}"],!1)):r.push("".concat(Hn(a),": ").concat((t=a,null==(n=o)||"boolean"==typeof n||""===n?"":"number"!=typeof n||0===n||t in bt||t.startsWith("--")?String(n).trim():"".concat(n,"px")),";")))}return r};function Kn(e,t,n,r){return Gn(e)?[]:sn(e)?[".".concat(e.styledComponentId)]:on(e)?!on(a=e)||a.prototype&&a.prototype.isReactComponent||!t?[e]:Kn(e(t),t,n,r):e instanceof Vn?n?(e.inject(n,r),[e.getName(r)]):[e]:un(e)?qn(e):Array.isArray(e)?Array.prototype.concat.apply(Et,e.map((function(e){return Kn(e,t,n,r)}))):[e.toString()];var a}function Xn(e){for(var t=0;t<e.length;t+=1){var n=e[t];if(on(n)&&!sn(n))return!1}return!0}var $n=Wt(kt),Yn=function(){function e(e,t,n){this.rules=e,this.staticRulesId="",this.isStatic=(void 0===n||n.isStatic)&&Xn(e),this.componentId=t,this.baseHash=Bt($n,t),this.baseStyle=n,On.registerId(t)}return e.prototype.generateAndInjectStyles=function(e,t,n){var r=this.baseStyle?this.baseStyle.generateAndInjectStyles(e,t,n):"";if(this.isStatic&&!n.hash)if(this.staticRulesId&&t.hasNameForId(this.componentId,this.staticRulesId))r=cn(r,this.staticRulesId);else{var a=ln(Kn(this.rules,e,t,n)),o=Pt(Bt(this.baseHash,a)>>>0);if(!t.hasNameForId(this.componentId,o)){var i=n(a,".".concat(o),void 0,this.componentId);t.insertRules(this.componentId,o,i)}r=cn(r,o),this.staticRulesId=o}else{for(var s=Bt(this.baseHash,n.hash),c="",l=0;l<this.rules.length;l++){var u=this.rules[l];if("string"==typeof u)c+=u;else if(u){var d=ln(Kn(u,e,t,n));s=Bt(s,d+l),c+=d}}if(c){var h=Pt(s>>>0);t.hasNameForId(this.componentId,h)||t.insertRules(this.componentId,h,n(c,".".concat(h),void 0,this.componentId)),r=cn(r,h)}}return r},e}(),Qn=o.createContext(void 0);Qn.Consumer;function Zn(e){var t=o.useContext(Qn),n=(0,o.useMemo)((function(){return function(e,t){if(!e)throw pn(14);if(on(e))return e(t);if(Array.isArray(e)||"object"!=typeof e)throw pn(8);return t?fe(fe({},t),e):e}(e.theme,t)}),[e.theme,t]);return e.children?o.createElement(Qn.Provider,{value:n},e.children):null}var Jn={};new Set;function er(e,t,n){var r=sn(e),a=e,i=!jt(e),s=t.attrs,c=void 0===s?Et:s,l=t.componentId,u=void 0===l?function(e,t){var n="string"!=typeof e?"sc":Ft(e);Jn[n]=(Jn[n]||0)+1;var r="".concat(n,"-").concat(Ut(kt+n+Jn[n]));return t?"".concat(t,"-").concat(r):r}(t.displayName,t.parentComponentId):l,d=t.displayName,h=void 0===d?function(e){return jt(e)?"styled.".concat(e):"Styled(".concat(Vt(e),")")}(e):d,p=t.displayName&&t.componentId?"".concat(Ft(t.displayName),"-").concat(t.componentId):t.componentId||u,f=r&&a.attrs?a.attrs.concat(c).filter(Boolean):c,g=t.shouldForwardProp;if(r&&a.shouldForwardProp){var m=a.shouldForwardProp;if(t.shouldForwardProp){var v=t.shouldForwardProp;g=function(e,t){return m(e,t)&&v(e,t)}}else g=m}var b=new Yn(n,p,r?a.componentStyle:void 0);function y(e,t){return function(e,t,n){var r=e.attrs,a=e.componentStyle,i=e.defaultProps,s=e.foldedComponentIds,c=e.styledComponentId,l=e.target,u=o.useContext(Qn),d=Wn(),h=e.shouldForwardProp||d.shouldForwardProp,p=Tt(t,u,i)||Nt,f=function(e,t,n){for(var r,a=fe(fe({},t),{className:void 0,theme:n}),o=0;o<e.length;o+=1){var i=on(r=e[o])?r(a):r;for(var s in i)a[s]="className"===s?cn(a[s],i[s]):"style"===s?fe(fe({},a[s]),i[s]):i[s]}return t.className&&(a.className=cn(a.className,t.className)),a}(r,t,p),g=f.as||l,m={};for(var v in f)void 0===f[v]||"$"===v[0]||"as"===v||"theme"===v&&f.theme===p||("forwardedAs"===v?m.as=f.forwardedAs:h&&!h(v,g)||(m[v]=f[v]));var b=function(e,t){var n=Wn();return e.generateAndInjectStyles(t,n.styleSheet,n.stylis)}(a,f),y=cn(s,c);return b&&(y+=" "+b),f.className&&(y+=" "+f.className),m[jt(g)&&!Rt.has(g)?"class":"className"]=y,m.ref=n,(0,o.createElement)(g,m)}(x,e,t)}y.displayName=h;var x=o.forwardRef(y);return x.attrs=f,x.componentStyle=b,x.displayName=h,x.shouldForwardProp=g,x.foldedComponentIds=r?cn(a.foldedComponentIds,a.styledComponentId):"",x.styledComponentId=p,x.target=r?a.target:e,Object.defineProperty(x,"defaultProps",{get:function(){return this._foldedDefaultProps},set:function(e){this._foldedDefaultProps=r?function(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];for(var r=0,a=t;r<a.length;r++)dn(e,a[r],!0);return e}({},a.defaultProps,e):e}}),hn(x,(function(){return".".concat(x.styledComponentId)})),i&&an(x,e,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,shouldForwardProp:!0,styledComponentId:!0,target:!0}),x}function tr(e,t){for(var n=[e[0]],r=0,a=t.length;r<a;r+=1)n.push(t[r],e[r+1]);return n}var nr=function(e){return Object.assign(e,{isCss:!0})};function rr(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];if(on(e)||un(e))return nr(Kn(tr(Et,ge([e],t,!0))));var r=e;return 0===t.length&&1===r.length&&"string"==typeof r[0]?Kn(r):nr(Kn(tr(r,t)))}function ar(e,t,n){if(void 0===n&&(n=Nt),!t)throw pn(1,t);var r=function(r){for(var a=[],o=1;o<arguments.length;o++)a[o-1]=arguments[o];return e(t,n,rr.apply(void 0,ge([r],a,!1)))};return r.attrs=function(r){return ar(e,t,fe(fe({},n),{attrs:Array.prototype.concat(n.attrs,r).filter(Boolean)}))},r.withConfig=function(r){return ar(e,t,fe(fe({},n),r))},r}var or=function(e){return ar(er,e)},ir=or;Rt.forEach((function(e){ir[e]=or(e)}));!function(){function e(e,t){this.rules=e,this.componentId=t,this.isStatic=Xn(e),On.registerId(this.componentId+1)}e.prototype.createStyles=function(e,t,n,r){var a=r(ln(Kn(this.rules,t,n,r)),""),o=this.componentId+e;n.insertRules(o,o,a)},e.prototype.removeStyles=function(e,t){t.clearRules(this.componentId+e)},e.prototype.renderStyles=function(e,t,n,r){e>2&&On.registerId(this.componentId+e),this.removeStyles(e,n),this.createStyles(e,t,n,r)}}();(function(){function e(){var e=this;this._emitSheetCSS=function(){var t=e.instance.toString(),n=Cn(),r=ln([n&&'nonce="'.concat(n,'"'),"".concat(yt,'="true"'),"".concat(wt,'="').concat(kt,'"')].filter(Boolean)," ");return"<style ".concat(r,">").concat(t,"</style>")},this.getStyleTags=function(){if(e.sealed)throw pn(2);return e._emitSheetCSS()},this.getStyleElement=function(){var t;if(e.sealed)throw pn(2);var n=((t={})[yt]="",t[wt]=kt,t.dangerouslySetInnerHTML={__html:e.instance.toString()},t),r=Cn();return r&&(n.nonce=r),[o.createElement("style",fe({},n,{key:"sc-0-0"}))]},this.seal=function(){e.sealed=!0},this.instance=new On({isServer:!0}),this.sealed=!1}e.prototype.collectStyles=function(e){if(this.sealed)throw pn(2);return o.createElement(Un,{sheet:this.instance},e)},e.prototype.interleaveWithNodeStream=function(e){throw pn(3)}})(),"__sc-".concat(yt,"__");var sr=n(139),cr=n.n(sr);function lr(e){return lr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},lr(e)}function ur(e){var t=function(e,t){if("object"!=lr(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var r=n.call(e,t||"default");if("object"!=lr(r))return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==lr(t)?t:t+""}function dr(e,t,n){return(t=ur(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function hr(e){if(Array.isArray(e))return e}function pr(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=Array(t);n<t;n++)r[n]=e[n];return r}function fr(e,t){if(e){if("string"==typeof e)return pr(e,t);var n={}.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?pr(e,t):void 0}}function gr(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function mr(e,t){return hr(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=n){var r,a,o,i,s=[],c=!0,l=!1;try{if(o=(n=n.call(e)).next,0===t){if(Object(n)!==n)return;c=!1}else for(;!(c=(r=o.call(n)).done)&&(s.push(r.value),s.length!==t);c=!0);}catch(e){l=!0,a=e}finally{try{if(!c&&null!=n.return&&(i=n.return(),Object(i)!==i))return}finally{if(l)throw a}}return s}}(e,t)||fr(e,t)||gr()}function vr(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}function br(e){return function(e){if(Array.isArray(e))return pr(e)}(e)||vr(e)||fr(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function yr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function xr(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?yr(Object(n),!0).forEach((function(t){dr(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):yr(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}const wr=function(e){for(var t,n=0,r=0,a=e.length;a>=4;++r,a-=4)t=1540483477*(65535&(t=255&e.charCodeAt(r)|(255&e.charCodeAt(++r))<<8|(255&e.charCodeAt(++r))<<16|(255&e.charCodeAt(++r))<<24))+(59797*(t>>>16)<<16),n=1540483477*(65535&(t^=t>>>24))+(59797*(t>>>16)<<16)^1540483477*(65535&n)+(59797*(n>>>16)<<16);switch(a){case 3:n^=(255&e.charCodeAt(r+2))<<16;case 2:n^=(255&e.charCodeAt(r+1))<<8;case 1:n=1540483477*(65535&(n^=255&e.charCodeAt(r)))+(59797*(n>>>16)<<16)}return(((n=1540483477*(65535&(n^=n>>>13))+(59797*(n>>>16)<<16))^n>>>15)>>>0).toString(36)};function kr(){return!("undefined"===typeof window||!window.document||!window.document.createElement)}var Sr="data-rc-order",Cr="data-rc-priority",Ir="rc-util-key",Er=new Map;function Nr(){var e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}).mark;return e?e.startsWith("data-")?e:"data-".concat(e):Ir}function Tr(e){return e.attachTo?e.attachTo:document.querySelector("head")||document.body}function Rr(e){return Array.from((Er.get(e)||e).children).filter((function(e){return"STYLE"===e.tagName}))}function Ar(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!kr())return null;var n=t.csp,r=t.prepend,a=t.priority,o=void 0===a?0:a,i=function(e){return"queue"===e?"prependQueue":e?"prepend":"append"}(r),s="prependQueue"===i,c=document.createElement("style");c.setAttribute(Sr,i),s&&o&&c.setAttribute(Cr,"".concat(o)),null!==n&&void 0!==n&&n.nonce&&(c.nonce=null===n||void 0===n?void 0:n.nonce),c.innerHTML=e;var l=Tr(t),u=l.firstChild;if(r){if(s){var d=(t.styles||Rr(l)).filter((function(e){if(!["prepend","prependQueue"].includes(e.getAttribute(Sr)))return!1;var t=Number(e.getAttribute(Cr)||0);return o>=t}));if(d.length)return l.insertBefore(c,d[d.length-1].nextSibling),c}l.insertBefore(c,u)}else l.appendChild(c);return c}function Or(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=Tr(t);return(t.styles||Rr(n)).find((function(n){return n.getAttribute(Nr(t))===e}))}function Fr(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=Or(e,t);n&&Tr(t).removeChild(n)}function _r(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=Tr(n),a=Rr(r),o=xr(xr({},n),{},{styles:a});!function(e,t){var n=Er.get(e);if(!n||!function(e,t){if(!e)return!1;if(e.contains)return e.contains(t);for(var n=t;n;){if(n===e)return!0;n=n.parentNode}return!1}(document,n)){var r=Ar("",t),a=r.parentNode;Er.set(e,a),e.removeChild(r)}}(r,o);var i=Or(t,o);if(i){var s,c,l;if(null!==(s=o.csp)&&void 0!==s&&s.nonce&&i.nonce!==(null===(c=o.csp)||void 0===c?void 0:c.nonce))i.nonce=null===(l=o.csp)||void 0===l?void 0:l.nonce;return i.innerHTML!==e&&(i.innerHTML=e),i}var u=Ar(e,o);return u.setAttribute(Nr(o),t),u}function Dr(e,t,n){var r=o.useRef({});return"value"in r.current&&!n(r.current.condition,t)||(r.current.value=e(),r.current.condition=t),r.current.value}var Mr={},Pr=[];function Lr(e,t){}function zr(e,t){}function Br(e,t,n){t||Mr[n]||(e(!1,n),Mr[n]=!0)}function Wr(e,t){Br(Lr,e,t)}Wr.preMessage=function(e){Pr.push(e)},Wr.resetWarned=function(){Mr={}},Wr.noteOnce=function(e,t){Br(zr,e,t)};const Ur=Wr;const Vr=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=new Set;return function e(t,a){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=r.has(t);if(Ur(!i,"Warning: There may be circular references"),i)return!1;if(t===a)return!0;if(n&&o>1)return!1;r.add(t);var s=o+1;if(Array.isArray(t)){if(!Array.isArray(a)||t.length!==a.length)return!1;for(var c=0;c<t.length;c++)if(!e(t[c],a[c],s))return!1;return!0}if(t&&a&&"object"===lr(t)&&"object"===lr(a)){var l=Object.keys(t);return l.length===Object.keys(a).length&&l.every((function(n){return e(t[n],a[n],s)}))}return!1}(e,t)};function jr(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function Hr(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,ur(r.key),r)}}function Gr(e,t,n){return t&&Hr(e.prototype,t),n&&Hr(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e}var qr="%";function Kr(e){return e.join(qr)}var Xr=function(){function e(t){jr(this,e),dr(this,"instanceId",void 0),dr(this,"cache",new Map),this.instanceId=t}return Gr(e,[{key:"get",value:function(e){return this.opGet(Kr(e))}},{key:"opGet",value:function(e){return this.cache.get(e)||null}},{key:"update",value:function(e,t){return this.opUpdate(Kr(e),t)}},{key:"opUpdate",value:function(e,t){var n=t(this.cache.get(e));null===n?this.cache.delete(e):this.cache.set(e,n)}}]),e}();const $r=Xr;var Yr="data-token-hash",Qr="data-css-hash",Zr="__cssinjs_instance__";function Jr(){var e=Math.random().toString(12).slice(2);if("undefined"!==typeof document&&document.head&&document.body){var t=document.body.querySelectorAll("style[".concat(Qr,"]"))||[],n=document.head.firstChild;Array.from(t).forEach((function(t){t[Zr]=t[Zr]||e,t[Zr]===e&&document.head.insertBefore(t,n)}));var r={};Array.from(document.querySelectorAll("style[".concat(Qr,"]"))).forEach((function(t){var n,a=t.getAttribute(Qr);r[a]?t[Zr]===e&&(null===(n=t.parentNode)||void 0===n||n.removeChild(t)):r[a]=!0}))}return new $r(e)}var ea=o.createContext({hashPriority:"low",cache:Jr(),defaultCache:!0});const ta=ea;var na=function(){function e(){jr(this,e),dr(this,"cache",void 0),dr(this,"keys",void 0),dr(this,"cacheCallTimes",void 0),this.cache=new Map,this.keys=[],this.cacheCallTimes=0}return Gr(e,[{key:"size",value:function(){return this.keys.length}},{key:"internalGet",value:function(e){var t,n,r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a={map:this.cache};return e.forEach((function(e){var t;a?a=null===(t=a)||void 0===t||null===(t=t.map)||void 0===t?void 0:t.get(e):a=void 0})),null!==(t=a)&&void 0!==t&&t.value&&r&&(a.value[1]=this.cacheCallTimes++),null===(n=a)||void 0===n?void 0:n.value}},{key:"get",value:function(e){var t;return null===(t=this.internalGet(e,!0))||void 0===t?void 0:t[0]}},{key:"has",value:function(e){return!!this.internalGet(e)}},{key:"set",value:function(t,n){var r=this;if(!this.has(t)){if(this.size()+1>e.MAX_CACHE_SIZE+e.MAX_CACHE_OFFSET){var a=this.keys.reduce((function(e,t){var n=mr(e,2)[1];return r.internalGet(t)[1]<n?[t,r.internalGet(t)[1]]:e}),[this.keys[0],this.cacheCallTimes]),o=mr(a,1)[0];this.delete(o)}this.keys.push(t)}var i=this.cache;t.forEach((function(e,a){if(a===t.length-1)i.set(e,{value:[n,r.cacheCallTimes++]});else{var o=i.get(e);o?o.map||(o.map=new Map):i.set(e,{map:new Map}),i=i.get(e).map}}))}},{key:"deleteByPath",value:function(e,t){var n,r=e.get(t[0]);if(1===t.length)return r.map?e.set(t[0],{map:r.map}):e.delete(t[0]),null===(n=r.value)||void 0===n?void 0:n[0];var a=this.deleteByPath(r.map,t.slice(1));return r.map&&0!==r.map.size||r.value||e.delete(t[0]),a}},{key:"delete",value:function(e){if(this.has(e))return this.keys=this.keys.filter((function(t){return!function(e,t){if(e.length!==t.length)return!1;for(var n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}(t,e)})),this.deleteByPath(this.cache,e)}}]),e}();dr(na,"MAX_CACHE_SIZE",20),dr(na,"MAX_CACHE_OFFSET",5);var ra=0,aa=function(){function e(t){jr(this,e),dr(this,"derivatives",void 0),dr(this,"id",void 0),this.derivatives=Array.isArray(t)?t:[t],this.id=ra,0===t.length&&t.length,ra+=1}return Gr(e,[{key:"getDerivativeToken",value:function(e){return this.derivatives.reduce((function(t,n){return n(e,t)}),void 0)}}]),e}(),oa=new na;function ia(e){var t=Array.isArray(e)?e:[e];return oa.has(t)||oa.set(t,new aa(t)),oa.get(t)}var sa=new WeakMap,ca={};var la=new WeakMap;function ua(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=la.get(e)||"";return n||(Object.keys(e).forEach((function(r){var a=e[r];n+=r,a instanceof aa?n+=a.id:a&&"object"===lr(a)?n+=ua(a,t):n+=a})),t&&(n=wr(n)),la.set(e,n)),n}function da(e,t){return wr("".concat(t,"_").concat(ua(e,!0)))}"random-".concat(Date.now(),"-").concat(Math.random()).replace(/\./g,"");var ha=kr();function pa(e){return"number"===typeof e?"".concat(e,"px"):e}function fa(e,t,n){var r;if(arguments.length>4&&void 0!==arguments[4]&&arguments[4])return e;var a=xr(xr({},arguments.length>3&&void 0!==arguments[3]?arguments[3]:{}),{},(dr(r={},Yr,t),dr(r,Qr,n),r)),o=Object.keys(a).map((function(e){var t=a[e];return t?"".concat(e,'="').concat(t,'"'):null})).filter((function(e){return e})).join(" ");return"<style ".concat(o,">").concat(e,"</style>")}var ga=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return"--".concat(t?"".concat(t,"-"):"").concat(e).replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g,"$1-$2").replace(/([a-z])([A-Z0-9])/g,"$1-$2").toLowerCase()},ma=function(e,t,n){return Object.keys(e).length?".".concat(t).concat(null!==n&&void 0!==n&&n.scope?".".concat(n.scope):"","{").concat(Object.entries(e).map((function(e){var t=mr(e,2),n=t[0],r=t[1];return"".concat(n,":").concat(r,";")})).join(""),"}"):""},va=function(e,t,n){var r={},a={};return Object.entries(e).forEach((function(e){var t,o,i=mr(e,2),s=i[0],c=i[1];if(null!==n&&void 0!==n&&null!==(t=n.preserve)&&void 0!==t&&t[s])a[s]=c;else if(("string"===typeof c||"number"===typeof c)&&(null===n||void 0===n||null===(o=n.ignore)||void 0===o||!o[s])){var l,u=ga(s,null===n||void 0===n?void 0:n.prefix);r[u]="number"!==typeof c||null!==n&&void 0!==n&&null!==(l=n.unitless)&&void 0!==l&&l[s]?String(c):"".concat(c,"px"),a[s]="var(".concat(u,")")}})),[a,ma(r,t,{scope:null===n||void 0===n?void 0:n.scope})]},ba=kr()?o.useLayoutEffect:o.useEffect,ya=function(e,t){var n=o.useRef(!0);ba((function(){return e(n.current)}),t),ba((function(){return n.current=!1,function(){n.current=!0}}),[])},xa=function(e,t){ya((function(t){if(!t)return e()}),t)};const wa=ya;var ka=xr({},i).useInsertionEffect;const Sa=ka?function(e,t,n){return ka((function(){return e(),t()}),n)}:function(e,t,n){o.useMemo(e,n),wa((function(){return t(!0)}),n)};var Ca="undefined"!==typeof xr({},i).useInsertionEffect?function(e){var t=[],n=!1;return o.useEffect((function(){return n=!1,function(){n=!0,t.length&&t.forEach((function(e){return e()}))}}),e),function(e){n||t.push(e)}}:function(){return function(e){e()}};const Ia=Ca;const Ea=function(){return!1};function Na(e,t,n,r,a){var i=o.useContext(ta).cache,s=Kr([e].concat(br(t))),c=Ia([s]),l=(Ea(),function(e){i.opUpdate(s,(function(t){var r=mr(t||[void 0,void 0],2),a=r[0];var o=[void 0===a?0:a,r[1]||n()];return e?e(o):o}))});o.useMemo((function(){l()}),[s]);var u=i.opGet(s)[1];return Sa((function(){null===a||void 0===a||a(u)}),(function(e){return l((function(t){var n=mr(t,2),r=n[0],o=n[1];return e&&0===r&&(null===a||void 0===a||a(u)),[r+1,o]})),function(){i.opUpdate(s,(function(t){var n=mr(t||[],2),a=n[0],o=void 0===a?0:a,l=n[1];return 0===o-1?(c((function(){!e&&i.opGet(s)||null===r||void 0===r||r(l,!1)})),null):[o-1,l]}))}}),[s]),u}var Ta={},Ra="css",Aa=new Map;var Oa=0;function Fa(e,t){Aa.set(e,(Aa.get(e)||0)-1);var n=Array.from(Aa.keys()),r=n.filter((function(e){return(Aa.get(e)||0)<=0}));n.length-r.length>Oa&&r.forEach((function(e){!function(e,t){"undefined"!==typeof document&&document.querySelectorAll("style[".concat(Yr,'="').concat(e,'"]')).forEach((function(e){var n;e[Zr]===t&&(null===(n=e.parentNode)||void 0===n||n.removeChild(e))}))}(e,t),Aa.delete(e)}))}var _a=function(e,t,n,r){var a=xr(xr({},n.getDerivativeToken(e)),t);return r&&(a=r(a)),a},Da="token";function Ma(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=(0,o.useContext)(ta),a=r.cache.instanceId,i=r.container,s=n.salt,c=void 0===s?"":s,l=n.override,u=void 0===l?Ta:l,d=n.formatToken,h=n.getComputedToken,p=n.cssVar,f=function(e,t){for(var n=sa,r=0;r<t.length;r+=1){var a=t[r];n.has(a)||n.set(a,new WeakMap),n=n.get(a)}return n.has(ca)||n.set(ca,e()),n.get(ca)}((function(){return Object.assign.apply(Object,[{}].concat(br(t)))}),t),g=ua(f),m=ua(u),v=p?ua(p):"",b=Na(Da,[c,e.id,g,m,v],(function(){var t,n=h?h(f,u,e):_a(f,u,e,d),r=xr({},n),a="";if(p){var o=mr(va(n,p.key,{prefix:p.prefix,ignore:p.ignore,unitless:p.unitless,preserve:p.preserve}),2);n=o[0],a=o[1]}var i=da(n,c);n._tokenKey=i,r._tokenKey=da(r,c);var s=null!==(t=null===p||void 0===p?void 0:p.key)&&void 0!==t?t:i;n._themeKey=s,function(e){Aa.set(e,(Aa.get(e)||0)+1)}(s);var l="".concat(Ra,"-").concat(wr(i));return n._hashId=l,[n,l,r,a,(null===p||void 0===p?void 0:p.key)||""]}),(function(e){Fa(e[0]._themeKey,a)}),(function(e){var t=mr(e,4),n=t[0],r=t[3];if(p&&r){var o=_r(r,wr("css-variables-".concat(n._themeKey)),{mark:Qr,prepend:"queue",attachTo:i,priority:-999});o[Zr]=a,o.setAttribute(Yr,n._themeKey)}}));return b}function Pa(){return Pa=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Pa.apply(null,arguments)}const La={animationIterationCount:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1};var za,Ba="data-ant-cssinjs-cache-path",Wa="_FILE_STYLE__";var Ua=!0;function Va(e){return function(){if(!za&&(za={},kr())){var e=document.createElement("div");e.className=Ba,e.style.position="fixed",e.style.visibility="hidden",e.style.top="-9999px",document.body.appendChild(e);var t=getComputedStyle(e).content||"";(t=t.replace(/^"/,"").replace(/"$/,"")).split(";").forEach((function(e){var t=mr(e.split(":"),2),n=t[0],r=t[1];za[n]=r}));var n,r=document.querySelector("style[".concat(Ba,"]"));r&&(Ua=!1,null===(n=r.parentNode)||void 0===n||n.removeChild(r)),document.body.removeChild(e)}}(),!!za[e]}var ja="_multi_value_";function Ha(e){return lt(pt(e),ut).replace(/\{%%%\:[^;];}/g,";")}var Ga=function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{root:!0,parentSelectors:[]},a=r.root,o=r.injectHash,i=r.parentSelectors,s=n.hashId,c=n.layer,l=(n.path,n.hashPriority),u=n.transformers,d=void 0===u?[]:u,h=(n.linters,""),p={};function f(t){var r=t.getName(s);if(!p[r]){var a=mr(e(t.style,n,{root:!1,parentSelectors:i}),1)[0];p[r]="@keyframes ".concat(t.getName(s)).concat(a)}}var g=function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t.forEach((function(t){Array.isArray(t)?e(t,n):t&&n.push(t)})),n}(Array.isArray(t)?t:[t]);return g.forEach((function(t){var r="string"!==typeof t||a?t:{};if("string"===typeof r)h+="".concat(r,"\n");else if(r._keyframe)f(r);else{var c=d.reduce((function(e,t){var n;return(null===t||void 0===t||null===(n=t.visit)||void 0===n?void 0:n.call(t,e))||e}),r);Object.keys(c).forEach((function(t){var r=c[t];if("object"!==lr(r)||!r||"animationName"===t&&r._keyframe||function(e){return"object"===lr(e)&&e&&("_skip_check_"in e||ja in e)}(r)){var u;function w(e,t){var n=e.replace(/[A-Z]/g,(function(e){return"-".concat(e.toLowerCase())})),r=t;La[e]||"number"!==typeof r||0===r||(r="".concat(r,"px")),"animationName"===e&&null!==t&&void 0!==t&&t._keyframe&&(f(t),r=t.getName(s)),h+="".concat(n,":").concat(r,";")}var d=null!==(u=null===r||void 0===r?void 0:r.value)&&void 0!==u?u:r;"object"===lr(r)&&null!==r&&void 0!==r&&r[ja]&&Array.isArray(d)?d.forEach((function(e){w(t,e)})):w(t,d)}else{var g=!1,m=t.trim(),v=!1;(a||o)&&s?m.startsWith("@")?g=!0:m=function(e,t,n){if(!t)return e;var r=".".concat(t),a="low"===n?":where(".concat(r,")"):r,o=e.split(",").map((function(e){var t,n=e.trim().split(/\s+/),r=n[0]||"",o=(null===(t=r.match(/^\w+/))||void 0===t?void 0:t[0])||"";return[r="".concat(o).concat(a).concat(r.slice(o.length))].concat(br(n.slice(1))).join(" ")}));return o.join(",")}(t,s,l):!a||s||"&"!==m&&""!==m||(m="",v=!0);var b=mr(e(r,n,{root:v,injectHash:g,parentSelectors:[].concat(br(i),[m])}),2),y=b[0],x=b[1];p=xr(xr({},p),x),h+="".concat(m).concat(y)}}))}})),a?c&&(h="@layer ".concat(c.name," {").concat(h,"}"),c.dependencies&&(p["@layer ".concat(c.name)]=c.dependencies.map((function(e){return"@layer ".concat(e,", ").concat(c.name,";")})).join("\n"))):h="{".concat(h,"}"),[h,p]};function qa(e,t){return wr("".concat(e.join("%")).concat(t))}function Ka(){return null}var Xa="style";function $a(e,t){var n=e.token,r=e.path,a=e.hashId,i=e.layer,s=e.nonce,c=e.clientOnly,l=e.order,u=void 0===l?0:l,d=o.useContext(ta),h=d.autoClear,p=(d.mock,d.defaultCache),f=d.hashPriority,g=d.container,m=d.ssrInline,v=d.transformers,b=d.linters,y=d.cache,x=d.layer,w=n._tokenKey,k=[w];x&&k.push("layer"),k.push.apply(k,br(r));var S=ha;var C=Na(Xa,k,(function(){var e=k.join("|");if(Va(e)){var n=function(e){var t=za[e],n=null;if(t&&kr())if(Ua)n=Wa;else{var r=document.querySelector("style[".concat(Qr,'="').concat(za[e],'"]'));r?n=r.innerHTML:delete za[e]}return[n,t]}(e),o=mr(n,2),s=o[0],l=o[1];if(s)return[s,w,l,{},c,u]}var d=t(),h=mr(Ga(d,{hashId:a,hashPriority:f,layer:x?i:void 0,path:r.join("-"),transformers:v,linters:b}),2),p=h[0],g=h[1],m=Ha(p),y=qa(k,m);return[m,w,y,g,c,u]}),(function(e,t){var n=mr(e,3)[2];(t||h)&&ha&&Fr(n,{mark:Qr})}),(function(e){var t=mr(e,4),n=t[0],r=(t[1],t[2]),a=t[3];if(S&&n!==Wa){var o={mark:Qr,prepend:!x&&"queue",attachTo:g,priority:u},i="function"===typeof s?s():s;i&&(o.csp={nonce:i});var c=[],l=[];Object.keys(a).forEach((function(e){e.startsWith("@layer")?c.push(e):l.push(e)})),c.forEach((function(e){_r(Ha(a[e]),"_layer-".concat(e),xr(xr({},o),{},{prepend:!0}))}));var d=_r(n,r,o);d[Zr]=y.instanceId,d.setAttribute(Yr,w),l.forEach((function(e){_r(Ha(a[e]),"_effect-".concat(e),o)}))}})),I=mr(C,3),E=I[0],N=I[1],T=I[2];return function(e){var t,n;m&&!S&&p?t=o.createElement("style",Pa({},(dr(n={},Yr,N),dr(n,Qr,T),n),{dangerouslySetInnerHTML:{__html:E}})):t=o.createElement(Ka,null);return o.createElement(o.Fragment,null,t,e)}}var Ya="cssVar";const Qa=function(e,t){var n=e.key,r=e.prefix,a=e.unitless,i=e.ignore,s=e.token,c=e.scope,l=void 0===c?"":c,u=(0,o.useContext)(ta),d=u.cache.instanceId,h=u.container,p=s._tokenKey,f=[].concat(br(e.path),[n,l,p]),g=Na(Ya,f,(function(){var e=t(),o=mr(va(e,n,{prefix:r,unitless:a,ignore:i,scope:l}),2),s=o[0],c=o[1];return[s,c,qa(f,c),n]}),(function(e){var t=mr(e,3)[2];ha&&Fr(t,{mark:Qr})}),(function(e){var t=mr(e,3),r=t[1],a=t[2];if(r){var o=_r(r,a,{mark:Qr,prepend:"queue",attachTo:h,priority:-999});o[Zr]=d,o.setAttribute(Yr,n)}}));return g};var Za;dr(Za={},Xa,(function(e,t,n){var r=mr(e,6),a=r[0],o=r[1],i=r[2],s=r[3],c=r[4],l=r[5],u=(n||{}).plain;if(c)return null;var d=a,h={"data-rc-order":"prependQueue","data-rc-priority":"".concat(l)};return d=fa(a,o,i,h,u),s&&Object.keys(s).forEach((function(e){if(!t[e]){t[e]=!0;var n=fa(Ha(s[e]),o,"_effect-".concat(e),h,u);e.startsWith("@layer")?d=n+d:d+=n}})),[l,i,d]})),dr(Za,Da,(function(e,t,n){var r=mr(e,5),a=r[2],o=r[3],i=r[4],s=(n||{}).plain;if(!o)return null;var c=a._tokenKey;return[-999,c,fa(o,i,c,{"data-rc-order":"prependQueue","data-rc-priority":"".concat(-999)},s)]})),dr(Za,Ya,(function(e,t,n){var r=mr(e,4),a=r[1],o=r[2],i=r[3],s=(n||{}).plain;if(!a)return null;return[-999,o,fa(a,i,o,{"data-rc-order":"prependQueue","data-rc-priority":"".concat(-999)},s)]}));var Ja=function(){function e(t,n){jr(this,e),dr(this,"name",void 0),dr(this,"style",void 0),dr(this,"_keyframe",!0),this.name=t,this.style=n}return Gr(e,[{key:"getName",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e?"".concat(e,"-").concat(this.name):this.name}}]),e}();const eo=Ja;function to(e){return e.notSplit=!0,e}to(["borderTop","borderBottom"]),to(["borderTop"]),to(["borderBottom"]),to(["borderLeft","borderRight"]),to(["borderLeft"]),to(["borderRight"]);const no="5.18.1";function ro(e,t){(function(e){return"string"===typeof e&&-1!==e.indexOf(".")&&1===parseFloat(e)})(e)&&(e="100%");var n=function(e){return"string"===typeof e&&-1!==e.indexOf("%")}(e);return e=360===t?e:Math.min(t,Math.max(0,parseFloat(e))),n&&(e=parseInt(String(e*t),10)/100),Math.abs(e-t)<1e-6?1:e=360===t?(e<0?e%t+t:e%t)/parseFloat(String(t)):e%t/parseFloat(String(t))}function ao(e){return Math.min(1,Math.max(0,e))}function oo(e){return e=parseFloat(e),(isNaN(e)||e<0||e>1)&&(e=1),e}function io(e){return e<=1?"".concat(100*Number(e),"%"):e}function so(e){return 1===e.length?"0"+e:String(e)}function co(e,t,n){e=ro(e,255),t=ro(t,255),n=ro(n,255);var r=Math.max(e,t,n),a=Math.min(e,t,n),o=0,i=0,s=(r+a)/2;if(r===a)i=0,o=0;else{var c=r-a;switch(i=s>.5?c/(2-r-a):c/(r+a),r){case e:o=(t-n)/c+(t<n?6:0);break;case t:o=(n-e)/c+2;break;case n:o=(e-t)/c+4}o/=6}return{h:o,s:i,l:s}}function lo(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*n*(t-e):n<.5?t:n<2/3?e+(t-e)*(2/3-n)*6:e}function uo(e,t,n){e=ro(e,255),t=ro(t,255),n=ro(n,255);var r=Math.max(e,t,n),a=Math.min(e,t,n),o=0,i=r,s=r-a,c=0===r?0:s/r;if(r===a)o=0;else{switch(r){case e:o=(t-n)/s+(t<n?6:0);break;case t:o=(n-e)/s+2;break;case n:o=(e-t)/s+4}o/=6}return{h:o,s:c,v:i}}function ho(e,t,n,r){var a=[so(Math.round(e).toString(16)),so(Math.round(t).toString(16)),so(Math.round(n).toString(16))];return r&&a[0].startsWith(a[0].charAt(1))&&a[1].startsWith(a[1].charAt(1))&&a[2].startsWith(a[2].charAt(1))?a[0].charAt(0)+a[1].charAt(0)+a[2].charAt(0):a.join("")}function po(e){return Math.round(255*parseFloat(e)).toString(16)}function fo(e){return go(e)/255}function go(e){return parseInt(e,16)}var mo={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",goldenrod:"#daa520",gold:"#ffd700",gray:"#808080",green:"#008000",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavenderblush:"#fff0f5",lavender:"#e6e6fa",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"};function vo(e){var t={r:0,g:0,b:0},n=1,r=null,a=null,o=null,i=!1,s=!1;return"string"===typeof e&&(e=function(e){if(e=e.trim().toLowerCase(),0===e.length)return!1;var t=!1;if(mo[e])e=mo[e],t=!0;else if("transparent"===e)return{r:0,g:0,b:0,a:0,format:"name"};var n=wo.rgb.exec(e);if(n)return{r:n[1],g:n[2],b:n[3]};if(n=wo.rgba.exec(e),n)return{r:n[1],g:n[2],b:n[3],a:n[4]};if(n=wo.hsl.exec(e),n)return{h:n[1],s:n[2],l:n[3]};if(n=wo.hsla.exec(e),n)return{h:n[1],s:n[2],l:n[3],a:n[4]};if(n=wo.hsv.exec(e),n)return{h:n[1],s:n[2],v:n[3]};if(n=wo.hsva.exec(e),n)return{h:n[1],s:n[2],v:n[3],a:n[4]};if(n=wo.hex8.exec(e),n)return{r:go(n[1]),g:go(n[2]),b:go(n[3]),a:fo(n[4]),format:t?"name":"hex8"};if(n=wo.hex6.exec(e),n)return{r:go(n[1]),g:go(n[2]),b:go(n[3]),format:t?"name":"hex"};if(n=wo.hex4.exec(e),n)return{r:go(n[1]+n[1]),g:go(n[2]+n[2]),b:go(n[3]+n[3]),a:fo(n[4]+n[4]),format:t?"name":"hex8"};if(n=wo.hex3.exec(e),n)return{r:go(n[1]+n[1]),g:go(n[2]+n[2]),b:go(n[3]+n[3]),format:t?"name":"hex"};return!1}(e)),"object"===typeof e&&(ko(e.r)&&ko(e.g)&&ko(e.b)?(t=function(e,t,n){return{r:255*ro(e,255),g:255*ro(t,255),b:255*ro(n,255)}}(e.r,e.g,e.b),i=!0,s="%"===String(e.r).substr(-1)?"prgb":"rgb"):ko(e.h)&&ko(e.s)&&ko(e.v)?(r=io(e.s),a=io(e.v),t=function(e,t,n){e=6*ro(e,360),t=ro(t,100),n=ro(n,100);var r=Math.floor(e),a=e-r,o=n*(1-t),i=n*(1-a*t),s=n*(1-(1-a)*t),c=r%6;return{r:255*[n,i,o,o,s,n][c],g:255*[s,n,n,i,o,o][c],b:255*[o,o,s,n,n,i][c]}}(e.h,r,a),i=!0,s="hsv"):ko(e.h)&&ko(e.s)&&ko(e.l)&&(r=io(e.s),o=io(e.l),t=function(e,t,n){var r,a,o;if(e=ro(e,360),t=ro(t,100),n=ro(n,100),0===t)a=n,o=n,r=n;else{var i=n<.5?n*(1+t):n+t-n*t,s=2*n-i;r=lo(s,i,e+1/3),a=lo(s,i,e),o=lo(s,i,e-1/3)}return{r:255*r,g:255*a,b:255*o}}(e.h,r,o),i=!0,s="hsl"),Object.prototype.hasOwnProperty.call(e,"a")&&(n=e.a)),n=oo(n),{ok:i,format:e.format||s,r:Math.min(255,Math.max(t.r,0)),g:Math.min(255,Math.max(t.g,0)),b:Math.min(255,Math.max(t.b,0)),a:n}}var bo="(?:".concat("[-\\+]?\\d*\\.\\d+%?",")|(?:").concat("[-\\+]?\\d+%?",")"),yo="[\\s|\\(]+(".concat(bo,")[,|\\s]+(").concat(bo,")[,|\\s]+(").concat(bo,")\\s*\\)?"),xo="[\\s|\\(]+(".concat(bo,")[,|\\s]+(").concat(bo,")[,|\\s]+(").concat(bo,")[,|\\s]+(").concat(bo,")\\s*\\)?"),wo={CSS_UNIT:new RegExp(bo),rgb:new RegExp("rgb"+yo),rgba:new RegExp("rgba"+xo),hsl:new RegExp("hsl"+yo),hsla:new RegExp("hsla"+xo),hsv:new RegExp("hsv"+yo),hsva:new RegExp("hsva"+xo),hex3:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex4:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex8:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/};function ko(e){return Boolean(wo.CSS_UNIT.exec(String(e)))}var So=2,Co=.16,Io=.05,Eo=.05,No=.15,To=5,Ro=4,Ao=[{index:7,opacity:.15},{index:6,opacity:.25},{index:5,opacity:.3},{index:5,opacity:.45},{index:5,opacity:.65},{index:5,opacity:.85},{index:4,opacity:.9},{index:3,opacity:.95},{index:2,opacity:.97},{index:1,opacity:.98}];function Oo(e){var t=uo(e.r,e.g,e.b);return{h:360*t.h,s:t.s,v:t.v}}function Fo(e){var t=e.r,n=e.g,r=e.b;return"#".concat(ho(t,n,r,!1))}function _o(e,t,n){var r;return(r=Math.round(e.h)>=60&&Math.round(e.h)<=240?n?Math.round(e.h)-So*t:Math.round(e.h)+So*t:n?Math.round(e.h)+So*t:Math.round(e.h)-So*t)<0?r+=360:r>=360&&(r-=360),r}function Do(e,t,n){return 0===e.h&&0===e.s?e.s:((r=n?e.s-Co*t:t===Ro?e.s+Co:e.s+Io*t)>1&&(r=1),n&&t===To&&r>.1&&(r=.1),r<.06&&(r=.06),Number(r.toFixed(2)));var r}function Mo(e,t,n){var r;return(r=n?e.v+Eo*t:e.v-No*t)>1&&(r=1),Number(r.toFixed(2))}function Po(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=[],r=vo(e),a=To;a>0;a-=1){var o=Oo(r),i=Fo(vo({h:_o(o,a,!0),s:Do(o,a,!0),v:Mo(o,a,!0)}));n.push(i)}n.push(Fo(r));for(var s=1;s<=Ro;s+=1){var c=Oo(r),l=Fo(vo({h:_o(c,s),s:Do(c,s),v:Mo(c,s)}));n.push(l)}return"dark"===t.theme?Ao.map((function(e){var r=e.index,a=e.opacity,o=Fo(function(e,t,n){var r=n/100;return{r:(t.r-e.r)*r+e.r,g:(t.g-e.g)*r+e.g,b:(t.b-e.b)*r+e.b}}(vo(t.backgroundColor||"#141414"),vo(n[r]),100*a));return o})):n}var Lo={red:"#F5222D",volcano:"#FA541C",orange:"#FA8C16",gold:"#FAAD14",yellow:"#FADB14",lime:"#A0D911",green:"#52C41A",cyan:"#13C2C2",blue:"#1677FF",geekblue:"#2F54EB",purple:"#722ED1",magenta:"#EB2F96",grey:"#666666"},zo={},Bo={};Object.keys(Lo).forEach((function(e){zo[e]=Po(Lo[e]),zo[e].primary=zo[e][5],Bo[e]=Po(Lo[e],{theme:"dark",backgroundColor:"#141414"}),Bo[e].primary=Bo[e][5]}));zo.red,zo.volcano;var Wo=zo.gold,Uo=(zo.orange,zo.yellow,zo.lime,zo.green,zo.cyan,zo.blue);zo.geekblue,zo.purple,zo.magenta,zo.grey,zo.grey;const Vo={blue:"#1677ff",purple:"#722ED1",cyan:"#13C2C2",green:"#52C41A",magenta:"#EB2F96",pink:"#eb2f96",red:"#F5222D",orange:"#FA8C16",yellow:"#FADB14",volcano:"#FA541C",geekblue:"#2F54EB",gold:"#FAAD14",lime:"#A0D911"},jo=Object.assign(Object.assign({},Vo),{colorPrimary:"#1677ff",colorSuccess:"#52c41a",colorWarning:"#faad14",colorError:"#ff4d4f",colorInfo:"#1677ff",colorLink:"",colorTextBase:"",colorBgBase:"",fontFamily:"-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,\n'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n'Noto Color Emoji'",fontFamilyCode:"'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",fontSize:14,lineWidth:1,lineType:"solid",motionUnit:.1,motionBase:0,motionEaseOutCirc:"cubic-bezier(0.08, 0.82, 0.17, 1)",motionEaseInOutCirc:"cubic-bezier(0.78, 0.14, 0.15, 0.86)",motionEaseOut:"cubic-bezier(0.215, 0.61, 0.355, 1)",motionEaseInOut:"cubic-bezier(0.645, 0.045, 0.355, 1)",motionEaseOutBack:"cubic-bezier(0.12, 0.4, 0.29, 1.46)",motionEaseInBack:"cubic-bezier(0.71, -0.46, 0.88, 0.6)",motionEaseInQuint:"cubic-bezier(0.755, 0.05, 0.855, 0.06)",motionEaseOutQuint:"cubic-bezier(0.23, 1, 0.32, 1)",borderRadius:6,sizeUnit:4,sizeStep:4,sizePopupArrow:16,controlHeight:32,zIndexBase:0,zIndexPopupBase:1e3,opacityImage:1,wireframe:!1,motion:!0});var Ho=function(){function e(t,n){var r;if(void 0===t&&(t=""),void 0===n&&(n={}),t instanceof e)return t;"number"===typeof t&&(t=function(e){return{r:e>>16,g:(65280&e)>>8,b:255&e}}(t)),this.originalInput=t;var a=vo(t);this.originalInput=t,this.r=a.r,this.g=a.g,this.b=a.b,this.a=a.a,this.roundA=Math.round(100*this.a)/100,this.format=null!==(r=n.format)&&void 0!==r?r:a.format,this.gradientType=n.gradientType,this.r<1&&(this.r=Math.round(this.r)),this.g<1&&(this.g=Math.round(this.g)),this.b<1&&(this.b=Math.round(this.b)),this.isValid=a.ok}return e.prototype.isDark=function(){return this.getBrightness()<128},e.prototype.isLight=function(){return!this.isDark()},e.prototype.getBrightness=function(){var e=this.toRgb();return(299*e.r+587*e.g+114*e.b)/1e3},e.prototype.getLuminance=function(){var e=this.toRgb(),t=e.r/255,n=e.g/255,r=e.b/255;return.2126*(t<=.03928?t/12.92:Math.pow((t+.055)/1.055,2.4))+.7152*(n<=.03928?n/12.92:Math.pow((n+.055)/1.055,2.4))+.0722*(r<=.03928?r/12.92:Math.pow((r+.055)/1.055,2.4))},e.prototype.getAlpha=function(){return this.a},e.prototype.setAlpha=function(e){return this.a=oo(e),this.roundA=Math.round(100*this.a)/100,this},e.prototype.isMonochrome=function(){return 0===this.toHsl().s},e.prototype.toHsv=function(){var e=uo(this.r,this.g,this.b);return{h:360*e.h,s:e.s,v:e.v,a:this.a}},e.prototype.toHsvString=function(){var e=uo(this.r,this.g,this.b),t=Math.round(360*e.h),n=Math.round(100*e.s),r=Math.round(100*e.v);return 1===this.a?"hsv(".concat(t,", ").concat(n,"%, ").concat(r,"%)"):"hsva(".concat(t,", ").concat(n,"%, ").concat(r,"%, ").concat(this.roundA,")")},e.prototype.toHsl=function(){var e=co(this.r,this.g,this.b);return{h:360*e.h,s:e.s,l:e.l,a:this.a}},e.prototype.toHslString=function(){var e=co(this.r,this.g,this.b),t=Math.round(360*e.h),n=Math.round(100*e.s),r=Math.round(100*e.l);return 1===this.a?"hsl(".concat(t,", ").concat(n,"%, ").concat(r,"%)"):"hsla(".concat(t,", ").concat(n,"%, ").concat(r,"%, ").concat(this.roundA,")")},e.prototype.toHex=function(e){return void 0===e&&(e=!1),ho(this.r,this.g,this.b,e)},e.prototype.toHexString=function(e){return void 0===e&&(e=!1),"#"+this.toHex(e)},e.prototype.toHex8=function(e){return void 0===e&&(e=!1),function(e,t,n,r,a){var o=[so(Math.round(e).toString(16)),so(Math.round(t).toString(16)),so(Math.round(n).toString(16)),so(po(r))];return a&&o[0].startsWith(o[0].charAt(1))&&o[1].startsWith(o[1].charAt(1))&&o[2].startsWith(o[2].charAt(1))&&o[3].startsWith(o[3].charAt(1))?o[0].charAt(0)+o[1].charAt(0)+o[2].charAt(0)+o[3].charAt(0):o.join("")}(this.r,this.g,this.b,this.a,e)},e.prototype.toHex8String=function(e){return void 0===e&&(e=!1),"#"+this.toHex8(e)},e.prototype.toHexShortString=function(e){return void 0===e&&(e=!1),1===this.a?this.toHexString(e):this.toHex8String(e)},e.prototype.toRgb=function(){return{r:Math.round(this.r),g:Math.round(this.g),b:Math.round(this.b),a:this.a}},e.prototype.toRgbString=function(){var e=Math.round(this.r),t=Math.round(this.g),n=Math.round(this.b);return 1===this.a?"rgb(".concat(e,", ").concat(t,", ").concat(n,")"):"rgba(".concat(e,", ").concat(t,", ").concat(n,", ").concat(this.roundA,")")},e.prototype.toPercentageRgb=function(){var e=function(e){return"".concat(Math.round(100*ro(e,255)),"%")};return{r:e(this.r),g:e(this.g),b:e(this.b),a:this.a}},e.prototype.toPercentageRgbString=function(){var e=function(e){return Math.round(100*ro(e,255))};return 1===this.a?"rgb(".concat(e(this.r),"%, ").concat(e(this.g),"%, ").concat(e(this.b),"%)"):"rgba(".concat(e(this.r),"%, ").concat(e(this.g),"%, ").concat(e(this.b),"%, ").concat(this.roundA,")")},e.prototype.toName=function(){if(0===this.a)return"transparent";if(this.a<1)return!1;for(var e="#"+ho(this.r,this.g,this.b,!1),t=0,n=Object.entries(mo);t<n.length;t++){var r=n[t],a=r[0];if(e===r[1])return a}return!1},e.prototype.toString=function(e){var t=Boolean(e);e=null!==e&&void 0!==e?e:this.format;var n=!1,r=this.a<1&&this.a>=0;return t||!r||!e.startsWith("hex")&&"name"!==e?("rgb"===e&&(n=this.toRgbString()),"prgb"===e&&(n=this.toPercentageRgbString()),"hex"!==e&&"hex6"!==e||(n=this.toHexString()),"hex3"===e&&(n=this.toHexString(!0)),"hex4"===e&&(n=this.toHex8String(!0)),"hex8"===e&&(n=this.toHex8String()),"name"===e&&(n=this.toName()),"hsl"===e&&(n=this.toHslString()),"hsv"===e&&(n=this.toHsvString()),n||this.toHexString()):"name"===e&&0===this.a?this.toName():this.toRgbString()},e.prototype.toNumber=function(){return(Math.round(this.r)<<16)+(Math.round(this.g)<<8)+Math.round(this.b)},e.prototype.clone=function(){return new e(this.toString())},e.prototype.lighten=function(t){void 0===t&&(t=10);var n=this.toHsl();return n.l+=t/100,n.l=ao(n.l),new e(n)},e.prototype.brighten=function(t){void 0===t&&(t=10);var n=this.toRgb();return n.r=Math.max(0,Math.min(255,n.r-Math.round(-t/100*255))),n.g=Math.max(0,Math.min(255,n.g-Math.round(-t/100*255))),n.b=Math.max(0,Math.min(255,n.b-Math.round(-t/100*255))),new e(n)},e.prototype.darken=function(t){void 0===t&&(t=10);var n=this.toHsl();return n.l-=t/100,n.l=ao(n.l),new e(n)},e.prototype.tint=function(e){return void 0===e&&(e=10),this.mix("white",e)},e.prototype.shade=function(e){return void 0===e&&(e=10),this.mix("black",e)},e.prototype.desaturate=function(t){void 0===t&&(t=10);var n=this.toHsl();return n.s-=t/100,n.s=ao(n.s),new e(n)},e.prototype.saturate=function(t){void 0===t&&(t=10);var n=this.toHsl();return n.s+=t/100,n.s=ao(n.s),new e(n)},e.prototype.greyscale=function(){return this.desaturate(100)},e.prototype.spin=function(t){var n=this.toHsl(),r=(n.h+t)%360;return n.h=r<0?360+r:r,new e(n)},e.prototype.mix=function(t,n){void 0===n&&(n=50);var r=this.toRgb(),a=new e(t).toRgb(),o=n/100;return new e({r:(a.r-r.r)*o+r.r,g:(a.g-r.g)*o+r.g,b:(a.b-r.b)*o+r.b,a:(a.a-r.a)*o+r.a})},e.prototype.analogous=function(t,n){void 0===t&&(t=6),void 0===n&&(n=30);var r=this.toHsl(),a=360/n,o=[this];for(r.h=(r.h-(a*t>>1)+720)%360;--t;)r.h=(r.h+a)%360,o.push(new e(r));return o},e.prototype.complement=function(){var t=this.toHsl();return t.h=(t.h+180)%360,new e(t)},e.prototype.monochromatic=function(t){void 0===t&&(t=6);for(var n=this.toHsv(),r=n.h,a=n.s,o=n.v,i=[],s=1/t;t--;)i.push(new e({h:r,s:a,v:o})),o=(o+s)%1;return i},e.prototype.splitcomplement=function(){var t=this.toHsl(),n=t.h;return[this,new e({h:(n+72)%360,s:t.s,l:t.l}),new e({h:(n+216)%360,s:t.s,l:t.l})]},e.prototype.onBackground=function(t){var n=this.toRgb(),r=new e(t).toRgb(),a=n.a+r.a*(1-n.a);return new e({r:(n.r*n.a+r.r*r.a*(1-n.a))/a,g:(n.g*n.a+r.g*r.a*(1-n.a))/a,b:(n.b*n.a+r.b*r.a*(1-n.a))/a,a:a})},e.prototype.triad=function(){return this.polyad(3)},e.prototype.tetrad=function(){return this.polyad(4)},e.prototype.polyad=function(t){for(var n=this.toHsl(),r=n.h,a=[this],o=360/t,i=1;i<t;i++)a.push(new e({h:(r+i*o)%360,s:n.s,l:n.l}));return a},e.prototype.equals=function(t){return this.toRgbString()===new e(t).toRgbString()},e}();const Go=e=>{let t=e,n=e,r=e,a=e;return e<6&&e>=5?t=e+1:e<16&&e>=6?t=e+2:e>=16&&(t=16),e<7&&e>=5?n=4:e<8&&e>=7?n=5:e<14&&e>=8?n=6:e<16&&e>=14?n=7:e>=16&&(n=8),e<6&&e>=2?r=1:e>=6&&(r=2),e>4&&e<8?a=4:e>=8&&(a=6),{borderRadius:e,borderRadiusXS:r,borderRadiusSM:n,borderRadiusLG:t,borderRadiusOuter:a}};const qo=e=>{const{controlHeight:t}=e;return{controlHeightSM:.75*t,controlHeightXS:.5*t,controlHeightLG:1.25*t}};const Ko=e=>{const t=function(e){const t=new Array(10).fill(null).map(((t,n)=>{const r=n-1,a=e*Math.pow(2.71828,r/5),o=n>1?Math.floor(a):Math.ceil(a);return 2*Math.floor(o/2)}));return t[1]=e,t.map((e=>{return{size:e,lineHeight:(t=e,(t+8)/t)};var t}))}(e),n=t.map((e=>e.size)),r=t.map((e=>e.lineHeight)),a=n[1],o=n[0],i=n[2],s=r[1],c=r[0],l=r[2];return{fontSizeSM:o,fontSize:a,fontSizeLG:i,fontSizeXL:n[3],fontSizeHeading1:n[6],fontSizeHeading2:n[5],fontSizeHeading3:n[4],fontSizeHeading4:n[3],fontSizeHeading5:n[2],lineHeight:s,lineHeightLG:l,lineHeightSM:c,fontHeight:Math.round(s*a),fontHeightLG:Math.round(l*i),fontHeightSM:Math.round(c*o),lineHeightHeading1:r[6],lineHeightHeading2:r[5],lineHeightHeading3:r[4],lineHeightHeading4:r[3],lineHeightHeading5:r[2]}};const Xo=(e,t)=>new Ho(e).setAlpha(t).toRgbString(),$o=(e,t)=>new Ho(e).darken(t).toHexString(),Yo=e=>{const t=Po(e);return{1:t[0],2:t[1],3:t[2],4:t[3],5:t[4],6:t[5],7:t[6],8:t[4],9:t[5],10:t[6]}},Qo=(e,t)=>{const n=e||"#fff",r=t||"#000";return{colorBgBase:n,colorTextBase:r,colorText:Xo(r,.88),colorTextSecondary:Xo(r,.65),colorTextTertiary:Xo(r,.45),colorTextQuaternary:Xo(r,.25),colorFill:Xo(r,.15),colorFillSecondary:Xo(r,.06),colorFillTertiary:Xo(r,.04),colorFillQuaternary:Xo(r,.02),colorBgLayout:$o(n,4),colorBgContainer:$o(n,0),colorBgElevated:$o(n,0),colorBgSpotlight:Xo(r,.85),colorBgBlur:"transparent",colorBorder:$o(n,15),colorBorderSecondary:$o(n,6)}};const Zo=ia((function(e){const t=Object.keys(Vo).map((t=>{const n=Po(e[t]);return new Array(10).fill(1).reduce(((e,r,a)=>(e["".concat(t,"-").concat(a+1)]=n[a],e["".concat(t).concat(a+1)]=n[a],e)),{})})).reduce(((e,t)=>e=Object.assign(Object.assign({},e),t)),{});return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},e),t),function(e,t){let{generateColorPalettes:n,generateNeutralColorPalettes:r}=t;const{colorSuccess:a,colorWarning:o,colorError:i,colorInfo:s,colorPrimary:c,colorBgBase:l,colorTextBase:u}=e,d=n(c),h=n(a),p=n(o),f=n(i),g=n(s),m=r(l,u),v=n(e.colorLink||e.colorInfo);return Object.assign(Object.assign({},m),{colorPrimaryBg:d[1],colorPrimaryBgHover:d[2],colorPrimaryBorder:d[3],colorPrimaryBorderHover:d[4],colorPrimaryHover:d[5],colorPrimary:d[6],colorPrimaryActive:d[7],colorPrimaryTextHover:d[8],colorPrimaryText:d[9],colorPrimaryTextActive:d[10],colorSuccessBg:h[1],colorSuccessBgHover:h[2],colorSuccessBorder:h[3],colorSuccessBorderHover:h[4],colorSuccessHover:h[4],colorSuccess:h[6],colorSuccessActive:h[7],colorSuccessTextHover:h[8],colorSuccessText:h[9],colorSuccessTextActive:h[10],colorErrorBg:f[1],colorErrorBgHover:f[2],colorErrorBgActive:f[3],colorErrorBorder:f[3],colorErrorBorderHover:f[4],colorErrorHover:f[5],colorError:f[6],colorErrorActive:f[7],colorErrorTextHover:f[8],colorErrorText:f[9],colorErrorTextActive:f[10],colorWarningBg:p[1],colorWarningBgHover:p[2],colorWarningBorder:p[3],colorWarningBorderHover:p[4],colorWarningHover:p[4],colorWarning:p[6],colorWarningActive:p[7],colorWarningTextHover:p[8],colorWarningText:p[9],colorWarningTextActive:p[10],colorInfoBg:g[1],colorInfoBgHover:g[2],colorInfoBorder:g[3],colorInfoBorderHover:g[4],colorInfoHover:g[4],colorInfo:g[6],colorInfoActive:g[7],colorInfoTextHover:g[8],colorInfoText:g[9],colorInfoTextActive:g[10],colorLinkHover:v[4],colorLink:v[6],colorLinkActive:v[7],colorBgMask:new Ho("#000").setAlpha(.45).toRgbString(),colorWhite:"#fff"})}(e,{generateColorPalettes:Yo,generateNeutralColorPalettes:Qo})),Ko(e.fontSize)),function(e){const{sizeUnit:t,sizeStep:n}=e;return{sizeXXL:t*(n+8),sizeXL:t*(n+4),sizeLG:t*(n+2),sizeMD:t*(n+1),sizeMS:t*n,size:t*n,sizeSM:t*(n-1),sizeXS:t*(n-2),sizeXXS:t*(n-3)}}(e)),qo(e)),function(e){const{motionUnit:t,motionBase:n,borderRadius:r,lineWidth:a}=e;return Object.assign({motionDurationFast:"".concat((n+t).toFixed(1),"s"),motionDurationMid:"".concat((n+2*t).toFixed(1),"s"),motionDurationSlow:"".concat((n+3*t).toFixed(1),"s"),lineWidthBold:a+1},Go(r))}(e))})),Jo={token:jo,override:{override:jo},hashed:!0},ei=o.createContext(Jo);function ti(e){return e>=0&&e<=255}const ni=function(e,t){const{r:n,g:r,b:a,a:o}=new Ho(e).toRgb();if(o<1)return e;const{r:i,g:s,b:c}=new Ho(t).toRgb();for(let l=.01;l<=1;l+=.01){const e=Math.round((n-i*(1-l))/l),t=Math.round((r-s*(1-l))/l),o=Math.round((a-c*(1-l))/l);if(ti(e)&&ti(t)&&ti(o))return new Ho({r:e,g:t,b:o,a:Math.round(100*l)/100}).toRgbString()}return new Ho({r:n,g:r,b:a,a:1}).toRgbString()};var ri=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};function ai(e){const{override:t}=e,n=ri(e,["override"]),r=Object.assign({},t);Object.keys(jo).forEach((e=>{delete r[e]}));const a=Object.assign(Object.assign({},n),r),o=1200,i=1600;if(!1===a.motion){const e="0s";a.motionDurationFast=e,a.motionDurationMid=e,a.motionDurationSlow=e}return Object.assign(Object.assign(Object.assign({},a),{colorFillContent:a.colorFillSecondary,colorFillContentHover:a.colorFill,colorFillAlter:a.colorFillQuaternary,colorBgContainerDisabled:a.colorFillTertiary,colorBorderBg:a.colorBgContainer,colorSplit:ni(a.colorBorderSecondary,a.colorBgContainer),colorTextPlaceholder:a.colorTextQuaternary,colorTextDisabled:a.colorTextQuaternary,colorTextHeading:a.colorText,colorTextLabel:a.colorTextSecondary,colorTextDescription:a.colorTextTertiary,colorTextLightSolid:a.colorWhite,colorHighlight:a.colorError,colorBgTextHover:a.colorFillSecondary,colorBgTextActive:a.colorFill,colorIcon:a.colorTextTertiary,colorIconHover:a.colorText,colorErrorOutline:ni(a.colorErrorBg,a.colorBgContainer),colorWarningOutline:ni(a.colorWarningBg,a.colorBgContainer),fontSizeIcon:a.fontSizeSM,lineWidthFocus:4*a.lineWidth,lineWidth:a.lineWidth,controlOutlineWidth:2*a.lineWidth,controlInteractiveSize:a.controlHeight/2,controlItemBgHover:a.colorFillTertiary,controlItemBgActive:a.colorPrimaryBg,controlItemBgActiveHover:a.colorPrimaryBgHover,controlItemBgActiveDisabled:a.colorFill,controlTmpOutline:a.colorFillQuaternary,controlOutline:ni(a.colorPrimaryBg,a.colorBgContainer),lineType:a.lineType,borderRadius:a.borderRadius,borderRadiusXS:a.borderRadiusXS,borderRadiusSM:a.borderRadiusSM,borderRadiusLG:a.borderRadiusLG,fontWeightStrong:600,opacityLoading:.65,linkDecoration:"none",linkHoverDecoration:"none",linkFocusDecoration:"none",controlPaddingHorizontal:12,controlPaddingHorizontalSM:8,paddingXXS:a.sizeXXS,paddingXS:a.sizeXS,paddingSM:a.sizeSM,padding:a.size,paddingMD:a.sizeMD,paddingLG:a.sizeLG,paddingXL:a.sizeXL,paddingContentHorizontalLG:a.sizeLG,paddingContentVerticalLG:a.sizeMS,paddingContentHorizontal:a.sizeMS,paddingContentVertical:a.sizeSM,paddingContentHorizontalSM:a.size,paddingContentVerticalSM:a.sizeXS,marginXXS:a.sizeXXS,marginXS:a.sizeXS,marginSM:a.sizeSM,margin:a.size,marginMD:a.sizeMD,marginLG:a.sizeLG,marginXL:a.sizeXL,marginXXL:a.sizeXXL,boxShadow:"\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",boxShadowSecondary:"\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",boxShadowTertiary:"\n      0 1px 2px 0 rgba(0, 0, 0, 0.03),\n      0 1px 6px -1px rgba(0, 0, 0, 0.02),\n      0 2px 4px 0 rgba(0, 0, 0, 0.02)\n    ",screenXS:480,screenXSMin:480,screenXSMax:575,screenSM:576,screenSMMin:576,screenSMMax:767,screenMD:768,screenMDMin:768,screenMDMax:991,screenLG:992,screenLGMin:992,screenLGMax:1199,screenXL:o,screenXLMin:o,screenXLMax:1599,screenXXL:i,screenXXLMin:i,boxShadowPopoverArrow:"2px 2px 5px rgba(0, 0, 0, 0.05)",boxShadowCard:"\n      0 1px 2px -2px ".concat(new Ho("rgba(0, 0, 0, 0.16)").toRgbString(),",\n      0 3px 6px 0 ").concat(new Ho("rgba(0, 0, 0, 0.12)").toRgbString(),",\n      0 5px 12px 4px ").concat(new Ho("rgba(0, 0, 0, 0.09)").toRgbString(),"\n    "),boxShadowDrawerRight:"\n      -6px 0 16px 0 rgba(0, 0, 0, 0.08),\n      -3px 0 6px -4px rgba(0, 0, 0, 0.12),\n      -9px 0 28px 8px rgba(0, 0, 0, 0.05)\n    ",boxShadowDrawerLeft:"\n      6px 0 16px 0 rgba(0, 0, 0, 0.08),\n      3px 0 6px -4px rgba(0, 0, 0, 0.12),\n      9px 0 28px 8px rgba(0, 0, 0, 0.05)\n    ",boxShadowDrawerUp:"\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",boxShadowDrawerDown:"\n      0 -6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 -3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 -9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",boxShadowTabsOverflowLeft:"inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",boxShadowTabsOverflowRight:"inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",boxShadowTabsOverflowTop:"inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",boxShadowTabsOverflowBottom:"inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"}),r)}var oi=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const ii={lineHeight:!0,lineHeightSM:!0,lineHeightLG:!0,lineHeightHeading1:!0,lineHeightHeading2:!0,lineHeightHeading3:!0,lineHeightHeading4:!0,lineHeightHeading5:!0,opacityLoading:!0,fontWeightStrong:!0,zIndexPopupBase:!0,zIndexBase:!0},si={size:!0,sizeSM:!0,sizeLG:!0,sizeMD:!0,sizeXS:!0,sizeXXS:!0,sizeMS:!0,sizeXL:!0,sizeXXL:!0,sizeUnit:!0,sizeStep:!0,motionBase:!0,motionUnit:!0},ci={screenXS:!0,screenXSMin:!0,screenXSMax:!0,screenSM:!0,screenSMMin:!0,screenSMMax:!0,screenMD:!0,screenMDMin:!0,screenMDMax:!0,screenLG:!0,screenLGMin:!0,screenLGMax:!0,screenXL:!0,screenXLMin:!0,screenXLMax:!0,screenXXL:!0,screenXXLMin:!0},li=(e,t,n)=>{const r=n.getDerivativeToken(e),{override:a}=t,o=oi(t,["override"]);let i=Object.assign(Object.assign({},r),{override:a});return i=ai(i),o&&Object.entries(o).forEach((e=>{let[t,n]=e;const{theme:r}=n,a=oi(n,["theme"]);let o=a;r&&(o=li(Object.assign(Object.assign({},i),a),{override:a},r)),i[t]=o})),i};function ui(){const{token:e,hashed:t,theme:n,override:r,cssVar:a}=o.useContext(ei),i="".concat(no,"-").concat(t||""),s=n||Zo,[c,l,u]=Ma(s,[jo,e],{salt:i,override:r,getComputedToken:li,formatToken:ai,cssVar:a&&{prefix:a.prefix,key:a.key,unitless:ii,ignore:si,preserve:ci}});return[s,u,t?l:"",c,a]}const di=["xxl","xl","lg","md","sm","xs"];function hi(){const[,e]=ui(),t=(e=>({xs:"(max-width: ".concat(e.screenXSMax,"px)"),sm:"(min-width: ".concat(e.screenSM,"px)"),md:"(min-width: ".concat(e.screenMD,"px)"),lg:"(min-width: ".concat(e.screenLG,"px)"),xl:"(min-width: ".concat(e.screenXL,"px)"),xxl:"(min-width: ".concat(e.screenXXL,"px)")}))((e=>{const t=e,n=[].concat(di).reverse();return n.forEach(((e,r)=>{const a=e.toUpperCase(),o="screen".concat(a,"Min"),i="screen".concat(a);if(!(t[o]<=t[i]))throw new Error("".concat(o,"<=").concat(i," fails : !(").concat(t[o],"<=").concat(t[i],")"));if(r<n.length-1){const e="screen".concat(a,"Max");if(!(t[i]<=t[e]))throw new Error("".concat(i,"<=").concat(e," fails : !(").concat(t[i],"<=").concat(t[e],")"));const o=n[r+1].toUpperCase(),s="screen".concat(o,"Min");if(!(t[e]<=t[s]))throw new Error("".concat(e,"<=").concat(s," fails : !(").concat(t[e],"<=").concat(t[s],")"))}})),e})(e));return o.useMemo((()=>{const e=new Map;let n=-1,r={};return{matchHandlers:{},dispatch:t=>(r=t,e.forEach((e=>e(r))),e.size>=1),subscribe(t){return e.size||this.register(),n+=1,e.set(n,t),t(r),n},unsubscribe(t){e.delete(t),e.size||this.unregister()},unregister(){Object.keys(t).forEach((e=>{const n=t[e],r=this.matchHandlers[n];null===r||void 0===r||r.mql.removeListener(null===r||void 0===r?void 0:r.listener)})),e.clear()},register(){Object.keys(t).forEach((e=>{const n=t[e],a=t=>{let{matches:n}=t;this.dispatch(Object.assign(Object.assign({},r),{[e]:n}))},o=window.matchMedia(n);o.addListener(a),this.matchHandlers[n]={mql:o,listener:a},a(o)}))},responsiveMap:t}}),[e])}const pi="anticon",fi=o.createContext({getPrefixCls:(e,t)=>t||(e?"ant-".concat(e):"ant"),iconPrefixCls:pi}),{Consumer:gi}=fi,mi=(0,o.createContext)({});let vi=function(){return Gr((function e(){jr(this,e),this.map=new Map,this.objectIDMap=new WeakMap,this.nextID=0,this.lastAccessBeat=new Map,this.accessBeat=0}),[{key:"set",value:function(e,t){this.clear();const n=this.getCompositeKey(e);this.map.set(n,t),this.lastAccessBeat.set(n,Date.now())}},{key:"get",value:function(e){const t=this.getCompositeKey(e),n=this.map.get(t);return this.lastAccessBeat.set(t,Date.now()),this.accessBeat+=1,n}},{key:"getCompositeKey",value:function(e){return e.map((e=>e&&"object"===typeof e?"obj_".concat(this.getObjectID(e)):"".concat(typeof e,"_").concat(e))).join("|")}},{key:"getObjectID",value:function(e){if(this.objectIDMap.has(e))return this.objectIDMap.get(e);const t=this.nextID;return this.objectIDMap.set(e,t),this.nextID+=1,t}},{key:"clear",value:function(){if(this.accessBeat>1e4){const e=Date.now();this.lastAccessBeat.forEach(((t,n)=>{e-t>6e5&&(this.map.delete(n),this.lastAccessBeat.delete(n))})),this.accessBeat=0}}}])}();const bi=new vi;function yi(e){var t=o.useRef();t.current=e;var n=o.useCallback((function(){for(var e,n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];return null===(e=t.current)||void 0===e?void 0:e.call.apply(e,[t].concat(r))}),[]);return n}function xi(e){var t=o.useRef(!1),n=mr(o.useState(e),2),r=n[0],a=n[1];return o.useEffect((function(){return t.current=!1,function(){t.current=!0}}),[]),[r,function(e,n){n&&t.current||a(e)}]}function wi(e){return void 0!==e}function ki(e,t){var n=t||{},r=n.defaultValue,a=n.value,o=n.onChange,i=n.postState,s=mr(xi((function(){return wi(a)?a:wi(r)?"function"===typeof r?r():r:"function"===typeof e?e():e})),2),c=s[0],l=s[1],u=void 0!==a?a:c,d=i?i(u):u,h=yi(o),p=mr(xi([u]),2),f=p[0],g=p[1];return xa((function(){var e=f[0];c!==e&&h(c,e)}),[f]),xa((function(){wi(a)||l(a)}),[a]),[d,yi((function(e,t){l(e,t),g([u],t)}))]}var Si=n(816),Ci=function(e,t){"function"===typeof e?e(t):"object"===lr(e)&&e&&"current"in e&&(e.current=t)},Ii=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=t.filter(Boolean);return r.length<=1?r[0]:function(e){t.forEach((function(t){Ci(t,e)}))}},Ei=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return Dr((function(){return Ii.apply(void 0,t)}),t,(function(e,t){return e.length!==t.length||e.every((function(e,n){return e!==t[n]}))}))},Ni=function(e){var t,n,r=(0,Si.isMemo)(e)?e.type.type:e.type;return!!("function"!==typeof r||null!==(t=r.prototype)&&void 0!==t&&t.render||r.$$typeof===Si.ForwardRef)&&!!("function"!==typeof e||null!==(n=e.prototype)&&void 0!==n&&n.render||e.$$typeof===Si.ForwardRef)};function Ti(e){return(0,o.isValidElement)(e)&&!(0,Si.isFragment)(e)}Number(o.version.split(".")[0]);function Ri(e,t){for(var n=e,r=0;r<t.length;r+=1){if(null===n||void 0===n)return;n=n[t[r]]}return n}function Ai(e,t,n,r){if(!t.length)return n;var a,o,i=hr(a=t)||vr(a)||fr(a)||gr(),s=i[0],c=i.slice(1);return o=e||"number"!==typeof s?Array.isArray(e)?br(e):xr({},e):[],r&&void 0===n&&1===c.length?delete o[s][c[0]]:o[s]=Ai(o[s],c,n,r),o}function Oi(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return t.length&&r&&void 0===n&&!Ri(e,t.slice(0,-1))?e:Ai(e,t,n,r)}function Fi(e){return Array.isArray(e)?[]:{}}var _i="undefined"===typeof Reflect?Object.keys:Reflect.ownKeys;function Di(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=Fi(t[0]);return t.forEach((function(e){!function t(n,a){var o,i=new Set(a),s=Ri(e,n),c=Array.isArray(s);if(c||"object"===lr(o=s)&&null!==o&&Object.getPrototypeOf(o)===Object.prototype){if(!i.has(s)){i.add(s);var l=Ri(r,n);c?r=Oi(r,n,[]):l&&"object"===lr(l)||(r=Oi(r,n,Fi(s))),_i(s).forEach((function(e){t([].concat(br(n),[e]),i)}))}}else r=Oi(r,n,s)}([])})),r}const Mi=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return{boxSizing:"border-box",margin:0,padding:0,color:e.colorText,fontSize:e.fontSize,lineHeight:e.lineHeight,listStyle:"none",fontFamily:t?"inherit":e.fontFamily}},Pi=e=>({a:{color:e.colorLink,textDecoration:e.linkDecoration,backgroundColor:"transparent",outline:"none",cursor:"pointer",transition:"color ".concat(e.motionDurationSlow),"-webkit-text-decoration-skip":"objects","&:hover":{color:e.colorLinkHover},"&:active":{color:e.colorLinkActive},"&:active,\n  &:hover":{textDecoration:e.linkHoverDecoration,outline:0},"&:focus":{textDecoration:e.linkFocusDecoration,outline:0},"&[disabled]":{color:e.colorTextDisabled,cursor:"not-allowed"}}}),Li=(e,t,n,r)=>{const a='[class^="'.concat(t,'"], [class*=" ').concat(t,'"]'),o=n?".".concat(n):a,i={boxSizing:"border-box","&::before, &::after":{boxSizing:"border-box"}};let s={};return!1!==r&&(s={fontFamily:e.fontFamily,fontSize:e.fontSize}),{[o]:Object.assign(Object.assign(Object.assign({},s),i),{[a]:i})}};function zi(e){return zi=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},zi(e)}function Bi(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(Bi=function(){return!!e})()}function Wi(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function Ui(e,t){if(t&&("object"==lr(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return Wi(e)}function Vi(e,t,n){return t=zi(t),Ui(e,Bi()?Reflect.construct(t,n||[],zi(e).constructor):t.apply(e,n))}function ji(e,t){return ji=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},ji(e,t)}function Hi(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&ji(e,t)}const Gi=Gr((function e(){jr(this,e)})),qi="CALC_UNIT",Ki=new RegExp(qi,"g");function Xi(e){return"number"===typeof e?"".concat(e).concat(qi):e}let $i=function(e){function t(e,n){var r;jr(this,t),(r=Vi(this,t)).result="";const a=typeof e;return r.unitlessCssVar=n,e instanceof t?r.result="(".concat(e.result,")"):"number"===a?r.result=Xi(e):"string"===a&&(r.result=e),r}return Hi(t,e),Gr(t,[{key:"add",value:function(e){return e instanceof t?this.result="".concat(this.result," + ").concat(e.getResult()):"number"!==typeof e&&"string"!==typeof e||(this.result="".concat(this.result," + ").concat(Xi(e))),this.lowPriority=!0,this}},{key:"sub",value:function(e){return e instanceof t?this.result="".concat(this.result," - ").concat(e.getResult()):"number"!==typeof e&&"string"!==typeof e||(this.result="".concat(this.result," - ").concat(Xi(e))),this.lowPriority=!0,this}},{key:"mul",value:function(e){return this.lowPriority&&(this.result="(".concat(this.result,")")),e instanceof t?this.result="".concat(this.result," * ").concat(e.getResult(!0)):"number"!==typeof e&&"string"!==typeof e||(this.result="".concat(this.result," * ").concat(e)),this.lowPriority=!1,this}},{key:"div",value:function(e){return this.lowPriority&&(this.result="(".concat(this.result,")")),e instanceof t?this.result="".concat(this.result," / ").concat(e.getResult(!0)):"number"!==typeof e&&"string"!==typeof e||(this.result="".concat(this.result," / ").concat(e)),this.lowPriority=!1,this}},{key:"getResult",value:function(e){return this.lowPriority||e?"(".concat(this.result,")"):this.result}},{key:"equal",value:function(e){const{unit:t}=e||{};let n=!0;return"boolean"===typeof t?n=t:Array.from(this.unitlessCssVar).some((e=>this.result.includes(e)))&&(n=!1),this.result=this.result.replace(Ki,n?"px":""),"undefined"!==typeof this.lowPriority?"calc(".concat(this.result,")"):this.result}}])}(Gi),Yi=function(e){function t(e){var n;return jr(this,t),(n=Vi(this,t)).result=0,e instanceof t?n.result=e.result:"number"===typeof e&&(n.result=e),n}return Hi(t,e),Gr(t,[{key:"add",value:function(e){return e instanceof t?this.result+=e.result:"number"===typeof e&&(this.result+=e),this}},{key:"sub",value:function(e){return e instanceof t?this.result-=e.result:"number"===typeof e&&(this.result-=e),this}},{key:"mul",value:function(e){return e instanceof t?this.result*=e.result:"number"===typeof e&&(this.result*=e),this}},{key:"div",value:function(e){return e instanceof t?this.result/=e.result:"number"===typeof e&&(this.result/=e),this}},{key:"equal",value:function(){return this.result}}])}(Gi);const Qi=(e,t)=>{const n="css"===e?$i:Yi;return e=>new n(e,t)};const Zi="undefined"!==typeof CSSINJS_STATISTIC;let Ji=!0;function es(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(!Zi)return Object.assign.apply(Object,[{}].concat(t));Ji=!1;const r={};return t.forEach((e=>{Object.keys(e).forEach((t=>{Object.defineProperty(r,t,{configurable:!0,enumerable:!0,get:()=>e[t]})}))})),Ji=!0,r}const ts={};function ns(){}const rs=e=>{let t,n=e,r=ns;return Zi&&"undefined"!==typeof Proxy&&(t=new Set,n=new Proxy(e,{get:(e,n)=>(Ji&&t.add(n),e[n])}),r=(e,n)=>{var r;ts[e]={global:Array.from(t),component:Object.assign(Object.assign({},null===(r=ts[e])||void 0===r?void 0:r.component),n)}}),{token:n,keys:t,flush:r}},as=(e,t)=>{const[n,r]=ui();return $a({theme:n,token:r,hashId:"",path:["ant-design-icons",e],nonce:()=>null===t||void 0===t?void 0:t.nonce,layer:{name:"antd"}},(()=>[{[".".concat(e)]:Object.assign(Object.assign({},{display:"inline-flex",alignItems:"center",color:"inherit",fontStyle:"normal",lineHeight:0,textAlign:"center",textTransform:"none",verticalAlign:"-0.125em",textRendering:"optimizeLegibility","-webkit-font-smoothing":"antialiased","-moz-osx-font-smoothing":"grayscale","> *":{lineHeight:1},svg:{display:"inline-block"}}),{[".".concat(e," .").concat(e,"-icon")]:{display:"block"}})}]))},os=(e,t,n)=>{var r;return"function"===typeof n?n(es(t,null!==(r=t[e])&&void 0!==r?r:{})):null!==n&&void 0!==n?n:{}},is=(e,t,n,r)=>{const a=Object.assign({},t[e]);if(null===r||void 0===r?void 0:r.deprecatedTokens){const{deprecatedTokens:e}=r;e.forEach((e=>{let[t,n]=e;var r;((null===a||void 0===a?void 0:a[t])||(null===a||void 0===a?void 0:a[n]))&&(null!==(r=a[n])&&void 0!==r||(a[n]=null===a||void 0===a?void 0:a[t]))}))}const o=Object.assign(Object.assign({},n),a);return Object.keys(o).forEach((e=>{o[e]===t[e]&&delete o[e]})),o},ss=(e,t)=>"".concat([t,e.replace(/([A-Z]+)([A-Z][a-z]+)/g,"$1-$2").replace(/([a-z])([A-Z])/g,"$1-$2")].filter(Boolean).join("-"));function cs(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const a=Array.isArray(e)?e:[e,e],[i]=a,s=a.join("-");return function(e){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;const[c,l,u,d,h]=ui(),{getPrefixCls:p,iconPrefixCls:f,csp:g}=(0,o.useContext)(fi),m=p(),v=h?"css":"js",b=(y=()=>{const e=new Set;return h&&Object.keys(r.unitless||{}).forEach((t=>{e.add(ga(t,h.prefix)),e.add(ga(t,ss(i,h.prefix)))})),Qi(v,e)},x=[v,i,h&&h.prefix],o.useMemo((()=>{const e=bi.get(x);if(e)return e;const t=y();return bi.set(x,t),t}),x));var y,x;const{max:w,min:k}=function(e){return"js"===e?{max:Math.max,min:Math.min}:{max:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return"max(".concat(t.map((e=>pa(e))).join(","),")")},min:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return"min(".concat(t.map((e=>pa(e))).join(","),")")}}}(v),S={theme:c,token:d,hashId:u,nonce:()=>null===g||void 0===g?void 0:g.nonce,clientOnly:r.clientOnly,layer:{name:"antd"},order:r.order||-999};$a(Object.assign(Object.assign({},S),{clientOnly:!1,path:["Shared",m]}),(()=>[{"&":Pi(d)}])),as(f,g);return[$a(Object.assign(Object.assign({},S),{path:[s,e,f]}),(()=>{if(!1===r.injectStyle)return[];const{token:o,flush:s}=rs(d),c=os(i,l,n),p=".".concat(e),g=is(i,l,c,{deprecatedTokens:r.deprecatedTokens});h&&Object.keys(c).forEach((e=>{c[e]="var(".concat(ga(e,ss(i,h.prefix)),")")}));const v=es(o,{componentCls:p,prefixCls:e,iconCls:".".concat(f),antCls:".".concat(m),calc:b,max:w,min:k},h?c:g),y=t(v,{hashId:u,prefixCls:e,rootPrefixCls:m,iconPrefixCls:f});return s(i,g),[!1===r.resetStyle?null:Li(v,e,a,r.resetFont),y]})),u]}}const ls=(e,t,n,r)=>{const a=Array.isArray(e)?e[0]:e;function i(e){return"".concat(a).concat(e.slice(0,1).toUpperCase()).concat(e.slice(1))}const s=r&&r.unitless||{},c=Object.assign(Object.assign({},ii),{[i("zIndexPopup")]:!0});Object.keys(s).forEach((e=>{c[i(e)]=s[e]}));const l=Object.assign(Object.assign({},r),{unitless:c,prefixToken:i}),u=cs(e,t,n,l),d=((e,t,n)=>{const{unitless:r,injectStyle:a=!0,prefixToken:i}=n,s=a=>{let{rootCls:o,cssVar:s}=a;const[,c]=ui();return Qa({path:[e],prefix:s.prefix,key:null===s||void 0===s?void 0:s.key,unitless:r,ignore:si,token:c,scope:o},(()=>{const r=os(e,c,t),a=is(e,c,r,{deprecatedTokens:null===n||void 0===n?void 0:n.deprecatedTokens});return Object.keys(r).forEach((e=>{a[i(e)]=a[e],delete a[e]})),a})),null};return t=>{const[,,,,n]=ui();return[r=>a&&n?o.createElement(o.Fragment,null,o.createElement(s,{rootCls:t,cssVar:n,component:e}),r):r,null===n||void 0===n?void 0:n.key]}})(a,n,l);return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;const[,n]=u(e,t),[r,a]=d(t);return[r,n,a]}},us=e=>{const{componentCls:t}=e;return{[t]:{position:"relative",maxWidth:"100%",minHeight:1}}},ds=(e,t)=>((e,t)=>{const{prefixCls:n,componentCls:r,gridColumns:a}=e,o={};for(let i=a;i>=0;i--)0===i?(o["".concat(r).concat(t,"-").concat(i)]={display:"none"},o["".concat(r,"-push-").concat(i)]={insetInlineStart:"auto"},o["".concat(r,"-pull-").concat(i)]={insetInlineEnd:"auto"},o["".concat(r).concat(t,"-push-").concat(i)]={insetInlineStart:"auto"},o["".concat(r).concat(t,"-pull-").concat(i)]={insetInlineEnd:"auto"},o["".concat(r).concat(t,"-offset-").concat(i)]={marginInlineStart:0},o["".concat(r).concat(t,"-order-").concat(i)]={order:0}):(o["".concat(r).concat(t,"-").concat(i)]=[{"--ant-display":"block",display:"block"},{display:"var(--ant-display)",flex:"0 0 ".concat(i/a*100,"%"),maxWidth:"".concat(i/a*100,"%")}],o["".concat(r).concat(t,"-push-").concat(i)]={insetInlineStart:"".concat(i/a*100,"%")},o["".concat(r).concat(t,"-pull-").concat(i)]={insetInlineEnd:"".concat(i/a*100,"%")},o["".concat(r).concat(t,"-offset-").concat(i)]={marginInlineStart:"".concat(i/a*100,"%")},o["".concat(r).concat(t,"-order-").concat(i)]={order:i});return o["".concat(r).concat(t,"-flex")]={flex:"var(--".concat(n).concat(t,"-flex)")},o})(e,t),hs=ls("Grid",(e=>{const{componentCls:t}=e;return{[t]:{display:"flex",flexFlow:"row wrap",minWidth:0,"&::before, &::after":{display:"flex"},"&-no-wrap":{flexWrap:"nowrap"},"&-start":{justifyContent:"flex-start"},"&-center":{justifyContent:"center"},"&-end":{justifyContent:"flex-end"},"&-space-between":{justifyContent:"space-between"},"&-space-around":{justifyContent:"space-around"},"&-space-evenly":{justifyContent:"space-evenly"},"&-top":{alignItems:"flex-start"},"&-middle":{alignItems:"center"},"&-bottom":{alignItems:"flex-end"}}}}),(()=>({}))),ps=ls("Grid",(e=>{const t=es(e,{gridColumns:24}),n={"-sm":t.screenSMMin,"-md":t.screenMDMin,"-lg":t.screenLGMin,"-xl":t.screenXLMin,"-xxl":t.screenXXLMin};return[us(t),ds(t,""),ds(t,"-xs"),Object.keys(n).map((e=>((e,t,n)=>({["@media (min-width: ".concat(pa(t),")")]:Object.assign({},ds(e,n))}))(t,n[e],e))).reduce(((e,t)=>Object.assign(Object.assign({},e),t)),{})]}),(()=>({})));var fs=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};function gs(e,t){const[n,r]=o.useState("string"===typeof e?e:"");return o.useEffect((()=>{(()=>{if("string"===typeof e&&r(e),"object"===typeof e)for(let n=0;n<di.length;n++){const a=di[n];if(!t[a])continue;const o=e[a];if(void 0!==o)return void r(o)}})()}),[JSON.stringify(e),t]),n}const ms=o.forwardRef(((e,t)=>{const{prefixCls:n,justify:r,align:a,className:i,style:s,children:c,gutter:l=0,wrap:u}=e,d=fs(e,["prefixCls","justify","align","className","style","children","gutter","wrap"]),{getPrefixCls:h,direction:p}=o.useContext(fi),[f,g]=o.useState({xs:!0,sm:!0,md:!0,lg:!0,xl:!0,xxl:!0}),[m,v]=o.useState({xs:!1,sm:!1,md:!1,lg:!1,xl:!1,xxl:!1}),b=gs(a,m),y=gs(r,m),x=o.useRef(l),w=hi();o.useEffect((()=>{const e=w.subscribe((e=>{v(e);const t=x.current||0;(!Array.isArray(t)&&"object"===typeof t||Array.isArray(t)&&("object"===typeof t[0]||"object"===typeof t[1]))&&g(e)}));return()=>w.unsubscribe(e)}),[]);const k=h("row",n),[S,C,I]=hs(k),E=(()=>{const e=[void 0,void 0];return(Array.isArray(l)?l:[l,void 0]).forEach(((t,n)=>{if("object"===typeof t)for(let r=0;r<di.length;r++){const a=di[r];if(f[a]&&void 0!==t[a]){e[n]=t[a];break}}else e[n]=t})),e})(),N=cr()(k,{["".concat(k,"-no-wrap")]:!1===u,["".concat(k,"-").concat(y)]:y,["".concat(k,"-").concat(b)]:b,["".concat(k,"-rtl")]:"rtl"===p},i,C,I),T={},R=null!=E[0]&&E[0]>0?E[0]/-2:void 0;R&&(T.marginLeft=R,T.marginRight=R);const[A,O]=E;T.rowGap=O;const F=o.useMemo((()=>({gutter:[A,O],wrap:u})),[A,O,u]);return S(o.createElement(mi.Provider,{value:F},o.createElement("div",Object.assign({},d,{className:N,style:Object.assign(Object.assign({},T),s),ref:t}),c)))}));const vs=ms;var bs=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};function ys(e){return"number"===typeof e?"".concat(e," ").concat(e," auto"):/^\d+(\.\d+)?(px|em|rem|%)$/.test(e)?"0 0 ".concat(e):e}const xs=["xs","sm","md","lg","xl","xxl"],ws=o.forwardRef(((e,t)=>{const{getPrefixCls:n,direction:r}=o.useContext(fi),{gutter:a,wrap:i}=o.useContext(mi),{prefixCls:s,span:c,order:l,offset:u,push:d,pull:h,className:p,children:f,flex:g,style:m}=e,v=bs(e,["prefixCls","span","order","offset","push","pull","className","children","flex","style"]),b=n("col",s),[y,x,w]=ps(b),k={};let S={};xs.forEach((t=>{let n={};const a=e[t];"number"===typeof a?n.span=a:"object"===typeof a&&(n=a||{}),delete v[t],S=Object.assign(Object.assign({},S),{["".concat(b,"-").concat(t,"-").concat(n.span)]:void 0!==n.span,["".concat(b,"-").concat(t,"-order-").concat(n.order)]:n.order||0===n.order,["".concat(b,"-").concat(t,"-offset-").concat(n.offset)]:n.offset||0===n.offset,["".concat(b,"-").concat(t,"-push-").concat(n.push)]:n.push||0===n.push,["".concat(b,"-").concat(t,"-pull-").concat(n.pull)]:n.pull||0===n.pull,["".concat(b,"-rtl")]:"rtl"===r}),n.flex&&(S["".concat(b,"-").concat(t,"-flex")]=!0,k["--".concat(b,"-").concat(t,"-flex")]=ys(n.flex))}));const C=cr()(b,{["".concat(b,"-").concat(c)]:void 0!==c,["".concat(b,"-order-").concat(l)]:l,["".concat(b,"-offset-").concat(u)]:u,["".concat(b,"-push-").concat(d)]:d,["".concat(b,"-pull-").concat(h)]:h},p,S,x,w),I={};if(a&&a[0]>0){const e=a[0]/2;I.paddingLeft=e,I.paddingRight=e}return g&&(I.flex=ys(g),!1!==i||I.minWidth||(I.minWidth=0)),y(o.createElement("div",Object.assign({},v,{style:Object.assign(Object.assign(Object.assign({},I),m),k),className:C,ref:t}),f))}));const ks=ws;const Ss={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z"}}]},name:"edit",theme:"outlined"};function Cs(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n={};for(var r in e)if({}.hasOwnProperty.call(e,r)){if(t.indexOf(r)>=0)continue;n[r]=e[r]}return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||{}.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}const Is=(0,o.createContext)({});function Es(e){var t;return null===e||void 0===e||null===(t=e.getRootNode)||void 0===t?void 0:t.call(e)}function Ns(e){return function(e){return Es(e)instanceof ShadowRoot}(e)?Es(e):null}function Ts(e){return"object"===lr(e)&&"string"===typeof e.name&&"string"===typeof e.theme&&("object"===lr(e.icon)||"function"===typeof e.icon)}function Rs(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return Object.keys(e).reduce((function(t,n){var r=e[n];if("class"===n)t.className=r,delete t.class;else delete t[n],t[function(e){return e.replace(/-(.)/g,(function(e,t){return t.toUpperCase()}))}(n)]=r;return t}),{})}function As(e,t,n){return n?o.createElement(e.tag,xr(xr({key:t},Rs(e.attrs)),n),(e.children||[]).map((function(n,r){return As(n,"".concat(t,"-").concat(e.tag,"-").concat(r))}))):o.createElement(e.tag,xr({key:t},Rs(e.attrs)),(e.children||[]).map((function(n,r){return As(n,"".concat(t,"-").concat(e.tag,"-").concat(r))})))}function Os(e){return Po(e)[0]}function Fs(e){return e?Array.isArray(e)?e:[e]:[]}var _s=["icon","className","onClick","style","primaryColor","secondaryColor"],Ds={primaryColor:"#333",secondaryColor:"#E6E6E6",calculated:!1};var Ms=function(e){var t=e.icon,n=e.className,r=e.onClick,a=e.style,i=e.primaryColor,s=e.secondaryColor,c=Cs(e,_s),l=o.useRef(),u=Ds;if(i&&(u={primaryColor:i,secondaryColor:s||Os(i)}),function(e){var t=(0,o.useContext)(Is),n=t.csp,r=t.prefixCls,a="\n.anticon {\n  display: inline-flex;\n  align-items: center;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";r&&(a=a.replace(/anticon/g,r)),(0,o.useEffect)((function(){var t=Ns(e.current);_r(a,"@ant-design-icons",{prepend:!0,csp:n,attachTo:t})}),[])}(l),function(e,t){Ur(e,"[@ant-design/icons] ".concat(t))}(Ts(t),"icon should be icon definiton, but got ".concat(t)),!Ts(t))return null;var d=t;return d&&"function"===typeof d.icon&&(d=xr(xr({},d),{},{icon:d.icon(u.primaryColor,u.secondaryColor)})),As(d.icon,"svg-".concat(d.name),xr(xr({className:n,onClick:r,style:a,"data-icon":d.name,width:"1em",height:"1em",fill:"currentColor","aria-hidden":"true"},c),{},{ref:l}))};Ms.displayName="IconReact",Ms.getTwoToneColors=function(){return xr({},Ds)},Ms.setTwoToneColors=function(e){var t=e.primaryColor,n=e.secondaryColor;Ds.primaryColor=t,Ds.secondaryColor=n||Os(t),Ds.calculated=!!n};const Ps=Ms;function Ls(e){var t=mr(Fs(e),2),n=t[0],r=t[1];return Ps.setTwoToneColors({primaryColor:n,secondaryColor:r})}var zs=["className","icon","spin","rotate","tabIndex","onClick","twoToneColor"];Ls(Uo.primary);var Bs=o.forwardRef((function(e,t){var n=e.className,r=e.icon,a=e.spin,i=e.rotate,s=e.tabIndex,c=e.onClick,l=e.twoToneColor,u=Cs(e,zs),d=o.useContext(Is),h=d.prefixCls,p=void 0===h?"anticon":h,f=d.rootClassName,g=cr()(f,p,dr(dr({},"".concat(p,"-").concat(r.name),!!r.name),"".concat(p,"-spin"),!!a||"loading"===r.name),n),m=s;void 0===m&&c&&(m=-1);var v=i?{msTransform:"rotate(".concat(i,"deg)"),transform:"rotate(".concat(i,"deg)")}:void 0,b=mr(Fs(l),2),y=b[0],x=b[1];return o.createElement("span",Pa({role:"img","aria-label":r.name},u,{ref:t,tabIndex:m,onClick:c,className:g}),o.createElement(Ps,{icon:r,primaryColor:y,secondaryColor:x,style:v}))}));Bs.displayName="AntdIcon",Bs.getTwoToneColor=function(){var e=Ps.getTwoToneColors();return e.calculated?[e.primaryColor,e.secondaryColor]:e.primaryColor},Bs.setTwoToneColor=Ls;const Ws=Bs;var Us=function(e,t){return o.createElement(Ws,Pa({},e,{ref:t,icon:Ss}))};const Vs=o.forwardRef(Us);function js(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=[];return o.Children.forEach(e,(function(e){(void 0!==e&&null!==e||t.keepEmpty)&&(Array.isArray(e)?n=n.concat(js(e)):(0,Si.isFragment)(e)&&e.props?n=n.concat(js(e.props.children,t)):n.push(e))})),n}function Hs(e){return e instanceof HTMLElement||e instanceof SVGElement}function Gs(e){var t,n=function(e){return e&&"object"===lr(e)&&Hs(e.nativeElement)?e.nativeElement:Hs(e)?e:null}(e);return n||(e instanceof o.Component?null===(t=l.findDOMNode)||void 0===t?void 0:t.call(l,e):null)}var qs=o.createContext(null);var Ks=function(){if("undefined"!==typeof Map)return Map;function e(e,t){var n=-1;return e.some((function(e,r){return e[0]===t&&(n=r,!0)})),n}return function(){function t(){this.__entries__=[]}return Object.defineProperty(t.prototype,"size",{get:function(){return this.__entries__.length},enumerable:!0,configurable:!0}),t.prototype.get=function(t){var n=e(this.__entries__,t),r=this.__entries__[n];return r&&r[1]},t.prototype.set=function(t,n){var r=e(this.__entries__,t);~r?this.__entries__[r][1]=n:this.__entries__.push([t,n])},t.prototype.delete=function(t){var n=this.__entries__,r=e(n,t);~r&&n.splice(r,1)},t.prototype.has=function(t){return!!~e(this.__entries__,t)},t.prototype.clear=function(){this.__entries__.splice(0)},t.prototype.forEach=function(e,t){void 0===t&&(t=null);for(var n=0,r=this.__entries__;n<r.length;n++){var a=r[n];e.call(t,a[1],a[0])}},t}()}(),Xs="undefined"!==typeof window&&"undefined"!==typeof document&&window.document===document,$s="undefined"!==typeof n.g&&n.g.Math===Math?n.g:"undefined"!==typeof self&&self.Math===Math?self:"undefined"!==typeof window&&window.Math===Math?window:Function("return this")(),Ys="function"===typeof requestAnimationFrame?requestAnimationFrame.bind($s):function(e){return setTimeout((function(){return e(Date.now())}),1e3/60)};var Qs=["top","right","bottom","left","width","height","size","weight"],Zs="undefined"!==typeof MutationObserver,Js=function(){function e(){this.connected_=!1,this.mutationEventsAdded_=!1,this.mutationsObserver_=null,this.observers_=[],this.onTransitionEnd_=this.onTransitionEnd_.bind(this),this.refresh=function(e,t){var n=!1,r=!1,a=0;function o(){n&&(n=!1,e()),r&&s()}function i(){Ys(o)}function s(){var e=Date.now();if(n){if(e-a<2)return;r=!0}else n=!0,r=!1,setTimeout(i,t);a=e}return s}(this.refresh.bind(this),20)}return e.prototype.addObserver=function(e){~this.observers_.indexOf(e)||this.observers_.push(e),this.connected_||this.connect_()},e.prototype.removeObserver=function(e){var t=this.observers_,n=t.indexOf(e);~n&&t.splice(n,1),!t.length&&this.connected_&&this.disconnect_()},e.prototype.refresh=function(){this.updateObservers_()&&this.refresh()},e.prototype.updateObservers_=function(){var e=this.observers_.filter((function(e){return e.gatherActive(),e.hasActive()}));return e.forEach((function(e){return e.broadcastActive()})),e.length>0},e.prototype.connect_=function(){Xs&&!this.connected_&&(document.addEventListener("transitionend",this.onTransitionEnd_),window.addEventListener("resize",this.refresh),Zs?(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})):(document.addEventListener("DOMSubtreeModified",this.refresh),this.mutationEventsAdded_=!0),this.connected_=!0)},e.prototype.disconnect_=function(){Xs&&this.connected_&&(document.removeEventListener("transitionend",this.onTransitionEnd_),window.removeEventListener("resize",this.refresh),this.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationEventsAdded_&&document.removeEventListener("DOMSubtreeModified",this.refresh),this.mutationsObserver_=null,this.mutationEventsAdded_=!1,this.connected_=!1)},e.prototype.onTransitionEnd_=function(e){var t=e.propertyName,n=void 0===t?"":t;Qs.some((function(e){return!!~n.indexOf(e)}))&&this.refresh()},e.getInstance=function(){return this.instance_||(this.instance_=new e),this.instance_},e.instance_=null,e}(),ec=function(e,t){for(var n=0,r=Object.keys(t);n<r.length;n++){var a=r[n];Object.defineProperty(e,a,{value:t[a],enumerable:!1,writable:!1,configurable:!0})}return e},tc=function(e){return e&&e.ownerDocument&&e.ownerDocument.defaultView||$s},nc=cc(0,0,0,0);function rc(e){return parseFloat(e)||0}function ac(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];return t.reduce((function(t,n){return t+rc(e["border-"+n+"-width"])}),0)}function oc(e){var t=e.clientWidth,n=e.clientHeight;if(!t&&!n)return nc;var r=tc(e).getComputedStyle(e),a=function(e){for(var t={},n=0,r=["top","right","bottom","left"];n<r.length;n++){var a=r[n],o=e["padding-"+a];t[a]=rc(o)}return t}(r),o=a.left+a.right,i=a.top+a.bottom,s=rc(r.width),c=rc(r.height);if("border-box"===r.boxSizing&&(Math.round(s+o)!==t&&(s-=ac(r,"left","right")+o),Math.round(c+i)!==n&&(c-=ac(r,"top","bottom")+i)),!function(e){return e===tc(e).document.documentElement}(e)){var l=Math.round(s+o)-t,u=Math.round(c+i)-n;1!==Math.abs(l)&&(s-=l),1!==Math.abs(u)&&(c-=u)}return cc(a.left,a.top,s,c)}var ic="undefined"!==typeof SVGGraphicsElement?function(e){return e instanceof tc(e).SVGGraphicsElement}:function(e){return e instanceof tc(e).SVGElement&&"function"===typeof e.getBBox};function sc(e){return Xs?ic(e)?function(e){var t=e.getBBox();return cc(0,0,t.width,t.height)}(e):oc(e):nc}function cc(e,t,n,r){return{x:e,y:t,width:n,height:r}}var lc=function(){function e(e){this.broadcastWidth=0,this.broadcastHeight=0,this.contentRect_=cc(0,0,0,0),this.target=e}return e.prototype.isActive=function(){var e=sc(this.target);return this.contentRect_=e,e.width!==this.broadcastWidth||e.height!==this.broadcastHeight},e.prototype.broadcastRect=function(){var e=this.contentRect_;return this.broadcastWidth=e.width,this.broadcastHeight=e.height,e},e}(),uc=function(e,t){var n=function(e){var t=e.x,n=e.y,r=e.width,a=e.height,o="undefined"!==typeof DOMRectReadOnly?DOMRectReadOnly:Object,i=Object.create(o.prototype);return ec(i,{x:t,y:n,width:r,height:a,top:n,right:t+r,bottom:a+n,left:t}),i}(t);ec(this,{target:e,contentRect:n})},dc=function(){function e(e,t,n){if(this.activeObservations_=[],this.observations_=new Ks,"function"!==typeof e)throw new TypeError("The callback provided as parameter 1 is not a function.");this.callback_=e,this.controller_=t,this.callbackCtx_=n}return e.prototype.observe=function(e){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!==typeof Element&&Element instanceof Object){if(!(e instanceof tc(e).Element))throw new TypeError('parameter 1 is not of type "Element".');var t=this.observations_;t.has(e)||(t.set(e,new lc(e)),this.controller_.addObserver(this),this.controller_.refresh())}},e.prototype.unobserve=function(e){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!==typeof Element&&Element instanceof Object){if(!(e instanceof tc(e).Element))throw new TypeError('parameter 1 is not of type "Element".');var t=this.observations_;t.has(e)&&(t.delete(e),t.size||this.controller_.removeObserver(this))}},e.prototype.disconnect=function(){this.clearActive(),this.observations_.clear(),this.controller_.removeObserver(this)},e.prototype.gatherActive=function(){var e=this;this.clearActive(),this.observations_.forEach((function(t){t.isActive()&&e.activeObservations_.push(t)}))},e.prototype.broadcastActive=function(){if(this.hasActive()){var e=this.callbackCtx_,t=this.activeObservations_.map((function(e){return new uc(e.target,e.broadcastRect())}));this.callback_.call(e,t,e),this.clearActive()}},e.prototype.clearActive=function(){this.activeObservations_.splice(0)},e.prototype.hasActive=function(){return this.activeObservations_.length>0},e}(),hc="undefined"!==typeof WeakMap?new WeakMap:new Ks,pc=function e(t){if(!(this instanceof e))throw new TypeError("Cannot call a class as a function.");if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");var n=Js.getInstance(),r=new dc(t,n,this);hc.set(this,r)};["observe","unobserve","disconnect"].forEach((function(e){pc.prototype[e]=function(){var t;return(t=hc.get(this))[e].apply(t,arguments)}}));const fc="undefined"!==typeof $s.ResizeObserver?$s.ResizeObserver:pc;var gc=new Map;var mc=new fc((function(e){e.forEach((function(e){var t,n=e.target;null===(t=gc.get(n))||void 0===t||t.forEach((function(e){return e(n)}))}))}));function vc(e){var t=Bi();return function(){var n,r=zi(e);if(t){var a=zi(this).constructor;n=Reflect.construct(r,arguments,a)}else n=r.apply(this,arguments);return Ui(this,n)}}var bc=function(e){Hi(n,e);var t=vc(n);function n(){return jr(this,n),t.apply(this,arguments)}return Gr(n,[{key:"render",value:function(){return this.props.children}}]),n}(o.Component);function yc(e,t){var n=e.children,r=e.disabled,a=o.useRef(null),i=o.useRef(null),s=o.useContext(qs),c="function"===typeof n,l=c?n(a):n,u=o.useRef({width:-1,height:-1,offsetWidth:-1,offsetHeight:-1}),d=!c&&o.isValidElement(l)&&Ni(l),h=d?l.ref:null,p=Ei(h,a),f=function(){var e;return Gs(a.current)||(a.current&&"object"===lr(a.current)?Gs(null===(e=a.current)||void 0===e?void 0:e.nativeElement):null)||Gs(i.current)};o.useImperativeHandle(t,(function(){return f()}));var g=o.useRef(e);g.current=e;var m=o.useCallback((function(e){var t=g.current,n=t.onResize,r=t.data,a=e.getBoundingClientRect(),o=a.width,i=a.height,c=e.offsetWidth,l=e.offsetHeight,d=Math.floor(o),h=Math.floor(i);if(u.current.width!==d||u.current.height!==h||u.current.offsetWidth!==c||u.current.offsetHeight!==l){var p={width:d,height:h,offsetWidth:c,offsetHeight:l};u.current=p;var f=c===Math.round(o)?o:c,m=l===Math.round(i)?i:l,v=xr(xr({},p),{},{offsetWidth:f,offsetHeight:m});null===s||void 0===s||s(v,e,r),n&&Promise.resolve().then((function(){n(v,e)}))}}),[]);return o.useEffect((function(){var e,t,n=f();return n&&!r&&(e=n,t=m,gc.has(e)||(gc.set(e,new Set),mc.observe(e)),gc.get(e).add(t)),function(){return function(e,t){gc.has(e)&&(gc.get(e).delete(t),gc.get(e).size||(mc.unobserve(e),gc.delete(e)))}(n,m)}}),[a.current,r]),o.createElement(bc,{ref:i},d?o.cloneElement(l,{ref:p}):l)}const xc=o.forwardRef(yc);function wc(e,t){var n=e.children;return("function"===typeof n?[n]:js(n)).map((function(n,r){var a=(null===n||void 0===n?void 0:n.key)||"".concat("rc-observer-key","-").concat(r);return o.createElement(xc,Pa({},e,{key:a,ref:0===r?t:void 0}),n)}))}var kc=o.forwardRef(wc);kc.Collection=function(e){var t=e.children,n=e.onBatchResize,r=o.useRef(0),a=o.useRef([]),i=o.useContext(qs),s=o.useCallback((function(e,t,o){r.current+=1;var s=r.current;a.current.push({size:e,element:t,data:o}),Promise.resolve().then((function(){s===r.current&&(null===n||void 0===n||n(a.current),a.current=[])})),null===i||void 0===i||i(e,t,o)}),[n,i]);return o.createElement(qs.Provider,{value:s},t)};const Sc=kc;function Cc(e,t){var n=Object.assign({},e);return Array.isArray(t)&&t.forEach((function(e){delete n[e]})),n}var Ic=function(e){if(kr()&&window.document.documentElement){var t=Array.isArray(e)?e:[e],n=window.document.documentElement;return t.some((function(e){return e in n.style}))}return!1};function Ec(e,t){return Array.isArray(e)||void 0===t?Ic(e):function(e,t){if(!Ic(e))return!1;var n=document.createElement("div"),r=n.style[e];return n.style[e]=t,n.style[e]!==r}(e,t)}var Nc={MAC_ENTER:3,BACKSPACE:8,TAB:9,NUM_CENTER:12,ENTER:13,SHIFT:16,CTRL:17,ALT:18,PAUSE:19,CAPS_LOCK:20,ESC:27,SPACE:32,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40,PRINT_SCREEN:44,INSERT:45,DELETE:46,ZERO:48,ONE:49,TWO:50,THREE:51,FOUR:52,FIVE:53,SIX:54,SEVEN:55,EIGHT:56,NINE:57,QUESTION_MARK:63,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,META:91,WIN_KEY_RIGHT:92,CONTEXT_MENU:93,NUM_ZERO:96,NUM_ONE:97,NUM_TWO:98,NUM_THREE:99,NUM_FOUR:100,NUM_FIVE:101,NUM_SIX:102,NUM_SEVEN:103,NUM_EIGHT:104,NUM_NINE:105,NUM_MULTIPLY:106,NUM_PLUS:107,NUM_MINUS:109,NUM_PERIOD:110,NUM_DIVISION:111,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,NUMLOCK:144,SEMICOLON:186,DASH:189,EQUALS:187,COMMA:188,PERIOD:190,SLASH:191,APOSTROPHE:192,SINGLE_QUOTE:222,OPEN_SQUARE_BRACKET:219,BACKSLASH:220,CLOSE_SQUARE_BRACKET:221,WIN_KEY:224,MAC_FF_META:224,WIN_IME:229,isTextModifyingKeyEvent:function(e){var t=e.keyCode;if(e.altKey&&!e.ctrlKey||e.metaKey||t>=Nc.F1&&t<=Nc.F12)return!1;switch(t){case Nc.ALT:case Nc.CAPS_LOCK:case Nc.CONTEXT_MENU:case Nc.CTRL:case Nc.DOWN:case Nc.END:case Nc.ESC:case Nc.HOME:case Nc.INSERT:case Nc.LEFT:case Nc.MAC_FF_META:case Nc.META:case Nc.NUMLOCK:case Nc.NUM_CENTER:case Nc.PAGE_DOWN:case Nc.PAGE_UP:case Nc.PAUSE:case Nc.PRINT_SCREEN:case Nc.RIGHT:case Nc.SHIFT:case Nc.UP:case Nc.WIN_KEY:case Nc.WIN_KEY_RIGHT:return!1;default:return!0}},isCharacterKey:function(e){if(e>=Nc.ZERO&&e<=Nc.NINE)return!0;if(e>=Nc.NUM_ZERO&&e<=Nc.NUM_MULTIPLY)return!0;if(e>=Nc.A&&e<=Nc.Z)return!0;if(-1!==window.navigator.userAgent.indexOf("WebKit")&&0===e)return!0;switch(e){case Nc.SPACE:case Nc.QUESTION_MARK:case Nc.NUM_PLUS:case Nc.NUM_MINUS:case Nc.NUM_PERIOD:case Nc.NUM_DIVISION:case Nc.SEMICOLON:case Nc.DASH:case Nc.EQUALS:case Nc.COMMA:case Nc.PERIOD:case Nc.SLASH:case Nc.APOSTROPHE:case Nc.SINGLE_QUOTE:case Nc.OPEN_SQUARE_BRACKET:case Nc.BACKSLASH:case Nc.CLOSE_SQUARE_BRACKET:return!0;default:return!1}}};const Tc=Nc;var Rc=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const Ac={border:0,background:"transparent",padding:0,lineHeight:"inherit",display:"inline-flex"},Oc=o.forwardRef(((e,t)=>{const{style:n,noStyle:r,disabled:a,tabIndex:i=0}=e,s=Rc(e,["style","noStyle","disabled","tabIndex"]);let c={};return r||(c=Object.assign({},Ac)),a&&(c.pointerEvents="none"),c=Object.assign(Object.assign({},c),n),o.createElement("div",Object.assign({role:"button",tabIndex:i,ref:t},s,{onKeyDown:e=>{const{keyCode:t}=e;t===Tc.ENTER&&e.preventDefault()},onKeyUp:t=>{const{keyCode:n}=t,{onClick:r}=e;n===Tc.ENTER&&r&&r()},style:c}))})),Fc=Oc,_c=(0,o.createContext)(void 0);const Dc={items_per_page:"/ page",jump_to:"Go to",jump_to_confirm:"confirm",page:"Page",prev_page:"Previous Page",next_page:"Next Page",prev_5:"Previous 5 Pages",next_5:"Next 5 Pages",prev_3:"Previous 3 Pages",next_3:"Next 3 Pages",page_size:"Page Size"};const Mc={locale:"en_US",today:"Today",now:"Now",backToToday:"Back to today",ok:"OK",clear:"Clear",month:"Month",year:"Year",timeSelect:"select time",dateSelect:"select date",weekSelect:"Choose a week",monthSelect:"Choose a month",yearSelect:"Choose a year",decadeSelect:"Choose a decade",yearFormat:"YYYY",dateFormat:"M/D/YYYY",dayFormat:"D",dateTimeFormat:"M/D/YYYY HH:mm:ss",monthBeforeYear:!0,previousMonth:"Previous month (PageUp)",nextMonth:"Next month (PageDown)",previousYear:"Last year (Control + left)",nextYear:"Next year (Control + right)",previousDecade:"Last decade",nextDecade:"Next decade",previousCentury:"Last century",nextCentury:"Next century"},Pc={placeholder:"Select time",rangePlaceholder:["Start time","End time"]},Lc={lang:Object.assign({placeholder:"Select date",yearPlaceholder:"Select year",quarterPlaceholder:"Select quarter",monthPlaceholder:"Select month",weekPlaceholder:"Select week",rangePlaceholder:["Start date","End date"],rangeYearPlaceholder:["Start year","End year"],rangeQuarterPlaceholder:["Start quarter","End quarter"],rangeMonthPlaceholder:["Start month","End month"],rangeWeekPlaceholder:["Start week","End week"]},Mc),timePickerLocale:Object.assign({},Pc)},zc="${label} is not a valid ${type}",Bc={locale:"en",Pagination:Dc,DatePicker:Lc,TimePicker:Pc,Calendar:Lc,global:{placeholder:"Please select"},Table:{filterTitle:"Filter menu",filterConfirm:"OK",filterReset:"Reset",filterEmptyText:"No filters",filterCheckall:"Select all items",filterSearchPlaceholder:"Search in filters",emptyText:"No data",selectAll:"Select current page",selectInvert:"Invert current page",selectNone:"Clear all data",selectionAll:"Select all data",sortTitle:"Sort",expand:"Expand row",collapse:"Collapse row",triggerDesc:"Click to sort descending",triggerAsc:"Click to sort ascending",cancelSort:"Click to cancel sorting"},Tour:{Next:"Next",Previous:"Previous",Finish:"Finish"},Modal:{okText:"OK",cancelText:"Cancel",justOkText:"OK"},Popconfirm:{okText:"OK",cancelText:"Cancel"},Transfer:{titles:["",""],searchPlaceholder:"Search here",itemUnit:"item",itemsUnit:"items",remove:"Remove",selectCurrent:"Select current page",removeCurrent:"Remove current page",selectAll:"Select all data",deselectAll:"Deselect all data",removeAll:"Remove all data",selectInvert:"Invert current page"},Upload:{uploading:"Uploading...",removeFile:"Remove file",uploadError:"Upload error",previewFile:"Preview file",downloadFile:"Download file"},Empty:{description:"No data"},Icon:{icon:"icon"},Text:{edit:"Edit",copy:"Copy",copied:"Copied",expand:"Expand",collapse:"Collapse"},Form:{optional:"(optional)",defaultValidateMessages:{default:"Field validation error for ${label}",required:"Please enter ${label}",enum:"${label} must be one of [${enum}]",whitespace:"${label} cannot be a blank character",date:{format:"${label} date format is invalid",parse:"${label} cannot be converted to a date",invalid:"${label} is an invalid date"},types:{string:zc,method:zc,array:zc,object:zc,number:zc,date:zc,boolean:zc,integer:zc,float:zc,regexp:zc,email:zc,url:zc,hex:zc},string:{len:"${label} must be ${len} characters",min:"${label} must be at least ${min} characters",max:"${label} must be up to ${max} characters",range:"${label} must be between ${min}-${max} characters"},number:{len:"${label} must be equal to ${len}",min:"${label} must be minimum ${min}",max:"${label} must be maximum ${max}",range:"${label} must be between ${min}-${max}"},array:{len:"Must be ${len} ${label}",min:"At least ${min} ${label}",max:"At most ${max} ${label}",range:"The amount of ${label} must be between ${min}-${max}"},pattern:{mismatch:"${label} does not match the pattern ${pattern}"}}},Image:{preview:"Preview"},QRCode:{expired:"QR code expired",refresh:"Refresh",scanned:"Scanned"},ColorPicker:{presetEmpty:"Empty"}},Wc=(e,t)=>{const n=o.useContext(_c),r=o.useMemo((()=>{var r;const a=t||Bc[e],o=null!==(r=null===n||void 0===n?void 0:n[e])&&void 0!==r?r:{};return Object.assign(Object.assign({},"function"===typeof a?a():a),o||{})}),[e,t,n]);return[r,o.useMemo((()=>{const e=null===n||void 0===n?void 0:n.locale;return(null===n||void 0===n?void 0:n.exist)&&!e?Bc.locale:e}),[n])]};function Uc(e){var t=e.children,n=e.prefixCls,r=e.id,a=e.overlayInnerStyle,i=e.className,s=e.style;return o.createElement("div",{className:cr()("".concat(n,"-content"),i),style:s},o.createElement("div",{className:"".concat(n,"-inner"),id:r,role:"tooltip",style:a},"function"===typeof t?t():t))}const Vc=o.createContext(null);var jc=[];function Hc(e){var t="rc-scrollbar-measure-".concat(Math.random().toString(36).substring(7)),n=document.createElement("div");n.id=t;var r,a,o=n.style;if(o.position="absolute",o.left="0",o.top="0",o.width="100px",o.height="100px",o.overflow="scroll",e){var i=getComputedStyle(e);o.scrollbarColor=i.scrollbarColor,o.scrollbarWidth=i.scrollbarWidth;var s=getComputedStyle(e,"::-webkit-scrollbar"),c=parseInt(s.width,10),l=parseInt(s.height,10);try{var u=c?"width: ".concat(s.width,";"):"",d=l?"height: ".concat(s.height,";"):"";_r("\n#".concat(t,"::-webkit-scrollbar {\n").concat(u,"\n").concat(d,"\n}"),t)}catch(f0){console.error(f0),r=c,a=l}}document.body.appendChild(n);var h=e&&r&&!isNaN(r)?r:n.offsetWidth-n.clientWidth,p=e&&a&&!isNaN(a)?a:n.offsetHeight-n.clientHeight;return document.body.removeChild(n),Fr(t),{width:h,height:p}}var Gc="rc-util-locker-".concat(Date.now()),qc=0;function Kc(e){var t=!!e,n=mr(o.useState((function(){return qc+=1,"".concat(Gc,"_").concat(qc)})),1)[0];wa((function(){if(t){var e=(a=document.body,"undefined"!==typeof document&&a&&a instanceof Element?Hc(a):{width:0,height:0}).width,r=document.body.scrollHeight>(window.innerHeight||document.documentElement.clientHeight)&&window.innerWidth>document.body.offsetWidth;_r("\nhtml body {\n  overflow-y: hidden;\n  ".concat(r?"width: calc(100% - ".concat(e,"px);"):"","\n}"),n)}else Fr(n);var a;return function(){Fr(n)}}),[t,n])}var Xc=!1;var $c=function(e){return!1!==e&&(kr()&&e?"string"===typeof e?document.querySelector(e):"function"===typeof e?e():e:null)},Yc=o.forwardRef((function(e,t){var n=e.open,r=e.autoLock,a=e.getContainer,i=(e.debug,e.autoDestroy),s=void 0===i||i,c=e.children,u=mr(o.useState(n),2),d=u[0],h=u[1],p=d||n;o.useEffect((function(){(s||n)&&h(n)}),[n,s]);var f=mr(o.useState((function(){return $c(a)})),2),g=f[0],m=f[1];o.useEffect((function(){var e=$c(a);m(null!==e&&void 0!==e?e:null)}));var v=function(e,t){var n=mr(o.useState((function(){return kr()?document.createElement("div"):null})),1)[0],r=o.useRef(!1),a=o.useContext(Vc),i=mr(o.useState(jc),2),s=i[0],c=i[1],l=a||(r.current?void 0:function(e){c((function(t){return[e].concat(br(t))}))});function u(){n.parentElement||document.body.appendChild(n),r.current=!0}function d(){var e;null===(e=n.parentElement)||void 0===e||e.removeChild(n),r.current=!1}return wa((function(){return e?a?a(u):u():d(),d}),[e]),wa((function(){s.length&&(s.forEach((function(e){return e()})),c(jc))}),[s]),[n,l]}(p&&!g),b=mr(v,2),y=b[0],x=b[1],w=null!==g&&void 0!==g?g:y;Kc(r&&n&&kr()&&(w===y||w===document.body));var k=null;c&&Ni(c)&&t&&(k=c.ref);var S=Ei(k,t);if(!p||!kr()||void 0===g)return null;var C,I=!1===w||("boolean"===typeof C&&(Xc=C),Xc),E=c;return t&&(E=o.cloneElement(c,{ref:S})),o.createElement(Vc.Provider,{value:x},I?E:(0,l.createPortal)(E,w))}));const Qc=Yc;var Zc=0;var Jc=xr({},i).useId;const el=Jc?function(e){var t=Jc();return e||t}:function(e){var t=mr(o.useState("ssr-id"),2),n=t[0],r=t[1];return o.useEffect((function(){var e=Zc;Zc+=1,r("rc_unique_".concat(e))}),[]),e||n};var tl=["children"],nl=o.createContext({});function rl(e){var t=e.children,n=Cs(e,tl);return o.createElement(nl.Provider,{value:n},t)}var al=function(e){Hi(n,e);var t=vc(n);function n(){return jr(this,n),t.apply(this,arguments)}return Gr(n,[{key:"render",value:function(){return this.props.children}}]),n}(o.Component);const ol=al;var il="none",sl="appear",cl="enter",ll="leave",ul="none",dl="prepare",hl="start",pl="active",fl="end",gl="prepared";function ml(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit".concat(e)]="webkit".concat(t),n["Moz".concat(e)]="moz".concat(t),n["ms".concat(e)]="MS".concat(t),n["O".concat(e)]="o".concat(t.toLowerCase()),n}var vl=function(e,t){var n={animationend:ml("Animation","AnimationEnd"),transitionend:ml("Transition","TransitionEnd")};return e&&("AnimationEvent"in t||delete n.animationend.animation,"TransitionEvent"in t||delete n.transitionend.transition),n}(kr(),"undefined"!==typeof window?window:{}),bl={};if(kr()){var yl=document.createElement("div");bl=yl.style}var xl={};function wl(e){if(xl[e])return xl[e];var t=vl[e];if(t)for(var n=Object.keys(t),r=n.length,a=0;a<r;a+=1){var o=n[a];if(Object.prototype.hasOwnProperty.call(t,o)&&o in bl)return xl[e]=t[o],xl[e]}return""}var kl=wl("animationend"),Sl=wl("transitionend"),Cl=!(!kl||!Sl),Il=kl||"animationend",El=Sl||"transitionend";function Nl(e,t){if(!e)return null;if("object"===lr(e)){var n=t.replace(/-\w/g,(function(e){return e[1].toUpperCase()}));return e[n]}return"".concat(e,"-").concat(t)}const Tl=function(e){var t=(0,o.useRef)();function n(t){t&&(t.removeEventListener(El,e),t.removeEventListener(Il,e))}return o.useEffect((function(){return function(){n(t.current)}}),[]),[function(r){t.current&&t.current!==r&&n(t.current),r&&r!==t.current&&(r.addEventListener(El,e),r.addEventListener(Il,e),t.current=r)},n]};const Rl=kr()?o.useLayoutEffect:o.useEffect;var Al=function(e){return+setTimeout(e,16)},Ol=function(e){return clearTimeout(e)};"undefined"!==typeof window&&"requestAnimationFrame"in window&&(Al=function(e){return window.requestAnimationFrame(e)},Ol=function(e){return window.cancelAnimationFrame(e)});var Fl=0,_l=new Map;function Dl(e){_l.delete(e)}var Ml=function(e){var t=Fl+=1;return function n(r){if(0===r)Dl(t),e();else{var a=Al((function(){n(r-1)}));_l.set(t,a)}}(arguments.length>1&&void 0!==arguments[1]?arguments[1]:1),t};Ml.cancel=function(e){var t=_l.get(e);return Dl(e),Ol(t)};const Pl=Ml;var Ll=[dl,hl,pl,fl],zl=[dl,gl],Bl=!1,Wl=!0;function Ul(e){return e===pl||e===fl}const Vl=function(e,t,n){var r=mr(xi(ul),2),a=r[0],i=r[1],s=function(){var e=o.useRef(null);function t(){Pl.cancel(e.current)}return o.useEffect((function(){return function(){t()}}),[]),[function n(r){var a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;t();var o=Pl((function(){a<=1?r({isCanceled:function(){return o!==e.current}}):n(r,a-1)}));e.current=o},t]}(),c=mr(s,2),l=c[0],u=c[1];var d=t?zl:Ll;return Rl((function(){if(a!==ul&&a!==fl){var e=d.indexOf(a),t=d[e+1],r=n(a);r===Bl?i(t,!0):t&&l((function(e){function n(){e.isCanceled()||i(t,!0)}!0===r?n():Promise.resolve(r).then(n)}))}}),[e,a]),o.useEffect((function(){return function(){u()}}),[]),[function(){i(dl,!0)},a]};const jl=function(e){var t=e;"object"===lr(e)&&(t=e.transitionSupport);var n=o.forwardRef((function(e,n){var r=e.visible,a=void 0===r||r,i=e.removeOnLeave,s=void 0===i||i,c=e.forceRender,l=e.children,u=e.motionName,d=e.leavedClassName,h=e.eventProps,p=function(e,n){return!(!e.motionName||!t||!1===n)}(e,o.useContext(nl).motion),f=(0,o.useRef)(),g=(0,o.useRef)();var m=function(e,t,n,r){var a=r.motionEnter,i=void 0===a||a,s=r.motionAppear,c=void 0===s||s,l=r.motionLeave,u=void 0===l||l,d=r.motionDeadline,h=r.motionLeaveImmediately,p=r.onAppearPrepare,f=r.onEnterPrepare,g=r.onLeavePrepare,m=r.onAppearStart,v=r.onEnterStart,b=r.onLeaveStart,y=r.onAppearActive,x=r.onEnterActive,w=r.onLeaveActive,k=r.onAppearEnd,S=r.onEnterEnd,C=r.onLeaveEnd,I=r.onVisibleChanged,E=mr(xi(),2),N=E[0],T=E[1],R=mr(xi(il),2),A=R[0],O=R[1],F=mr(xi(null),2),_=F[0],D=F[1],M=(0,o.useRef)(!1),P=(0,o.useRef)(null);function L(){return n()}var z=(0,o.useRef)(!1);function B(){O(il,!0),D(null,!0)}var W=yi((function(e){if(A!==il){var t=L();if(!e||e.deadline||e.target===t){var n,r=z.current;A===sl&&r?n=null===k||void 0===k?void 0:k(t,e):A===cl&&r?n=null===S||void 0===S?void 0:S(t,e):A===ll&&r&&(n=null===C||void 0===C?void 0:C(t,e)),r&&!1!==n&&B()}}})),U=mr(Tl(W),1)[0],V=function(e){switch(e){case sl:return dr(dr(dr({},dl,p),hl,m),pl,y);case cl:return dr(dr(dr({},dl,f),hl,v),pl,x);case ll:return dr(dr(dr({},dl,g),hl,b),pl,w);default:return{}}},j=o.useMemo((function(){return V(A)}),[A]),H=mr(Vl(A,!e,(function(e){if(e===dl){var t=j[dl];return t?t(L()):Bl}var n;return q in j&&D((null===(n=j[q])||void 0===n?void 0:n.call(j,L(),null))||null),q===pl&&A!==il&&(U(L()),d>0&&(clearTimeout(P.current),P.current=setTimeout((function(){W({deadline:!0})}),d))),q===gl&&B(),Wl})),2),G=H[0],q=H[1],K=Ul(q);z.current=K,Rl((function(){T(t);var n,r=M.current;M.current=!0,!r&&t&&c&&(n=sl),r&&t&&i&&(n=cl),(r&&!t&&u||!r&&h&&!t&&u)&&(n=ll);var a=V(n);n&&(e||a[dl])?(O(n),G()):O(il)}),[t]),(0,o.useEffect)((function(){(A===sl&&!c||A===cl&&!i||A===ll&&!u)&&O(il)}),[c,i,u]),(0,o.useEffect)((function(){return function(){M.current=!1,clearTimeout(P.current)}}),[]);var X=o.useRef(!1);(0,o.useEffect)((function(){N&&(X.current=!0),void 0!==N&&A===il&&((X.current||N)&&(null===I||void 0===I||I(N)),X.current=!0)}),[N,A]);var $=_;return j[dl]&&q===hl&&($=xr({transition:"none"},$)),[A,q,$,null!==N&&void 0!==N?N:t]}(p,a,(function(){try{return f.current instanceof HTMLElement?f.current:Gs(g.current)}catch(f0){return null}}),e),v=mr(m,4),b=v[0],y=v[1],x=v[2],w=v[3],k=o.useRef(w);w&&(k.current=!0);var S,C=o.useCallback((function(e){f.current=e,Ci(n,e)}),[n]),I=xr(xr({},h),{},{visible:a});if(l)if(b===il)S=w?l(xr({},I),C):!s&&k.current&&d?l(xr(xr({},I),{},{className:d}),C):c||!s&&!d?l(xr(xr({},I),{},{style:{display:"none"}}),C):null;else{var E;y===dl?E="prepare":Ul(y)?E="active":y===hl&&(E="start");var N=Nl(u,"".concat(b,"-").concat(E));S=l(xr(xr({},I),{},{className:cr()(Nl(u,b),dr(dr({},N,N&&E),u,"string"===typeof u)),style:x}),C)}else S=null;o.isValidElement(S)&&Ni(S)&&(S.ref||(S=o.cloneElement(S,{ref:C})));return o.createElement(ol,{ref:g},S)}));return n.displayName="CSSMotion",n}(Cl);var Hl="add",Gl="keep",ql="remove",Kl="removed";function Xl(e){var t;return xr(xr({},t=e&&"object"===lr(e)&&"key"in e?e:{key:e}),{},{key:String(t.key)})}function $l(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]).map(Xl)}var Yl=["component","children","onVisibleChanged","onAllRemoved"],Ql=["status"],Zl=["eventProps","visible","children","motionName","motionAppear","motionEnter","motionLeave","motionLeaveImmediately","motionDeadline","removeOnLeave","leavedClassName","onAppearPrepare","onAppearStart","onAppearActive","onAppearEnd","onEnterStart","onEnterActive","onEnterEnd","onLeaveStart","onLeaveActive","onLeaveEnd"];const Jl=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:jl,n=function(e){Hi(r,e);var n=vc(r);function r(){var e;jr(this,r);for(var t=arguments.length,a=new Array(t),o=0;o<t;o++)a[o]=arguments[o];return dr(Wi(e=n.call.apply(n,[this].concat(a))),"state",{keyEntities:[]}),dr(Wi(e),"removeKey",(function(t){var n=e.state.keyEntities.map((function(e){return e.key!==t?e:xr(xr({},e),{},{status:Kl})}));return e.setState({keyEntities:n}),n.filter((function(e){return e.status!==Kl})).length})),e}return Gr(r,[{key:"render",value:function(){var e=this,n=this.state.keyEntities,r=this.props,a=r.component,i=r.children,s=r.onVisibleChanged,c=r.onAllRemoved,l=Cs(r,Yl),u=a||o.Fragment,d={};return Zl.forEach((function(e){d[e]=l[e],delete l[e]})),delete l.keys,o.createElement(u,l,n.map((function(n,r){var a=n.status,l=Cs(n,Ql),u=a===Hl||a===Gl;return o.createElement(t,Pa({},d,{key:l.key,visible:u,eventProps:l,onVisibleChanged:function(t){(null===s||void 0===s||s(t,{key:l.key}),t)||0===e.removeKey(l.key)&&c&&c()}}),(function(e,t){return i(xr(xr({},e),{},{index:r}),t)}))})))}}],[{key:"getDerivedStateFromProps",value:function(e,t){var n=e.keys,r=t.keyEntities,a=$l(n),o=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=[],r=0,a=t.length,o=$l(e),i=$l(t);o.forEach((function(e){for(var t=!1,o=r;o<a;o+=1){var s=i[o];if(s.key===e.key){r<o&&(n=n.concat(i.slice(r,o).map((function(e){return xr(xr({},e),{},{status:Hl})}))),r=o),n.push(xr(xr({},s),{},{status:Gl})),r+=1,t=!0;break}}t||n.push(xr(xr({},e),{},{status:ql}))})),r<a&&(n=n.concat(i.slice(r).map((function(e){return xr(xr({},e),{},{status:Hl})}))));var s={};return n.forEach((function(e){var t=e.key;s[t]=(s[t]||0)+1})),Object.keys(s).filter((function(e){return s[e]>1})).forEach((function(e){(n=n.filter((function(t){var n=t.key,r=t.status;return n!==e||r!==ql}))).forEach((function(t){t.key===e&&(t.status=Gl)}))})),n}(r,a);return{keyEntities:o.filter((function(e){var t=r.find((function(t){var n=t.key;return e.key===n}));return!t||t.status!==Kl||e.status!==ql}))}}}]),r}(o.Component);return dr(n,"defaultProps",{component:"div"}),n}(Cl),eu=jl;function tu(e){var t=e.prefixCls,n=e.align,r=e.arrow,a=e.arrowPos,i=r||{},s=i.className,c=i.content,l=a.x,u=void 0===l?0:l,d=a.y,h=void 0===d?0:d,p=o.useRef();if(!n||!n.points)return null;var f={position:"absolute"};if(!1!==n.autoArrow){var g=n.points[0],m=n.points[1],v=g[0],b=g[1],y=m[0],x=m[1];v!==y&&["t","b"].includes(v)?"t"===v?f.top=0:f.bottom=0:f.top=h,b!==x&&["l","r"].includes(b)?"l"===b?f.left=0:f.right=0:f.left=u}return o.createElement("div",{ref:p,className:cr()("".concat(t,"-arrow"),s),style:f},c)}function nu(e){var t=e.prefixCls,n=e.open,r=e.zIndex,a=e.mask,i=e.motion;return a?o.createElement(eu,Pa({},i,{motionAppear:!0,visible:n,removeOnLeave:!0}),(function(e){var n=e.className;return o.createElement("div",{style:{zIndex:r},className:cr()("".concat(t,"-mask"),n)})})):null}var ru=o.memo((function(e){return e.children}),(function(e,t){return t.cache}));const au=ru;var ou=o.forwardRef((function(e,t){var n=e.popup,r=e.className,a=e.prefixCls,i=e.style,s=e.target,c=e.onVisibleChanged,l=e.open,u=e.keepDom,d=e.fresh,h=e.onClick,p=e.mask,f=e.arrow,g=e.arrowPos,m=e.align,v=e.motion,b=e.maskMotion,y=e.forceRender,x=e.getPopupContainer,w=e.autoDestroy,k=e.portal,S=e.zIndex,C=e.onMouseEnter,I=e.onMouseLeave,E=e.onPointerEnter,N=e.ready,T=e.offsetX,R=e.offsetY,A=e.offsetR,O=e.offsetB,F=e.onAlign,_=e.onPrepare,D=e.stretch,M=e.targetWidth,P=e.targetHeight,L="function"===typeof n?n():n,z=l||u,B=(null===x||void 0===x?void 0:x.length)>0,W=mr(o.useState(!x||!B),2),U=W[0],V=W[1];if(wa((function(){!U&&B&&s&&V(!0)}),[U,B,s]),!U)return null;var j="auto",H={left:"-1000vw",top:"-1000vh",right:j,bottom:j};if(N||!l){var G,q=m.points,K=m.dynamicInset||(null===(G=m._experimental)||void 0===G?void 0:G.dynamicInset),X=K&&"r"===q[0][1],$=K&&"b"===q[0][0];X?(H.right=A,H.left=j):(H.left=T,H.right=j),$?(H.bottom=O,H.top=j):(H.top=R,H.bottom=j)}var Y={};return D&&(D.includes("height")&&P?Y.height=P:D.includes("minHeight")&&P&&(Y.minHeight=P),D.includes("width")&&M?Y.width=M:D.includes("minWidth")&&M&&(Y.minWidth=M)),l||(Y.pointerEvents="none"),o.createElement(k,{open:y||z,getContainer:x&&function(){return x(s)},autoDestroy:w},o.createElement(nu,{prefixCls:a,open:l,zIndex:S,mask:p,motion:b}),o.createElement(Sc,{onResize:F,disabled:!l},(function(e){return o.createElement(eu,Pa({motionAppear:!0,motionEnter:!0,motionLeave:!0,removeOnLeave:!1,forceRender:y,leavedClassName:"".concat(a,"-hidden")},v,{onAppearPrepare:_,onEnterPrepare:_,visible:l,onVisibleChanged:function(e){var t;null===v||void 0===v||null===(t=v.onVisibleChanged)||void 0===t||t.call(v,e),c(e)}}),(function(n,s){var c=n.className,u=n.style,p=cr()(a,c,r);return o.createElement("div",{ref:Ii(e,t,s),className:p,style:xr(xr(xr(xr({"--arrow-x":"".concat(g.x||0,"px"),"--arrow-y":"".concat(g.y||0,"px")},H),Y),u),{},{boxSizing:"border-box",zIndex:S},i),onMouseEnter:C,onMouseLeave:I,onPointerEnter:E,onClick:h},f&&o.createElement(tu,{prefixCls:a,arrow:f,arrowPos:g,align:m}),o.createElement(au,{cache:!l&&!d},L))}))})))}));const iu=ou;var su=o.forwardRef((function(e,t){var n=e.children,r=e.getTriggerDOMNode,a=Ni(n),i=o.useCallback((function(e){Ci(t,r?r(e):e)}),[r]),s=Ei(i,n.ref);return a?o.cloneElement(n,{ref:s}):n}));const cu=su;const lu=o.createContext(null);function uu(e){return e?Array.isArray(e)?e:[e]:[]}const du=function(e){if(!e)return!1;if(e instanceof Element){if(e.offsetParent)return!0;if(e.getBBox){var t=e.getBBox(),n=t.width,r=t.height;if(n||r)return!0}if(e.getBoundingClientRect){var a=e.getBoundingClientRect(),o=a.width,i=a.height;if(o||i)return!0}}return!1};function hu(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return(arguments.length>2?arguments[2]:void 0)?e[0]===t[0]:e[0]===t[0]&&e[1]===t[1]}function pu(e,t,n,r){return t||(n?{motionName:"".concat(e,"-").concat(n)}:r?{motionName:r}:null)}function fu(e){return e.ownerDocument.defaultView}function gu(e){for(var t=[],n=null===e||void 0===e?void 0:e.parentElement,r=["hidden","scroll","clip","auto"];n;){var a=fu(n).getComputedStyle(n);[a.overflowX,a.overflowY,a.overflow].some((function(e){return r.includes(e)}))&&t.push(n),n=n.parentElement}return t}function mu(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Number.isNaN(e)?t:e}function vu(e){return mu(parseFloat(e),0)}function bu(e,t){var n=xr({},e);return(t||[]).forEach((function(e){if(!(e instanceof HTMLBodyElement||e instanceof HTMLHtmlElement)){var t=fu(e).getComputedStyle(e),r=t.overflow,a=t.overflowClipMargin,o=t.borderTopWidth,i=t.borderBottomWidth,s=t.borderLeftWidth,c=t.borderRightWidth,l=e.getBoundingClientRect(),u=e.offsetHeight,d=e.clientHeight,h=e.offsetWidth,p=e.clientWidth,f=vu(o),g=vu(i),m=vu(s),v=vu(c),b=mu(Math.round(l.width/h*1e3)/1e3),y=mu(Math.round(l.height/u*1e3)/1e3),x=(h-p-m-v)*b,w=(u-d-f-g)*y,k=f*y,S=g*y,C=m*b,I=v*b,E=0,N=0;if("clip"===r){var T=vu(a);E=T*b,N=T*y}var R=l.x+C-E,A=l.y+k-N,O=R+l.width+2*E-C-I-x,F=A+l.height+2*N-k-S-w;n.left=Math.max(n.left,R),n.top=Math.max(n.top,A),n.right=Math.min(n.right,O),n.bottom=Math.min(n.bottom,F)}})),n}function yu(e){var t="".concat(arguments.length>1&&void 0!==arguments[1]?arguments[1]:0),n=t.match(/^(.*)\%$/);return n?e*(parseFloat(n[1])/100):parseFloat(t)}function xu(e,t){var n=mr(t||[],2),r=n[0],a=n[1];return[yu(e.width,r),yu(e.height,a)]}function wu(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return[e[0],e[1]]}function ku(e,t){var n,r=t[0],a=t[1];return n="t"===r?e.y:"b"===r?e.y+e.height:e.y+e.height/2,{x:"l"===a?e.x:"r"===a?e.x+e.width:e.x+e.width/2,y:n}}function Su(e,t){var n={t:"b",b:"t",l:"r",r:"l"};return e.map((function(e,r){return r===t?n[e]||"c":e})).join("")}var Cu=["prefixCls","children","action","showAction","hideAction","popupVisible","defaultPopupVisible","onPopupVisibleChange","afterPopupVisibleChange","mouseEnterDelay","mouseLeaveDelay","focusDelay","blurDelay","mask","maskClosable","getPopupContainer","forceRender","autoDestroy","destroyPopupOnHide","popup","popupClassName","popupStyle","popupPlacement","builtinPlacements","popupAlign","zIndex","stretch","getPopupClassNameFromAlign","fresh","alignPoint","onPopupClick","onPopupAlign","arrow","popupMotion","maskMotion","popupTransitionName","popupAnimation","maskTransitionName","maskAnimation","className","getTriggerDOMNode"];const Iu=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Qc,t=o.forwardRef((function(t,n){var r=t.prefixCls,a=void 0===r?"rc-trigger-popup":r,i=t.children,s=t.action,c=void 0===s?"hover":s,l=t.showAction,u=t.hideAction,d=t.popupVisible,h=t.defaultPopupVisible,p=t.onPopupVisibleChange,f=t.afterPopupVisibleChange,g=t.mouseEnterDelay,m=t.mouseLeaveDelay,v=void 0===m?.1:m,b=t.focusDelay,y=t.blurDelay,x=t.mask,w=t.maskClosable,k=void 0===w||w,S=t.getPopupContainer,C=t.forceRender,I=t.autoDestroy,E=t.destroyPopupOnHide,N=t.popup,T=t.popupClassName,R=t.popupStyle,A=t.popupPlacement,O=t.builtinPlacements,F=void 0===O?{}:O,_=t.popupAlign,D=t.zIndex,M=t.stretch,P=t.getPopupClassNameFromAlign,L=t.fresh,z=t.alignPoint,B=t.onPopupClick,W=t.onPopupAlign,U=t.arrow,V=t.popupMotion,j=t.maskMotion,H=t.popupTransitionName,G=t.popupAnimation,q=t.maskTransitionName,K=t.maskAnimation,X=t.className,$=t.getTriggerDOMNode,Y=Cs(t,Cu),Q=I||E||!1,Z=mr(o.useState(!1),2),J=Z[0],ee=Z[1];wa((function(){ee(function(){if("undefined"===typeof navigator||"undefined"===typeof window)return!1;var e=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(null===e||void 0===e?void 0:e.substr(0,4))}())}),[]);var te=o.useRef({}),ne=o.useContext(lu),re=o.useMemo((function(){return{registerSubPopup:function(e,t){te.current[e]=t,null===ne||void 0===ne||ne.registerSubPopup(e,t)}}}),[ne]),ae=el(),oe=mr(o.useState(null),2),ie=oe[0],se=oe[1],ce=o.useRef(null),le=yi((function(e){ce.current=e,Hs(e)&&ie!==e&&se(e),null===ne||void 0===ne||ne.registerSubPopup(ae,e)})),ue=mr(o.useState(null),2),de=ue[0],he=ue[1],pe=o.useRef(null),fe=yi((function(e){Hs(e)&&de!==e&&(he(e),pe.current=e)})),ge=o.Children.only(i),me=(null===ge||void 0===ge?void 0:ge.props)||{},ve={},be=yi((function(e){var t,n,r=de;return(null===r||void 0===r?void 0:r.contains(e))||(null===(t=Ns(r))||void 0===t?void 0:t.host)===e||e===r||(null===ie||void 0===ie?void 0:ie.contains(e))||(null===(n=Ns(ie))||void 0===n?void 0:n.host)===e||e===ie||Object.values(te.current).some((function(t){return(null===t||void 0===t?void 0:t.contains(e))||e===t}))})),ye=pu(a,V,G,H),xe=pu(a,j,K,q),we=mr(o.useState(h||!1),2),ke=we[0],Se=we[1],Ce=null!==d&&void 0!==d?d:ke,Ie=yi((function(e){void 0===d&&Se(e)}));wa((function(){Se(d||!1)}),[d]);var Ee=o.useRef(Ce);Ee.current=Ce;var Ne=o.useRef([]);Ne.current=[];var Te=yi((function(e){var t;Ie(e),(null!==(t=Ne.current[Ne.current.length-1])&&void 0!==t?t:Ce)!==e&&(Ne.current.push(e),null===p||void 0===p||p(e))})),Re=o.useRef(),Ae=function(){clearTimeout(Re.current)},Oe=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Ae(),0===t?Te(e):Re.current=setTimeout((function(){Te(e)}),1e3*t)};o.useEffect((function(){return Ae}),[]);var Fe=mr(o.useState(!1),2),_e=Fe[0],De=Fe[1];wa((function(e){e&&!Ce||De(!0)}),[Ce]);var Me=mr(o.useState(null),2),Pe=Me[0],Le=Me[1],ze=mr(o.useState([0,0]),2),Be=ze[0],We=ze[1],Ue=function(e){We([e.clientX,e.clientY])},Ve=function(e,t,n,r,a,i,s){var c=mr(o.useState({ready:!1,offsetX:0,offsetY:0,offsetR:0,offsetB:0,arrowX:0,arrowY:0,scaleX:1,scaleY:1,align:a[r]||{}}),2),l=c[0],u=c[1],d=o.useRef(0),h=o.useMemo((function(){return t?gu(t):[]}),[t]),p=o.useRef({});e||(p.current={});var f=yi((function(){if(t&&n&&e){var o,c,l,d=t,f=d.ownerDocument,g=fu(d).getComputedStyle(d),m=g.width,v=g.height,b=g.position,y=d.style.left,x=d.style.top,w=d.style.right,k=d.style.bottom,S=d.style.overflow,C=xr(xr({},a[r]),i),I=f.createElement("div");if(null===(o=d.parentElement)||void 0===o||o.appendChild(I),I.style.left="".concat(d.offsetLeft,"px"),I.style.top="".concat(d.offsetTop,"px"),I.style.position=b,I.style.height="".concat(d.offsetHeight,"px"),I.style.width="".concat(d.offsetWidth,"px"),d.style.left="0",d.style.top="0",d.style.right="auto",d.style.bottom="auto",d.style.overflow="hidden",Array.isArray(n))l={x:n[0],y:n[1],width:0,height:0};else{var E=n.getBoundingClientRect();l={x:E.x,y:E.y,width:E.width,height:E.height}}var N=d.getBoundingClientRect(),T=f.documentElement,R=T.clientWidth,A=T.clientHeight,O=T.scrollWidth,F=T.scrollHeight,_=T.scrollTop,D=T.scrollLeft,M=N.height,P=N.width,L=l.height,z=l.width,B={left:0,top:0,right:R,bottom:A},W={left:-D,top:-_,right:O-D,bottom:F-_},U=C.htmlRegion,V="visible",j="visibleFirst";"scroll"!==U&&U!==j&&(U=V);var H=U===j,G=bu(W,h),q=bu(B,h),K=U===V?q:G,X=H?q:K;d.style.left="auto",d.style.top="auto",d.style.right="0",d.style.bottom="0";var $=d.getBoundingClientRect();d.style.left=y,d.style.top=x,d.style.right=w,d.style.bottom=k,d.style.overflow=S,null===(c=d.parentElement)||void 0===c||c.removeChild(I);var Y=mu(Math.round(P/parseFloat(m)*1e3)/1e3),Q=mu(Math.round(M/parseFloat(v)*1e3)/1e3);if(0===Y||0===Q||Hs(n)&&!du(n))return;var Z=C.offset,J=C.targetOffset,ee=mr(xu(N,Z),2),te=ee[0],ne=ee[1],re=mr(xu(l,J),2),ae=re[0],oe=re[1];l.x-=ae,l.y-=oe;var ie=mr(C.points||[],2),se=ie[0],ce=wu(ie[1]),le=wu(se),ue=ku(l,ce),de=ku(N,le),he=xr({},C),pe=ue.x-de.x+te,fe=ue.y-de.y+ne;function st(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:K,r=N.x+e,a=N.y+t,o=r+P,i=a+M,s=Math.max(r,n.left),c=Math.max(a,n.top),l=Math.min(o,n.right),u=Math.min(i,n.bottom);return Math.max(0,(l-s)*(u-c))}var ge,me,ve,be,ye=st(pe,fe),xe=st(pe,fe,q),we=ku(l,["t","l"]),ke=ku(N,["t","l"]),Se=ku(l,["b","r"]),Ce=ku(N,["b","r"]),Ie=C.overflow||{},Ee=Ie.adjustX,Ne=Ie.adjustY,Te=Ie.shiftX,Re=Ie.shiftY,Ae=function(e){return"boolean"===typeof e?e:e>=0};function ct(){ge=N.y+fe,me=ge+M,ve=N.x+pe,be=ve+P}ct();var Oe=Ae(Ne),Fe=le[0]===ce[0];if(Oe&&"t"===le[0]&&(me>X.bottom||p.current.bt)){var _e=fe;Fe?_e-=M-L:_e=we.y-Ce.y-ne;var De=st(pe,_e),Me=st(pe,_e,q);De>ye||De===ye&&(!H||Me>=xe)?(p.current.bt=!0,fe=_e,ne=-ne,he.points=[Su(le,0),Su(ce,0)]):p.current.bt=!1}if(Oe&&"b"===le[0]&&(ge<X.top||p.current.tb)){var Pe=fe;Fe?Pe+=M-L:Pe=Se.y-ke.y-ne;var Le=st(pe,Pe),ze=st(pe,Pe,q);Le>ye||Le===ye&&(!H||ze>=xe)?(p.current.tb=!0,fe=Pe,ne=-ne,he.points=[Su(le,0),Su(ce,0)]):p.current.tb=!1}var Be=Ae(Ee),We=le[1]===ce[1];if(Be&&"l"===le[1]&&(be>X.right||p.current.rl)){var Ue=pe;We?Ue-=P-z:Ue=we.x-Ce.x-te;var Ve=st(Ue,fe),je=st(Ue,fe,q);Ve>ye||Ve===ye&&(!H||je>=xe)?(p.current.rl=!0,pe=Ue,te=-te,he.points=[Su(le,1),Su(ce,1)]):p.current.rl=!1}if(Be&&"r"===le[1]&&(ve<X.left||p.current.lr)){var He=pe;We?He+=P-z:He=Se.x-ke.x-te;var Ge=st(He,fe),qe=st(He,fe,q);Ge>ye||Ge===ye&&(!H||qe>=xe)?(p.current.lr=!0,pe=He,te=-te,he.points=[Su(le,1),Su(ce,1)]):p.current.lr=!1}ct();var Ke=!0===Te?0:Te;"number"===typeof Ke&&(ve<q.left&&(pe-=ve-q.left-te,l.x+z<q.left+Ke&&(pe+=l.x-q.left+z-Ke)),be>q.right&&(pe-=be-q.right-te,l.x>q.right-Ke&&(pe+=l.x-q.right+Ke)));var Xe=!0===Re?0:Re;"number"===typeof Xe&&(ge<q.top&&(fe-=ge-q.top-ne,l.y+L<q.top+Xe&&(fe+=l.y-q.top+L-Xe)),me>q.bottom&&(fe-=me-q.bottom-ne,l.y>q.bottom-Xe&&(fe+=l.y-q.bottom+Xe)));var $e=N.x+pe,Ye=$e+P,Qe=N.y+fe,Ze=Qe+M,Je=l.x,et=Je+z,tt=l.y,nt=tt+L,rt=(Math.max($e,Je)+Math.min(Ye,et))/2-$e,at=(Math.max(Qe,tt)+Math.min(Ze,nt))/2-Qe;null===s||void 0===s||s(t,he);var ot=$.right-N.x-(pe+N.width),it=$.bottom-N.y-(fe+N.height);1===Y&&(pe=Math.round(pe),ot=Math.round(ot)),1===Q&&(fe=Math.round(fe),it=Math.round(it)),u({ready:!0,offsetX:pe/Y,offsetY:fe/Q,offsetR:ot/Y,offsetB:it/Q,arrowX:rt/Y,arrowY:at/Q,scaleX:Y,scaleY:Q,align:he})}})),g=function(){u((function(e){return xr(xr({},e),{},{ready:!1})}))};return wa(g,[r]),wa((function(){e||g()}),[e]),[l.ready,l.offsetX,l.offsetY,l.offsetR,l.offsetB,l.arrowX,l.arrowY,l.scaleX,l.scaleY,l.align,function(){d.current+=1;var e=d.current;Promise.resolve().then((function(){d.current===e&&f()}))}]}(Ce,ie,z?Be:de,A,F,_,W),je=mr(Ve,11),He=je[0],Ge=je[1],qe=je[2],Ke=je[3],Xe=je[4],$e=je[5],Ye=je[6],Qe=je[7],Ze=je[8],Je=je[9],et=je[10],tt=function(e,t,n,r){return o.useMemo((function(){var a=uu(null!==n&&void 0!==n?n:t),o=uu(null!==r&&void 0!==r?r:t),i=new Set(a),s=new Set(o);return e&&(i.has("hover")&&(i.delete("hover"),i.add("click")),s.has("hover")&&(s.delete("hover"),s.add("click"))),[i,s]}),[e,t,n,r])}(J,c,l,u),nt=mr(tt,2),rt=nt[0],at=nt[1],ot=rt.has("click"),it=at.has("click")||at.has("contextMenu"),st=yi((function(){_e||et()}));!function(e,t,n,r,a){wa((function(){if(e&&t&&n){var o=n,i=gu(t),s=gu(o),c=fu(o),l=new Set([c].concat(br(i),br(s)));function u(){r(),a()}return l.forEach((function(e){e.addEventListener("scroll",u,{passive:!0})})),c.addEventListener("resize",u,{passive:!0}),r(),function(){l.forEach((function(e){e.removeEventListener("scroll",u),c.removeEventListener("resize",u)}))}}}),[e,t,n])}(Ce,de,ie,st,(function(){Ee.current&&z&&it&&Oe(!1)})),wa((function(){st()}),[Be,A]),wa((function(){!Ce||null!==F&&void 0!==F&&F[A]||st()}),[JSON.stringify(_)]);var ct=o.useMemo((function(){var e=function(e,t,n,r){for(var a=n.points,o=Object.keys(e),i=0;i<o.length;i+=1){var s,c=o[i];if(hu(null===(s=e[c])||void 0===s?void 0:s.points,a,r))return"".concat(t,"-placement-").concat(c)}return""}(F,a,Je,z);return cr()(e,null===P||void 0===P?void 0:P(Je))}),[Je,P,F,a,z]);o.useImperativeHandle(n,(function(){return{nativeElement:pe.current,popupElement:ce.current,forceAlign:st}}));var lt=mr(o.useState(0),2),ut=lt[0],dt=lt[1],ht=mr(o.useState(0),2),pt=ht[0],ft=ht[1],gt=function(){if(M&&de){var e=de.getBoundingClientRect();dt(e.width),ft(e.height)}};function mt(e,t,n,r){ve[e]=function(a){var o;null===r||void 0===r||r(a),Oe(t,n);for(var i=arguments.length,s=new Array(i>1?i-1:0),c=1;c<i;c++)s[c-1]=arguments[c];null===(o=me[e])||void 0===o||o.call.apply(o,[me,a].concat(s))}}wa((function(){Pe&&(et(),Pe(),Le(null))}),[Pe]),(ot||it)&&(ve.onClick=function(e){var t;Ee.current&&it?Oe(!1):!Ee.current&&ot&&(Ue(e),Oe(!0));for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];null===(t=me.onClick)||void 0===t||t.call.apply(t,[me,e].concat(r))}),function(e,t,n,r,a,i,s,c){var l=o.useRef(e);l.current=e,o.useEffect((function(){if(t&&r&&(!a||i)){var e=function(e){var t=e.target;l.current&&!s(t)&&c(!1)},o=fu(r);o.addEventListener("mousedown",e,!0),o.addEventListener("contextmenu",e,!0);var u=Ns(n);return u&&(u.addEventListener("mousedown",e,!0),u.addEventListener("contextmenu",e,!0)),function(){o.removeEventListener("mousedown",e,!0),o.removeEventListener("contextmenu",e,!0),u&&(u.removeEventListener("mousedown",e,!0),u.removeEventListener("contextmenu",e,!0))}}}),[t,n,r,a,i])}(Ce,it,de,ie,x,k,be,Oe);var vt,bt,yt=rt.has("hover"),xt=at.has("hover");yt&&(mt("onMouseEnter",!0,g,(function(e){Ue(e)})),mt("onPointerEnter",!0,g,(function(e){Ue(e)})),vt=function(e){(Ce||_e)&&null!==ie&&void 0!==ie&&ie.contains(e.target)&&Oe(!0,g)},z&&(ve.onMouseMove=function(e){var t;null===(t=me.onMouseMove)||void 0===t||t.call(me,e)})),xt&&(mt("onMouseLeave",!1,v),mt("onPointerLeave",!1,v),bt=function(){Oe(!1,v)}),rt.has("focus")&&mt("onFocus",!0,b),at.has("focus")&&mt("onBlur",!1,y),rt.has("contextMenu")&&(ve.onContextMenu=function(e){var t;Ee.current&&at.has("contextMenu")?Oe(!1):(Ue(e),Oe(!0)),e.preventDefault();for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];null===(t=me.onContextMenu)||void 0===t||t.call.apply(t,[me,e].concat(r))}),X&&(ve.className=cr()(me.className,X));var wt=xr(xr({},me),ve),kt={};["onContextMenu","onClick","onMouseDown","onTouchStart","onMouseEnter","onMouseLeave","onFocus","onBlur"].forEach((function(e){Y[e]&&(kt[e]=function(){for(var t,n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];null===(t=wt[e])||void 0===t||t.call.apply(t,[wt].concat(r)),Y[e].apply(Y,r)})}));var St=o.cloneElement(ge,xr(xr({},wt),kt)),Ct={x:$e,y:Ye},It=U?xr({},!0!==U?U:{}):null;return o.createElement(o.Fragment,null,o.createElement(Sc,{disabled:!Ce,ref:fe,onResize:function(){gt(),st()}},o.createElement(cu,{getTriggerDOMNode:$},St)),o.createElement(lu.Provider,{value:re},o.createElement(iu,{portal:e,ref:le,prefixCls:a,popup:N,className:cr()(T,ct),style:R,target:de,onMouseEnter:vt,onMouseLeave:bt,onPointerEnter:vt,zIndex:D,open:Ce,keepDom:_e,fresh:L,onClick:B,mask:x,motion:ye,maskMotion:xe,onVisibleChanged:function(e){De(!1),et(),null===f||void 0===f||f(e)},onPrepare:function(){return new Promise((function(e){gt(),Le((function(){return e}))}))},forceRender:C,autoDestroy:Q,getPopupContainer:S,align:Je,arrow:It,arrowPos:Ct,ready:He,offsetX:Ge,offsetY:qe,offsetR:Ke,offsetB:Xe,onAlign:st,stretch:M,targetWidth:ut/Qe,targetHeight:pt/Ze})))}));return t}(Qc);var Eu={shiftX:64,adjustY:1},Nu={adjustX:1,shiftY:!0},Tu=[0,0],Ru={left:{points:["cr","cl"],overflow:Nu,offset:[-4,0],targetOffset:Tu},right:{points:["cl","cr"],overflow:Nu,offset:[4,0],targetOffset:Tu},top:{points:["bc","tc"],overflow:Eu,offset:[0,-4],targetOffset:Tu},bottom:{points:["tc","bc"],overflow:Eu,offset:[0,4],targetOffset:Tu},topLeft:{points:["bl","tl"],overflow:Eu,offset:[0,-4],targetOffset:Tu},leftTop:{points:["tr","tl"],overflow:Nu,offset:[-4,0],targetOffset:Tu},topRight:{points:["br","tr"],overflow:Eu,offset:[0,-4],targetOffset:Tu},rightTop:{points:["tl","tr"],overflow:Nu,offset:[4,0],targetOffset:Tu},bottomRight:{points:["tr","br"],overflow:Eu,offset:[0,4],targetOffset:Tu},rightBottom:{points:["bl","br"],overflow:Nu,offset:[4,0],targetOffset:Tu},bottomLeft:{points:["tl","bl"],overflow:Eu,offset:[0,4],targetOffset:Tu},leftBottom:{points:["br","bl"],overflow:Nu,offset:[-4,0],targetOffset:Tu}};var Au=["overlayClassName","trigger","mouseEnterDelay","mouseLeaveDelay","overlayStyle","prefixCls","children","onVisibleChange","afterVisibleChange","transitionName","animation","motion","placement","align","destroyTooltipOnHide","defaultVisible","getTooltipContainer","overlayInnerStyle","arrowContent","overlay","id","showArrow"],Ou=function(e,t){var n=e.overlayClassName,r=e.trigger,a=void 0===r?["hover"]:r,i=e.mouseEnterDelay,s=void 0===i?0:i,c=e.mouseLeaveDelay,l=void 0===c?.1:c,u=e.overlayStyle,d=e.prefixCls,h=void 0===d?"rc-tooltip":d,p=e.children,f=e.onVisibleChange,g=e.afterVisibleChange,m=e.transitionName,v=e.animation,b=e.motion,y=e.placement,x=void 0===y?"right":y,w=e.align,k=void 0===w?{}:w,S=e.destroyTooltipOnHide,C=void 0!==S&&S,I=e.defaultVisible,E=e.getTooltipContainer,N=e.overlayInnerStyle,T=(e.arrowContent,e.overlay),R=e.id,A=e.showArrow,O=void 0===A||A,F=Cs(e,Au),_=(0,o.useRef)(null);(0,o.useImperativeHandle)(t,(function(){return _.current}));var D=xr({},F);"visible"in e&&(D.popupVisible=e.visible);return o.createElement(Iu,Pa({popupClassName:n,prefixCls:h,popup:function(){return o.createElement(Uc,{key:"content",prefixCls:h,id:R,overlayInnerStyle:N},T)},action:a,builtinPlacements:Ru,popupPlacement:x,ref:_,popupAlign:k,getPopupContainer:E,onPopupVisibleChange:f,afterPopupVisibleChange:g,popupTransitionName:m,popupAnimation:v,popupMotion:b,defaultPopupVisible:I,autoDestroy:C,mouseLeaveDelay:l,popupStyle:u,mouseEnterDelay:s,arrow:O},D),p)};const Fu=(0,o.forwardRef)(Ou);const _u=o.createContext(void 0),Du=100,Mu={Modal:Du,Drawer:Du,Popover:Du,Popconfirm:Du,Tooltip:Du,Tour:Du},Pu={SelectLike:50,Dropdown:50,DatePicker:50,Menu:50,ImagePreview:1};function Lu(e,t){const[,n]=ui(),r=o.useContext(_u),a=function(e){return e in Mu}(e);if(void 0!==t)return[t,t];let i=null!==r&&void 0!==r?r:0;return a?(i+=(r?0:n.zIndexPopupBase)+Mu[e],i=Math.min(i,n.zIndexPopupBase+1e3)):i+=Pu[e],[void 0===r?t:i,i]}const zu=(e,t,n)=>void 0!==n?n:"".concat(e,"-").concat(t);const Bu=(e,t,n)=>{const{sizePopupArrow:r,arrowPolygon:a,arrowPath:o,arrowShadowWidth:i,borderRadiusXS:s,calc:c}=e;return{pointerEvents:"none",width:r,height:r,overflow:"hidden","&::before":{position:"absolute",bottom:0,insetInlineStart:0,width:r,height:c(r).div(2).equal(),background:t,clipPath:{_multi_value_:!0,value:[a,o]},content:'""'},"&::after":{content:'""',position:"absolute",width:i,height:i,bottom:0,insetInline:0,margin:"auto",borderRadius:{_skip_check_:!0,value:"0 0 ".concat(pa(s)," 0")},transform:"translateY(50%) rotate(-135deg)",boxShadow:n,zIndex:0,background:"transparent"}}},Wu=8;function Uu(e){const{contentRadius:t,limitVerticalRadius:n}=e,r=t>12?t+2:12;return{arrowOffsetHorizontal:r,arrowOffsetVertical:n?Wu:r}}function Vu(e,t){return e?t:{}}function ju(e,t,n){const{componentCls:r,boxShadowPopoverArrow:a,arrowOffsetVertical:o,arrowOffsetHorizontal:i}=e,{arrowDistance:s=0,arrowPlacement:c={left:!0,right:!0,top:!0,bottom:!0}}=n||{};return{[r]:Object.assign(Object.assign(Object.assign(Object.assign({["".concat(r,"-arrow")]:[Object.assign(Object.assign({position:"absolute",zIndex:1,display:"block"},Bu(e,t,a)),{"&:before":{background:t}})]},Vu(!!c.top,{[["&-placement-top > ".concat(r,"-arrow"),"&-placement-topLeft > ".concat(r,"-arrow"),"&-placement-topRight > ".concat(r,"-arrow")].join(",")]:{bottom:s,transform:"translateY(100%) rotate(180deg)"},["&-placement-top > ".concat(r,"-arrow")]:{left:{_skip_check_:!0,value:"50%"},transform:"translateX(-50%) translateY(100%) rotate(180deg)"},["&-placement-topLeft > ".concat(r,"-arrow")]:{left:{_skip_check_:!0,value:i}},["&-placement-topRight > ".concat(r,"-arrow")]:{right:{_skip_check_:!0,value:i}}})),Vu(!!c.bottom,{[["&-placement-bottom > ".concat(r,"-arrow"),"&-placement-bottomLeft > ".concat(r,"-arrow"),"&-placement-bottomRight > ".concat(r,"-arrow")].join(",")]:{top:s,transform:"translateY(-100%)"},["&-placement-bottom > ".concat(r,"-arrow")]:{left:{_skip_check_:!0,value:"50%"},transform:"translateX(-50%) translateY(-100%)"},["&-placement-bottomLeft > ".concat(r,"-arrow")]:{left:{_skip_check_:!0,value:i}},["&-placement-bottomRight > ".concat(r,"-arrow")]:{right:{_skip_check_:!0,value:i}}})),Vu(!!c.left,{[["&-placement-left > ".concat(r,"-arrow"),"&-placement-leftTop > ".concat(r,"-arrow"),"&-placement-leftBottom > ".concat(r,"-arrow")].join(",")]:{right:{_skip_check_:!0,value:s},transform:"translateX(100%) rotate(90deg)"},["&-placement-left > ".concat(r,"-arrow")]:{top:{_skip_check_:!0,value:"50%"},transform:"translateY(-50%) translateX(100%) rotate(90deg)"},["&-placement-leftTop > ".concat(r,"-arrow")]:{top:o},["&-placement-leftBottom > ".concat(r,"-arrow")]:{bottom:o}})),Vu(!!c.right,{[["&-placement-right > ".concat(r,"-arrow"),"&-placement-rightTop > ".concat(r,"-arrow"),"&-placement-rightBottom > ".concat(r,"-arrow")].join(",")]:{left:{_skip_check_:!0,value:s},transform:"translateX(-100%) rotate(-90deg)"},["&-placement-right > ".concat(r,"-arrow")]:{top:{_skip_check_:!0,value:"50%"},transform:"translateY(-50%) translateX(-100%) rotate(-90deg)"},["&-placement-rightTop > ".concat(r,"-arrow")]:{top:o},["&-placement-rightBottom > ".concat(r,"-arrow")]:{bottom:o}}))}}const Hu={left:{points:["cr","cl"]},right:{points:["cl","cr"]},top:{points:["bc","tc"]},bottom:{points:["tc","bc"]},topLeft:{points:["bl","tl"]},leftTop:{points:["tr","tl"]},topRight:{points:["br","tr"]},rightTop:{points:["tl","tr"]},bottomRight:{points:["tr","br"]},rightBottom:{points:["bl","br"]},bottomLeft:{points:["tl","bl"]},leftBottom:{points:["br","bl"]}},Gu={topLeft:{points:["bl","tc"]},leftTop:{points:["tr","cl"]},topRight:{points:["br","tc"]},rightTop:{points:["tl","cr"]},bottomRight:{points:["tr","bc"]},rightBottom:{points:["bl","cr"]},bottomLeft:{points:["tl","bc"]},leftBottom:{points:["br","cl"]}},qu=new Set(["topLeft","topRight","bottomLeft","bottomRight","leftTop","leftBottom","rightTop","rightBottom"]);function Ku(e){const{arrowWidth:t,autoAdjustOverflow:n,arrowPointAtCenter:r,offset:a,borderRadius:o,visibleFirst:i}=e,s=t/2,c={};return Object.keys(Hu).forEach((e=>{const l=r&&Gu[e]||Hu[e],u=Object.assign(Object.assign({},l),{offset:[0,0],dynamicInset:!0});switch(c[e]=u,qu.has(e)&&(u.autoArrow=!1),e){case"top":case"topLeft":case"topRight":u.offset[1]=-s-a;break;case"bottom":case"bottomLeft":case"bottomRight":u.offset[1]=s+a;break;case"left":case"leftTop":case"leftBottom":u.offset[0]=-s-a;break;case"right":case"rightTop":case"rightBottom":u.offset[0]=s+a}const d=Uu({contentRadius:o,limitVerticalRadius:!0});if(r)switch(e){case"topLeft":case"bottomLeft":u.offset[0]=-d.arrowOffsetHorizontal-s;break;case"topRight":case"bottomRight":u.offset[0]=d.arrowOffsetHorizontal+s;break;case"leftTop":case"rightTop":u.offset[1]=-d.arrowOffsetHorizontal-s;break;case"leftBottom":case"rightBottom":u.offset[1]=d.arrowOffsetHorizontal+s}u.overflow=function(e,t,n,r){if(!1===r)return{adjustX:!1,adjustY:!1};const a=r&&"object"===typeof r?r:{},o={};switch(e){case"top":case"bottom":o.shiftX=2*t.arrowOffsetHorizontal+n,o.shiftY=!0,o.adjustY=!0;break;case"left":case"right":o.shiftY=2*t.arrowOffsetVertical+n,o.shiftX=!0,o.adjustX=!0}const i=Object.assign(Object.assign({},o),a);return i.shiftX||(i.adjustX=!0),i.shiftY||(i.adjustY=!0),i}(e,d,t,n),i&&(u.htmlRegion="visibleFirst")})),c}function Xu(e,t){return((e,t,n)=>o.isValidElement(e)?o.cloneElement(e,"function"===typeof n?n(e.props||{}):n):t)(e,e,t)}function $u(){}const Yu=o.createContext({}),Qu=()=>{const e=()=>{};return e.deprecated=$u,e};const Zu=o.createContext(null),Ju=e=>{let{children:t}=e;return o.createElement(Zu.Provider,{value:null},t)},ed=e=>({animationDuration:e,animationFillMode:"both"}),td=e=>({animationDuration:e,animationFillMode:"both"}),nd=function(e,t,n,r){const a=arguments.length>4&&void 0!==arguments[4]&&arguments[4]?"&":"";return{["\n      ".concat(a).concat(e,"-enter,\n      ").concat(a).concat(e,"-appear\n    ")]:Object.assign(Object.assign({},ed(r)),{animationPlayState:"paused"}),["".concat(a).concat(e,"-leave")]:Object.assign(Object.assign({},td(r)),{animationPlayState:"paused"}),["\n      ".concat(a).concat(e,"-enter").concat(e,"-enter-active,\n      ").concat(a).concat(e,"-appear").concat(e,"-appear-active\n    ")]:{animationName:t,animationPlayState:"running"},["".concat(a).concat(e,"-leave").concat(e,"-leave-active")]:{animationName:n,animationPlayState:"running",pointerEvents:"none"}}},rd=new eo("antZoomIn",{"0%":{transform:"scale(0.2)",opacity:0},"100%":{transform:"scale(1)",opacity:1}}),ad=new eo("antZoomOut",{"0%":{transform:"scale(1)"},"100%":{transform:"scale(0.2)",opacity:0}}),od=new eo("antZoomBigIn",{"0%":{transform:"scale(0.8)",opacity:0},"100%":{transform:"scale(1)",opacity:1}}),id=new eo("antZoomBigOut",{"0%":{transform:"scale(1)"},"100%":{transform:"scale(0.8)",opacity:0}}),sd=new eo("antZoomUpIn",{"0%":{transform:"scale(0.8)",transformOrigin:"50% 0%",opacity:0},"100%":{transform:"scale(1)",transformOrigin:"50% 0%"}}),cd=new eo("antZoomUpOut",{"0%":{transform:"scale(1)",transformOrigin:"50% 0%"},"100%":{transform:"scale(0.8)",transformOrigin:"50% 0%",opacity:0}}),ld={zoom:{inKeyframes:rd,outKeyframes:ad},"zoom-big":{inKeyframes:od,outKeyframes:id},"zoom-big-fast":{inKeyframes:od,outKeyframes:id},"zoom-left":{inKeyframes:new eo("antZoomLeftIn",{"0%":{transform:"scale(0.8)",transformOrigin:"0% 50%",opacity:0},"100%":{transform:"scale(1)",transformOrigin:"0% 50%"}}),outKeyframes:new eo("antZoomLeftOut",{"0%":{transform:"scale(1)",transformOrigin:"0% 50%"},"100%":{transform:"scale(0.8)",transformOrigin:"0% 50%",opacity:0}})},"zoom-right":{inKeyframes:new eo("antZoomRightIn",{"0%":{transform:"scale(0.8)",transformOrigin:"100% 50%",opacity:0},"100%":{transform:"scale(1)",transformOrigin:"100% 50%"}}),outKeyframes:new eo("antZoomRightOut",{"0%":{transform:"scale(1)",transformOrigin:"100% 50%"},"100%":{transform:"scale(0.8)",transformOrigin:"100% 50%",opacity:0}})},"zoom-up":{inKeyframes:sd,outKeyframes:cd},"zoom-down":{inKeyframes:new eo("antZoomDownIn",{"0%":{transform:"scale(0.8)",transformOrigin:"50% 100%",opacity:0},"100%":{transform:"scale(1)",transformOrigin:"50% 100%"}}),outKeyframes:new eo("antZoomDownOut",{"0%":{transform:"scale(1)",transformOrigin:"50% 100%"},"100%":{transform:"scale(0.8)",transformOrigin:"50% 100%",opacity:0}})}},ud=(e,t)=>{const{antCls:n}=e,r="".concat(n,"-").concat(t),{inKeyframes:a,outKeyframes:o}=ld[t];return[nd(r,a,o,"zoom-big-fast"===t?e.motionDurationFast:e.motionDurationMid),{["\n        ".concat(r,"-enter,\n        ").concat(r,"-appear\n      ")]:{transform:"scale(0)",opacity:0,animationTimingFunction:e.motionEaseOutCirc,"&-prepare":{transform:"none"}},["".concat(r,"-leave")]:{animationTimingFunction:e.motionEaseInOutCirc}}]},dd=["blue","purple","cyan","green","magenta","pink","red","orange","yellow","volcano","geekblue","lime","gold"];function hd(e,t){return dd.reduce(((n,r)=>{const a=e["".concat(r,"1")],o=e["".concat(r,"3")],i=e["".concat(r,"6")],s=e["".concat(r,"7")];return Object.assign(Object.assign({},n),t(r,{lightColor:a,lightBorderColor:o,darkColor:i,textColor:s}))}),{})}const pd=e=>{const{componentCls:t,tooltipMaxWidth:n,tooltipColor:r,tooltipBg:a,tooltipBorderRadius:o,zIndexPopup:i,controlHeight:s,boxShadowSecondary:c,paddingSM:l,paddingXS:u}=e;return[{[t]:Object.assign(Object.assign(Object.assign(Object.assign({},Mi(e)),{position:"absolute",zIndex:i,display:"block",width:"max-content",maxWidth:n,visibility:"visible",transformOrigin:"var(--arrow-x, 50%) var(--arrow-y, 50%)","&-hidden":{display:"none"},"--antd-arrow-background-color":a,["".concat(t,"-inner")]:{minWidth:"1em",minHeight:s,padding:"".concat(pa(e.calc(l).div(2).equal())," ").concat(pa(u)),color:r,textAlign:"start",textDecoration:"none",wordWrap:"break-word",backgroundColor:a,borderRadius:o,boxShadow:c,boxSizing:"border-box"},[["&-placement-left","&-placement-leftTop","&-placement-leftBottom","&-placement-right","&-placement-rightTop","&-placement-rightBottom"].join(",")]:{["".concat(t,"-inner")]:{borderRadius:e.min(o,Wu)}},["".concat(t,"-content")]:{position:"relative"}}),hd(e,((e,n)=>{let{darkColor:r}=n;return{["&".concat(t,"-").concat(e)]:{["".concat(t,"-inner")]:{backgroundColor:r},["".concat(t,"-arrow")]:{"--antd-arrow-background-color":r}}}}))),{"&-rtl":{direction:"rtl"}})},ju(e,"var(--antd-arrow-background-color)"),{["".concat(t,"-pure")]:{position:"relative",maxWidth:"none",margin:e.sizePopupArrow}}]},fd=e=>Object.assign(Object.assign({zIndexPopup:e.zIndexPopupBase+70},Uu({contentRadius:e.borderRadius,limitVerticalRadius:!0})),function(e){const{sizePopupArrow:t,borderRadiusXS:n,borderRadiusOuter:r}=e,a=t/2,o=a,i=1*r/Math.sqrt(2),s=a-r*(1-1/Math.sqrt(2)),c=a-n*(1/Math.sqrt(2)),l=r*(Math.sqrt(2)-1)+n*(1/Math.sqrt(2)),u=2*a-c,d=l,h=2*a-i,p=s,f=2*a-0,g=o,m=a*Math.sqrt(2)+r*(Math.sqrt(2)-2),v=r*(Math.sqrt(2)-1),b="polygon(".concat(v,"px 100%, 50% ").concat(v,"px, ").concat(2*a-v,"px 100%, ").concat(v,"px 100%)");return{arrowShadowWidth:m,arrowPath:"path('M ".concat(0," ").concat(o," A ").concat(r," ").concat(r," 0 0 0 ").concat(i," ").concat(s," L ").concat(c," ").concat(l," A ").concat(n," ").concat(n," 0 0 1 ").concat(u," ").concat(d," L ").concat(h," ").concat(p," A ").concat(r," ").concat(r," 0 0 0 ").concat(f," ").concat(g," Z')"),arrowPolygon:b}}(es(e,{borderRadiusOuter:Math.min(e.borderRadiusOuter,4)}))),gd=function(e){const t=ls("Tooltip",(e=>{const{borderRadius:t,colorTextLightSolid:n,colorBgSpotlight:r}=e,a=es(e,{tooltipMaxWidth:250,tooltipColor:n,tooltipBorderRadius:t,tooltipBg:r});return[pd(a),ud(e,"zoom-big-fast")]}),fd,{resetStyle:!1,injectStyle:!(arguments.length>1&&void 0!==arguments[1])||arguments[1]});return t(e)},md=dd.map((e=>"".concat(e,"-inverse")));function vd(e,t){const n=function(e){return arguments.length>1&&void 0!==arguments[1]&&!arguments[1]?dd.includes(e):[].concat(br(md),br(dd)).includes(e)}(t),r=cr()({["".concat(e,"-").concat(t)]:t&&n}),a={},o={};return t&&!n&&(a.background=t,o["--antd-arrow-background-color"]=t),{className:r,overlayStyle:a,arrowStyle:o}}const bd=e=>{const{prefixCls:t,className:n,placement:r="top",title:a,color:i,overlayInnerStyle:s}=e,{getPrefixCls:c}=o.useContext(fi),l=c("tooltip",t),[u,d,h]=gd(l),p=vd(l,i),f=p.arrowStyle,g=Object.assign(Object.assign({},s),p.overlayStyle),m=cr()(d,h,l,"".concat(l,"-pure"),"".concat(l,"-placement-").concat(r),n,p.className);return u(o.createElement("div",{className:m,style:f},o.createElement("div",{className:"".concat(l,"-arrow")}),o.createElement(Uc,Object.assign({},e,{className:d,prefixCls:l,overlayInnerStyle:g}),a)))};var yd=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const xd=o.forwardRef(((e,t)=>{var n,r;const{prefixCls:a,openClassName:i,getTooltipContainer:s,overlayClassName:c,color:l,overlayInnerStyle:u,children:d,afterOpenChange:h,afterVisibleChange:p,destroyTooltipOnHide:f,arrow:g=!0,title:m,overlay:v,builtinPlacements:b,arrowPointAtCenter:y=!1,autoAdjustOverflow:x=!0}=e,w=!!g,[,k]=ui(),{getPopupContainer:S,getPrefixCls:C,direction:I}=o.useContext(fi),E=Qu("Tooltip"),N=o.useRef(null),T=()=>{var e;null===(e=N.current)||void 0===e||e.forceAlign()};o.useImperativeHandle(t,(()=>{var e;return{forceAlign:T,forcePopupAlign:()=>{E.deprecated(!1,"forcePopupAlign","forceAlign"),T()},nativeElement:null===(e=N.current)||void 0===e?void 0:e.nativeElement}}));const[R,A]=ki(!1,{value:null!==(n=e.open)&&void 0!==n?n:e.visible,defaultValue:null!==(r=e.defaultOpen)&&void 0!==r?r:e.defaultVisible}),O=!m&&!v&&0!==m,F=o.useMemo((()=>{var e,t;let n=y;return"object"===typeof g&&(n=null!==(t=null!==(e=g.pointAtCenter)&&void 0!==e?e:g.arrowPointAtCenter)&&void 0!==t?t:y),b||Ku({arrowPointAtCenter:n,autoAdjustOverflow:x,arrowWidth:w?k.sizePopupArrow:0,borderRadius:k.borderRadius,offset:k.marginXXS,visibleFirst:!0})}),[y,g,b,k]),_=o.useMemo((()=>0===m?m:v||m||""),[v,m]),D=o.createElement(Ju,null,"function"===typeof _?_():_),{getPopupContainer:M,placement:P="top",mouseEnterDelay:L=.1,mouseLeaveDelay:z=.1,overlayStyle:B,rootClassName:W}=e,U=yd(e,["getPopupContainer","placement","mouseEnterDelay","mouseLeaveDelay","overlayStyle","rootClassName"]),V=C("tooltip",a),j=C(),H=e["data-popover-inject"];let G=R;"open"in e||"visible"in e||!O||(G=!1);const q=o.isValidElement(d)&&!function(e){return e&&o.isValidElement(e)&&e.type===o.Fragment}(d)?d:o.createElement("span",null,d),K=q.props,X=K.className&&"string"!==typeof K.className?K.className:cr()(K.className,i||"".concat(V,"-open")),[$,Y,Q]=gd(V,!H),Z=vd(V,l),J=Z.arrowStyle,ee=Object.assign(Object.assign({},u),Z.overlayStyle),te=cr()(c,{["".concat(V,"-rtl")]:"rtl"===I},Z.className,W,Y,Q),[ne,re]=Lu("Tooltip",U.zIndex),ae=o.createElement(Fu,Object.assign({},U,{zIndex:ne,showArrow:w,placement:P,mouseEnterDelay:L,mouseLeaveDelay:z,prefixCls:V,overlayClassName:te,overlayStyle:Object.assign(Object.assign({},J),B),getTooltipContainer:M||s||S,ref:N,builtinPlacements:F,overlay:D,visible:G,onVisibleChange:t=>{var n,r;A(!O&&t),O||(null===(n=e.onOpenChange)||void 0===n||n.call(e,t),null===(r=e.onVisibleChange)||void 0===r||r.call(e,t))},afterVisibleChange:null!==h&&void 0!==h?h:p,overlayInnerStyle:ee,arrowContent:o.createElement("span",{className:"".concat(V,"-arrow-content")}),motion:{motionName:zu(j,"zoom-big-fast",e.transitionName),motionDeadline:1e3},destroyTooltipOnHide:!!f}),G?Xu(q,{className:X}):q);return $(o.createElement(_u.Provider,{value:re},ae))})),wd=xd;wd._InternalPanelDoNotUseOrYouWillBeFired=bd;const kd=wd;const Sd={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z"}}]},name:"enter",theme:"outlined"};var Cd=function(e,t){return o.createElement(Ws,Pa({},e,{ref:t,icon:Sd}))};const Id=o.forwardRef(Cd);function Ed(e,t,n){var r=t.cloneNode(!0),a=Object.create(e,{target:{value:r},currentTarget:{value:r}});return r.value=n,"number"===typeof t.selectionStart&&"number"===typeof t.selectionEnd&&(r.selectionStart=t.selectionStart,r.selectionEnd=t.selectionEnd),r.setSelectionRange=function(){t.setSelectionRange.apply(t,arguments)},a}function Nd(e,t,n,r){if(n){var a=t;"click"!==t.type?"file"===e.type||void 0===r?n(a):n(a=Ed(t,e,r)):n(a=Ed(t,e,""))}}var Td=o.forwardRef((function(e,t){var n,r,a=e.inputElement,i=e.children,s=e.prefixCls,c=e.prefix,l=e.suffix,u=e.addonBefore,d=e.addonAfter,h=e.className,p=e.style,f=e.disabled,g=e.readOnly,m=e.focused,v=e.triggerFocus,b=e.allowClear,y=e.value,x=e.handleReset,w=e.hidden,k=e.classes,S=e.classNames,C=e.dataAttrs,I=e.styles,E=e.components,N=null!==i&&void 0!==i?i:a,T=(null===E||void 0===E?void 0:E.affixWrapper)||"span",R=(null===E||void 0===E?void 0:E.groupWrapper)||"span",A=(null===E||void 0===E?void 0:E.wrapper)||"span",O=(null===E||void 0===E?void 0:E.groupAddon)||"span",F=(0,o.useRef)(null),_=function(e){return!!(e.prefix||e.suffix||e.allowClear)}(e),D=(0,o.cloneElement)(N,{value:y,className:cr()(N.props.className,!_&&(null===S||void 0===S?void 0:S.variant))||null}),M=(0,o.useRef)(null);if(o.useImperativeHandle(t,(function(){return{nativeElement:M.current||F.current}})),_){var P,L=null;if(b){var z,B=!f&&!g&&y,W="".concat(s,"-clear-icon"),U="object"===lr(b)&&null!==b&&void 0!==b&&b.clearIcon?b.clearIcon:"\u2716";L=o.createElement("span",{onClick:x,onMouseDown:function(e){return e.preventDefault()},className:cr()(W,(z={},dr(z,"".concat(W,"-hidden"),!B),dr(z,"".concat(W,"-has-suffix"),!!l),z)),role:"button",tabIndex:-1},U)}var V="".concat(s,"-affix-wrapper"),j=cr()(V,(dr(P={},"".concat(s,"-disabled"),f),dr(P,"".concat(V,"-disabled"),f),dr(P,"".concat(V,"-focused"),m),dr(P,"".concat(V,"-readonly"),g),dr(P,"".concat(V,"-input-with-clear-btn"),l&&b&&y),P),null===k||void 0===k?void 0:k.affixWrapper,null===S||void 0===S?void 0:S.affixWrapper,null===S||void 0===S?void 0:S.variant),H=(l||b)&&o.createElement("span",{className:cr()("".concat(s,"-suffix"),null===S||void 0===S?void 0:S.suffix),style:null===I||void 0===I?void 0:I.suffix},L,l);D=o.createElement(T,Pa({className:j,style:null===I||void 0===I?void 0:I.affixWrapper,onClick:function(e){var t;null!==(t=F.current)&&void 0!==t&&t.contains(e.target)&&(null===v||void 0===v||v())}},null===C||void 0===C?void 0:C.affixWrapper,{ref:F}),c&&o.createElement("span",{className:cr()("".concat(s,"-prefix"),null===S||void 0===S?void 0:S.prefix),style:null===I||void 0===I?void 0:I.prefix},c),D,H)}if(function(e){return!(!e.addonBefore&&!e.addonAfter)}(e)){var G="".concat(s,"-group"),q="".concat(G,"-addon"),K="".concat(G,"-wrapper"),X=cr()("".concat(s,"-wrapper"),G,null===k||void 0===k?void 0:k.wrapper,null===S||void 0===S?void 0:S.wrapper),$=cr()(K,dr({},"".concat(K,"-disabled"),f),null===k||void 0===k?void 0:k.group,null===S||void 0===S?void 0:S.groupWrapper);D=o.createElement(R,{className:$,ref:M},o.createElement(A,{className:X},u&&o.createElement(O,{className:q},u),D,d&&o.createElement(O,{className:q},d)))}return o.cloneElement(D,{className:cr()(null===(n=D.props)||void 0===n?void 0:n.className,h)||null,style:xr(xr({},null===(r=D.props)||void 0===r?void 0:r.style),p),hidden:w})}));const Rd=Td;var Ad=["show"];var Od,Fd=["letter-spacing","line-height","padding-top","padding-bottom","font-family","font-weight","font-size","font-variant","text-rendering","text-transform","width","text-indent","padding-left","padding-right","border-width","box-sizing","word-break","white-space"],_d={};function Dd(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;Od||((Od=document.createElement("textarea")).setAttribute("tab-index","-1"),Od.setAttribute("aria-hidden","true"),document.body.appendChild(Od)),e.getAttribute("wrap")?Od.setAttribute("wrap",e.getAttribute("wrap")):Od.removeAttribute("wrap");var a=function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=e.getAttribute("id")||e.getAttribute("data-reactid")||e.getAttribute("name");if(t&&_d[n])return _d[n];var r=window.getComputedStyle(e),a=r.getPropertyValue("box-sizing")||r.getPropertyValue("-moz-box-sizing")||r.getPropertyValue("-webkit-box-sizing"),o=parseFloat(r.getPropertyValue("padding-bottom"))+parseFloat(r.getPropertyValue("padding-top")),i=parseFloat(r.getPropertyValue("border-bottom-width"))+parseFloat(r.getPropertyValue("border-top-width")),s={sizingStyle:Fd.map((function(e){return"".concat(e,":").concat(r.getPropertyValue(e))})).join(";"),paddingSize:o,borderSize:i,boxSizing:a};return t&&n&&(_d[n]=s),s}(e,t),o=a.paddingSize,i=a.borderSize,s=a.boxSizing,c=a.sizingStyle;Od.setAttribute("style","".concat(c,";").concat("\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n")),Od.value=e.value||e.placeholder||"";var l,u=void 0,d=void 0,h=Od.scrollHeight;if("border-box"===s?h+=i:"content-box"===s&&(h-=o),null!==n||null!==r){Od.value=" ";var p=Od.scrollHeight-o;null!==n&&(u=p*n,"border-box"===s&&(u=u+o+i),h=Math.max(u,h)),null!==r&&(d=p*r,"border-box"===s&&(d=d+o+i),l=h>d?"":"hidden",h=Math.min(d,h))}var f={height:h,overflowY:l,resize:"none"};return u&&(f.minHeight=u),d&&(f.maxHeight=d),f}var Md=["prefixCls","onPressEnter","defaultValue","value","autoSize","onResize","className","style","disabled","onChange","onInternalAutoSize"],Pd=o.forwardRef((function(e,t){var n=e,r=n.prefixCls,a=(n.onPressEnter,n.defaultValue),i=n.value,s=n.autoSize,c=n.onResize,l=n.className,u=n.style,d=n.disabled,h=n.onChange,p=(n.onInternalAutoSize,Cs(n,Md)),f=mr(ki(a,{value:i,postState:function(e){return null!==e&&void 0!==e?e:""}}),2),g=f[0],m=f[1],v=o.useRef();o.useImperativeHandle(t,(function(){return{textArea:v.current}}));var b=mr(o.useMemo((function(){return s&&"object"===lr(s)?[s.minRows,s.maxRows]:[]}),[s]),2),y=b[0],x=b[1],w=!!s,k=mr(o.useState(2),2),S=k[0],C=k[1],I=mr(o.useState(),2),E=I[0],N=I[1],T=function(){C(0)};wa((function(){w&&T()}),[i,y,x,w]),wa((function(){if(0===S)C(1);else if(1===S){var e=Dd(v.current,!1,y,x);C(2),N(e)}else!function(){try{if(document.activeElement===v.current){var e=v.current,t=e.selectionStart,n=e.selectionEnd,r=e.scrollTop;v.current.setSelectionRange(t,n),v.current.scrollTop=r}}catch(f0){}}()}),[S]);var R=o.useRef(),A=function(){Pl.cancel(R.current)};o.useEffect((function(){return A}),[]);var O=w?E:null,F=xr(xr({},u),O);return 0!==S&&1!==S||(F.overflowY="hidden",F.overflowX="hidden"),o.createElement(Sc,{onResize:function(e){2===S&&(null===c||void 0===c||c(e),s&&(A(),R.current=Pl((function(){T()}))))},disabled:!(s||c)},o.createElement("textarea",Pa({},p,{ref:v,style:F,className:cr()(r,l,dr({},"".concat(r,"-disabled"),d)),disabled:d,value:g,onChange:function(e){m(e.target.value),null===h||void 0===h||h(e)}})))}));const Ld=Pd;var zd=["defaultValue","value","onFocus","onBlur","onChange","allowClear","maxLength","onCompositionStart","onCompositionEnd","suffix","prefixCls","showCount","count","className","style","disabled","hidden","classNames","styles","onResize","readOnly"],Bd=o.forwardRef((function(e,t){var n,r=e.defaultValue,a=e.value,i=e.onFocus,s=e.onBlur,c=e.onChange,l=e.allowClear,u=e.maxLength,d=e.onCompositionStart,h=e.onCompositionEnd,p=e.suffix,f=e.prefixCls,g=void 0===f?"rc-textarea":f,m=e.showCount,v=e.count,b=e.className,y=e.style,x=e.disabled,w=e.hidden,k=e.classNames,S=e.styles,C=e.onResize,I=e.readOnly,E=Cs(e,zd),N=mr(ki(r,{value:a,defaultValue:r}),2),T=N[0],R=N[1],A=void 0===T||null===T?"":String(T),O=mr(o.useState(!1),2),F=O[0],_=O[1],D=o.useRef(!1),M=mr(o.useState(null),2),P=M[0],L=M[1],z=(0,o.useRef)(null),B=(0,o.useRef)(null),W=function(){var e;return null===(e=B.current)||void 0===e?void 0:e.textArea},U=function(){W().focus()};(0,o.useImperativeHandle)(t,(function(){var e;return{resizableTextArea:B.current,focus:U,blur:function(){W().blur()},nativeElement:(null===(e=z.current)||void 0===e?void 0:e.nativeElement)||W()}})),(0,o.useEffect)((function(){_((function(e){return!x&&e}))}),[x]);var V=mr(o.useState(null),2),j=V[0],H=V[1];o.useEffect((function(){var e;j&&(e=W()).setSelectionRange.apply(e,br(j))}),[j]);var G,q=function(e,t){return o.useMemo((function(){var n={};t&&(n.show="object"===lr(t)&&t.formatter?t.formatter:!!t);var r=n=xr(xr({},n),e),a=r.show,o=Cs(r,Ad);return xr(xr({},o),{},{show:!!a,showFormatter:"function"===typeof a?a:void 0,strategy:o.strategy||function(e){return e.length}})}),[e,t])}(v,m),K=null!==(n=q.max)&&void 0!==n?n:u,X=Number(K)>0,$=q.strategy(A),Y=!!K&&$>K,Q=function(e,t){var n=t;!D.current&&q.exceedFormatter&&q.max&&q.strategy(t)>q.max&&t!==(n=q.exceedFormatter(t,{max:q.max}))&&H([W().selectionStart||0,W().selectionEnd||0]),R(n),Nd(e.currentTarget,e,c,n)},Z=p;q.show&&(G=q.showFormatter?q.showFormatter({value:A,count:$,maxLength:K}):"".concat($).concat(X?" / ".concat(K):""),Z=o.createElement(o.Fragment,null,Z,o.createElement("span",{className:cr()("".concat(g,"-data-count"),null===k||void 0===k?void 0:k.count),style:null===S||void 0===S?void 0:S.count},G)));var J=!E.autoSize&&!m&&!l;return o.createElement(Rd,{ref:z,value:A,allowClear:l,handleReset:function(e){R(""),U(),Nd(W(),e,c)},suffix:Z,prefixCls:g,classNames:xr(xr({},k),{},{affixWrapper:cr()(null===k||void 0===k?void 0:k.affixWrapper,dr(dr({},"".concat(g,"-show-count"),m),"".concat(g,"-textarea-allow-clear"),l))}),disabled:x,focused:F,className:cr()(b,Y&&"".concat(g,"-out-of-range")),style:xr(xr({},y),P&&!J?{height:"auto"}:{}),dataAttrs:{affixWrapper:{"data-count":"string"===typeof G?G:void 0}},hidden:w,readOnly:I},o.createElement(Ld,Pa({},E,{maxLength:u,onKeyDown:function(e){var t=E.onPressEnter,n=E.onKeyDown;"Enter"===e.key&&t&&t(e),null===n||void 0===n||n(e)},onChange:function(e){Q(e,e.target.value)},onFocus:function(e){_(!0),null===i||void 0===i||i(e)},onBlur:function(e){_(!1),null===s||void 0===s||s(e)},onCompositionStart:function(e){D.current=!0,null===d||void 0===d||d(e)},onCompositionEnd:function(e){D.current=!1,Q(e,e.currentTarget.value),null===h||void 0===h||h(e)},className:cr()(null===k||void 0===k?void 0:k.textarea),style:xr(xr({},null===S||void 0===S?void 0:S.textarea),{},{resize:null===y||void 0===y?void 0:y.resize}),disabled:x,prefixCls:g,onResize:function(e){var t;null===C||void 0===C||C(e),null!==(t=W())&&void 0!==t&&t.style.height&&L(!0)},ref:B,readOnly:I})))}));const Wd=Bd;const Ud={icon:{tag:"svg",attrs:{"fill-rule":"evenodd",viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z"}}]},name:"close-circle",theme:"filled"};var Vd=function(e,t){return o.createElement(Ws,Pa({},e,{ref:t,icon:Ud}))};const jd=o.forwardRef(Vd),Hd=e=>{let t;return"object"===typeof e&&(null===e||void 0===e?void 0:e.clearIcon)?t=e:e&&(t={clearIcon:o.createElement(jd,null)}),t};function Gd(e,t,n){return cr()({["".concat(e,"-status-success")]:"success"===t,["".concat(e,"-status-warning")]:"warning"===t,["".concat(e,"-status-error")]:"error"===t,["".concat(e,"-status-validating")]:"validating"===t,["".concat(e,"-has-feedback")]:n})}const qd=o.createContext(!1),Kd=e=>{let{children:t,disabled:n}=e;const r=o.useContext(qd);return o.createElement(qd.Provider,{value:null!==n&&void 0!==n?n:r},t)},Xd=qd,$d=e=>{const[,,,,t]=ui();return t?"".concat(e,"-css-var"):""},Yd=o.createContext(void 0),Qd=e=>{let{children:t,size:n}=e;const r=o.useContext(Yd);return o.createElement(Yd.Provider,{value:n||r},t)},Zd=Yd,Jd=e=>{const t=o.useContext(Zd);return o.useMemo((()=>e?"string"===typeof e?null!==e&&void 0!==e?e:t:e instanceof Function?e(t):t:t),[e,t])};function eh(){eh=function(){return t};var e,t={},n=Object.prototype,r=n.hasOwnProperty,a=Object.defineProperty||function(e,t,n){e[t]=n.value},o="function"==typeof Symbol?Symbol:{},i=o.iterator||"@@iterator",s=o.asyncIterator||"@@asyncIterator",c=o.toStringTag||"@@toStringTag";function l(e,t,n){return Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{l({},"")}catch(e){l=function(e,t,n){return e[t]=n}}function u(e,t,n,r){var o=t&&t.prototype instanceof v?t:v,i=Object.create(o.prototype),s=new A(r||[]);return a(i,"_invoke",{value:E(e,n,s)}),i}function d(e,t,n){try{return{type:"normal",arg:e.call(t,n)}}catch(e){return{type:"throw",arg:e}}}t.wrap=u;var h="suspendedStart",p="suspendedYield",f="executing",g="completed",m={};function v(){}function b(){}function y(){}var x={};l(x,i,(function(){return this}));var w=Object.getPrototypeOf,k=w&&w(w(O([])));k&&k!==n&&r.call(k,i)&&(x=k);var S=y.prototype=v.prototype=Object.create(x);function C(e){["next","throw","return"].forEach((function(t){l(e,t,(function(e){return this._invoke(t,e)}))}))}function I(e,t){function n(a,o,i,s){var c=d(e[a],e,o);if("throw"!==c.type){var l=c.arg,u=l.value;return u&&"object"==lr(u)&&r.call(u,"__await")?t.resolve(u.__await).then((function(e){n("next",e,i,s)}),(function(e){n("throw",e,i,s)})):t.resolve(u).then((function(e){l.value=e,i(l)}),(function(e){return n("throw",e,i,s)}))}s(c.arg)}var o;a(this,"_invoke",{value:function(e,r){function a(){return new t((function(t,a){n(e,r,t,a)}))}return o=o?o.then(a,a):a()}})}function E(t,n,r){var a=h;return function(o,i){if(a===f)throw Error("Generator is already running");if(a===g){if("throw"===o)throw i;return{value:e,done:!0}}for(r.method=o,r.arg=i;;){var s=r.delegate;if(s){var c=N(s,r);if(c){if(c===m)continue;return c}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(a===h)throw a=g,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);a=f;var l=d(t,n,r);if("normal"===l.type){if(a=r.done?g:p,l.arg===m)continue;return{value:l.arg,done:r.done}}"throw"===l.type&&(a=g,r.method="throw",r.arg=l.arg)}}}function N(t,n){var r=n.method,a=t.iterator[r];if(a===e)return n.delegate=null,"throw"===r&&t.iterator.return&&(n.method="return",n.arg=e,N(t,n),"throw"===n.method)||"return"!==r&&(n.method="throw",n.arg=new TypeError("The iterator does not provide a '"+r+"' method")),m;var o=d(a,t.iterator,n.arg);if("throw"===o.type)return n.method="throw",n.arg=o.arg,n.delegate=null,m;var i=o.arg;return i?i.done?(n[t.resultName]=i.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=e),n.delegate=null,m):i:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,m)}function T(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function R(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function A(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(T,this),this.reset(!0)}function O(t){if(t||""===t){var n=t[i];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var a=-1,o=function n(){for(;++a<t.length;)if(r.call(t,a))return n.value=t[a],n.done=!1,n;return n.value=e,n.done=!0,n};return o.next=o}}throw new TypeError(lr(t)+" is not iterable")}return b.prototype=y,a(S,"constructor",{value:y,configurable:!0}),a(y,"constructor",{value:b,configurable:!0}),b.displayName=l(y,c,"GeneratorFunction"),t.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===b||"GeneratorFunction"===(t.displayName||t.name))},t.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,y):(e.__proto__=y,l(e,c,"GeneratorFunction")),e.prototype=Object.create(S),e},t.awrap=function(e){return{__await:e}},C(I.prototype),l(I.prototype,s,(function(){return this})),t.AsyncIterator=I,t.async=function(e,n,r,a,o){void 0===o&&(o=Promise);var i=new I(u(e,n,r,a),o);return t.isGeneratorFunction(n)?i:i.next().then((function(e){return e.done?e.value:i.next()}))},C(S),l(S,c,"Generator"),l(S,i,(function(){return this})),l(S,"toString",(function(){return"[object Generator]"})),t.keys=function(e){var t=Object(e),n=[];for(var r in t)n.push(r);return n.reverse(),function e(){for(;n.length;){var r=n.pop();if(r in t)return e.value=r,e.done=!1,e}return e.done=!0,e}},t.values=O,A.prototype={constructor:A,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(R),!t)for(var n in this)"t"===n.charAt(0)&&r.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=e)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var n=this;function a(r,a){return s.type="throw",s.arg=t,n.next=r,a&&(n.method="next",n.arg=e),!!a}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],s=i.completion;if("root"===i.tryLoc)return a("end");if(i.tryLoc<=this.prev){var c=r.call(i,"catchLoc"),l=r.call(i,"finallyLoc");if(c&&l){if(this.prev<i.catchLoc)return a(i.catchLoc,!0);if(this.prev<i.finallyLoc)return a(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return a(i.catchLoc,!0)}else{if(!l)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return a(i.finallyLoc)}}}},abrupt:function(e,t){for(var n=this.tryEntries.length-1;n>=0;--n){var a=this.tryEntries[n];if(a.tryLoc<=this.prev&&r.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var o=a;break}}o&&("break"===e||"continue"===e)&&o.tryLoc<=t&&t<=o.finallyLoc&&(o=null);var i=o?o.completion:{};return i.type=e,i.arg=t,o?(this.method="next",this.next=o.finallyLoc,m):this.complete(i)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),m},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.finallyLoc===e)return this.complete(n.completion,n.afterLoc),R(n),m}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.tryLoc===e){var r=n.completion;if("throw"===r.type){var a=r.arg;R(n)}return a}}throw Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:O(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=e),m}},t}function th(e,t,n,r,a,o,i){try{var s=e[o](i),c=s.value}catch(e){return void n(e)}s.done?t(c):Promise.resolve(c).then(r,a)}function nh(e){return function(){var t=this,n=arguments;return new Promise((function(r,a){var o=e.apply(t,n);function i(e){th(o,r,a,i,s,"next",e)}function s(e){th(o,r,a,i,s,"throw",e)}i(void 0)}))}}var rh="RC_FORM_INTERNAL_HOOKS",ah=function(){Ur(!1,"Can not find FormContext. Please make sure you wrap Field under Form.")};const oh=o.createContext({getFieldValue:ah,getFieldsValue:ah,getFieldError:ah,getFieldWarning:ah,getFieldsError:ah,isFieldsTouched:ah,isFieldTouched:ah,isFieldValidating:ah,isFieldsValidating:ah,resetFields:ah,setFields:ah,setFieldValue:ah,setFieldsValue:ah,validateFields:ah,submit:ah,getInternalHooks:function(){return ah(),{dispatch:ah,initEntityValue:ah,registerField:ah,useSubscribe:ah,setInitialValues:ah,destroyForm:ah,setCallbacks:ah,registerWatch:ah,getFields:ah,setValidateMessages:ah,setPreserve:ah,getInitialValue:ah}}});const ih=o.createContext(null);function sh(e){return void 0===e||null===e?[]:Array.isArray(e)?e:[e]}function ch(){return{default:"Validation error on field %s",required:"%s is required",enum:"%s must be one of %s",whitespace:"%s cannot be empty",date:{format:"%s date %s is invalid for format %s",parse:"%s date could not be parsed, %s is invalid ",invalid:"%s date %s is invalid"},types:{string:"%s is not a %s",method:"%s is not a %s (function)",array:"%s is not an %s",object:"%s is not an %s",number:"%s is not a %s",date:"%s is not a %s",boolean:"%s is not a %s",integer:"%s is not an %s",float:"%s is not a %s",regexp:"%s is not a valid %s",email:"%s is not a valid %s",url:"%s is not a valid %s",hex:"%s is not a valid %s"},string:{len:"%s must be exactly %s characters",min:"%s must be at least %s characters",max:"%s cannot be longer than %s characters",range:"%s must be between %s and %s characters"},number:{len:"%s must equal %s",min:"%s cannot be less than %s",max:"%s cannot be greater than %s",range:"%s must be between %s and %s"},array:{len:"%s must be exactly %s in length",min:"%s cannot be less than %s in length",max:"%s cannot be greater than %s in length",range:"%s must be between %s and %s in length"},pattern:{mismatch:"%s value %s does not match pattern %s"},clone:function(){var e=JSON.parse(JSON.stringify(this));return e.clone=this.clone,e}}}var lh=ch();function uh(e){var t="function"==typeof Map?new Map:void 0;return uh=function(e){if(null===e||!function(e){try{return-1!==Function.toString.call(e).indexOf("[native code]")}catch(t){return"function"==typeof e}}(e))return e;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,n)}function n(){return function(e,t,n){if(Bi())return Reflect.construct.apply(null,arguments);var r=[null];r.push.apply(r,t);var a=new(e.bind.apply(e,r));return n&&ji(a,n.prototype),a}(e,arguments,zi(this).constructor)}return n.prototype=Object.create(e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),ji(n,e)},uh(e)}var dh=/%[sdj%]/g;function hh(e){if(!e||!e.length)return null;var t={};return e.forEach((function(e){var n=e.field;t[n]=t[n]||[],t[n].push(e)})),t}function ph(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];var a=0,o=n.length;if("function"===typeof e)return e.apply(null,n);if("string"===typeof e){var i=e.replace(dh,(function(e){if("%%"===e)return"%";if(a>=o)return e;switch(e){case"%s":return String(n[a++]);case"%d":return Number(n[a++]);case"%j":try{return JSON.stringify(n[a++])}catch(Et){return"[Circular]"}break;default:return e}}));return i}return e}function fh(e,t){return void 0===e||null===e||(!("array"!==t||!Array.isArray(e)||e.length)||!(!function(e){return"string"===e||"url"===e||"hex"===e||"email"===e||"date"===e||"pattern"===e}(t)||"string"!==typeof e||e))}function gh(e,t,n){var r=0,a=e.length;!function o(i){if(i&&i.length)n(i);else{var s=r;r+=1,s<a?t(e[s],o):n([])}}([])}var mh=function(e){Hi(n,e);var t=vc(n);function n(e,r){var a;return jr(this,n),dr(Wi(a=t.call(this,"Async Validation Error")),"errors",void 0),dr(Wi(a),"fields",void 0),a.errors=e,a.fields=r,a}return Gr(n)}(uh(Error));function vh(e,t,n,r,a){if(t.first){var o=new Promise((function(t,o){var i=function(e){var t=[];return Object.keys(e).forEach((function(n){t.push.apply(t,br(e[n]||[]))})),t}(e);gh(i,n,(function(e){return r(e),e.length?o(new mh(e,hh(e))):t(a)}))}));return o.catch((function(e){return e})),o}var i=!0===t.firstFields?Object.keys(e):t.firstFields||[],s=Object.keys(e),c=s.length,l=0,u=[],d=new Promise((function(t,o){var d=function(e){if(u.push.apply(u,e),++l===c)return r(u),u.length?o(new mh(u,hh(u))):t(a)};s.length||(r(u),t(a)),s.forEach((function(t){var r=e[t];-1!==i.indexOf(t)?gh(r,n,d):function(e,t,n){var r=[],a=0,o=e.length;function i(e){r.push.apply(r,br(e||[])),++a===o&&n(r)}e.forEach((function(e){t(e,i)}))}(r,n,d)}))}));return d.catch((function(e){return e})),d}function bh(e,t){return function(n){var r,a;return r=e.fullFields?function(e,t){for(var n=e,r=0;r<t.length;r++){if(void 0==n)return n;n=n[t[r]]}return n}(t,e.fullFields):t[n.field||e.fullField],(a=n)&&void 0!==a.message?(n.field=n.field||e.fullField,n.fieldValue=r,n):{message:"function"===typeof n?n():n,fieldValue:r,field:n.field||e.fullField}}}function yh(e,t){if(t)for(var n in t)if(t.hasOwnProperty(n)){var r=t[n];"object"===lr(r)&&"object"===lr(e[n])?e[n]=xr(xr({},e[n]),r):e[n]=r}return e}var xh="enum";const wh=function(e,t,n,r,a){var o="number"===typeof e.len,i="number"===typeof e.min,s="number"===typeof e.max,c=t,l=null,u="number"===typeof t,d="string"===typeof t,h=Array.isArray(t);if(u?l="number":d?l="string":h&&(l="array"),!l)return!1;h&&(c=t.length),d&&(c=t.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,"_").length),o?c!==e.len&&r.push(ph(a.messages[l].len,e.fullField,e.len)):i&&!s&&c<e.min?r.push(ph(a.messages[l].min,e.fullField,e.min)):s&&!i&&c>e.max?r.push(ph(a.messages[l].max,e.fullField,e.max)):i&&s&&(c<e.min||c>e.max)&&r.push(ph(a.messages[l].range,e.fullField,e.min,e.max))};const kh=function(e,t,n,r,a,o){!e.required||n.hasOwnProperty(e.field)&&!fh(t,o||e.type)||r.push(ph(a.messages.required,e.fullField))};var Sh;var Ch=/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,Ih=/^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,Eh={integer:function(e){return Eh.number(e)&&parseInt(e,10)===e},float:function(e){return Eh.number(e)&&!Eh.integer(e)},array:function(e){return Array.isArray(e)},regexp:function(e){if(e instanceof RegExp)return!0;try{return!!new RegExp(e)}catch(f0){return!1}},date:function(e){return"function"===typeof e.getTime&&"function"===typeof e.getMonth&&"function"===typeof e.getYear&&!isNaN(e.getTime())},number:function(e){return!isNaN(e)&&"number"===typeof e},object:function(e){return"object"===lr(e)&&!Eh.array(e)},method:function(e){return"function"===typeof e},email:function(e){return"string"===typeof e&&e.length<=320&&!!e.match(Ch)},url:function(e){return"string"===typeof e&&e.length<=2048&&!!e.match(function(){if(Sh)return Sh;var e="[a-fA-F\\d:]",t=function(t){return t&&t.includeBoundaries?"(?:(?<=\\s|^)(?=".concat(e,")|(?<=").concat(e,")(?=\\s|$))"):""},n="(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",r="[a-fA-F\\d]{1,4}",a=["(?:".concat(r,":){7}(?:").concat(r,"|:)"),"(?:".concat(r,":){6}(?:").concat(n,"|:").concat(r,"|:)"),"(?:".concat(r,":){5}(?::").concat(n,"|(?::").concat(r,"){1,2}|:)"),"(?:".concat(r,":){4}(?:(?::").concat(r,"){0,1}:").concat(n,"|(?::").concat(r,"){1,3}|:)"),"(?:".concat(r,":){3}(?:(?::").concat(r,"){0,2}:").concat(n,"|(?::").concat(r,"){1,4}|:)"),"(?:".concat(r,":){2}(?:(?::").concat(r,"){0,3}:").concat(n,"|(?::").concat(r,"){1,5}|:)"),"(?:".concat(r,":){1}(?:(?::").concat(r,"){0,4}:").concat(n,"|(?::").concat(r,"){1,6}|:)"),"(?::(?:(?::".concat(r,"){0,5}:").concat(n,"|(?::").concat(r,"){1,7}|:))")],o="(?:".concat(a.join("|"),")").concat("(?:%[0-9a-zA-Z]{1,})?"),i=new RegExp("(?:^".concat(n,"$)|(?:^").concat(o,"$)")),s=new RegExp("^".concat(n,"$")),c=new RegExp("^".concat(o,"$")),l=function(e){return e&&e.exact?i:new RegExp("(?:".concat(t(e)).concat(n).concat(t(e),")|(?:").concat(t(e)).concat(o).concat(t(e),")"),"g")};l.v4=function(e){return e&&e.exact?s:new RegExp("".concat(t(e)).concat(n).concat(t(e)),"g")},l.v6=function(e){return e&&e.exact?c:new RegExp("".concat(t(e)).concat(o).concat(t(e)),"g")};var u=l.v4().source,d=l.v6().source,h="(?:".concat("(?:(?:[a-z]+:)?//)","|www\\.)").concat("(?:\\S+(?::\\S*)?@)?","(?:localhost|").concat(u,"|").concat(d,"|").concat("(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)").concat("(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*").concat("(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))",")").concat("(?::\\d{2,5})?").concat('(?:[/?#][^\\s"]*)?');return Sh=new RegExp("(?:^".concat(h,"$)"),"i")}())},hex:function(e){return"string"===typeof e&&!!e.match(Ih)}};const Nh=function(e,t,n,r,a){if(e.required&&void 0===t)kh(e,t,n,r,a);else{var o=e.type;["integer","float","array","regexp","object","method","email","number","date","url","hex"].indexOf(o)>-1?Eh[o](t)||r.push(ph(a.messages.types[o],e.fullField,e.type)):o&&lr(t)!==e.type&&r.push(ph(a.messages.types[o],e.fullField,e.type))}};const Th={required:kh,whitespace:function(e,t,n,r,a){(/^\s+$/.test(t)||""===t)&&r.push(ph(a.messages.whitespace,e.fullField))},type:Nh,range:wh,enum:function(e,t,n,r,a){e[xh]=Array.isArray(e[xh])?e[xh]:[],-1===e[xh].indexOf(t)&&r.push(ph(a.messages[xh],e.fullField,e[xh].join(", ")))},pattern:function(e,t,n,r,a){if(e.pattern)if(e.pattern instanceof RegExp)e.pattern.lastIndex=0,e.pattern.test(t)||r.push(ph(a.messages.pattern.mismatch,e.fullField,t,e.pattern));else if("string"===typeof e.pattern){new RegExp(e.pattern).test(t)||r.push(ph(a.messages.pattern.mismatch,e.fullField,t,e.pattern))}}};const Rh=function(e,t,n,r,a){var o=[],i=Array.isArray(t)?"array":lr(t);Th.required(e,t,r,o,a,i),n(o)};const Ah=function(e,t,n,r,a){var o=e.type,i=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t,o)&&!e.required)return n();Th.required(e,t,r,i,a,o),fh(t,o)||Th.type(e,t,r,i,a)}n(i)},Oh={string:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t,"string")&&!e.required)return n();Th.required(e,t,r,o,a,"string"),fh(t,"string")||(Th.type(e,t,r,o,a),Th.range(e,t,r,o,a),Th.pattern(e,t,r,o,a),!0===e.whitespace&&Th.whitespace(e,t,r,o,a))}n(o)},method:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t)&&!e.required)return n();Th.required(e,t,r,o,a),void 0!==t&&Th.type(e,t,r,o,a)}n(o)},number:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(""===t&&(t=void 0),fh(t)&&!e.required)return n();Th.required(e,t,r,o,a),void 0!==t&&(Th.type(e,t,r,o,a),Th.range(e,t,r,o,a))}n(o)},boolean:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t)&&!e.required)return n();Th.required(e,t,r,o,a),void 0!==t&&Th.type(e,t,r,o,a)}n(o)},regexp:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t)&&!e.required)return n();Th.required(e,t,r,o,a),fh(t)||Th.type(e,t,r,o,a)}n(o)},integer:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t)&&!e.required)return n();Th.required(e,t,r,o,a),void 0!==t&&(Th.type(e,t,r,o,a),Th.range(e,t,r,o,a))}n(o)},float:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t)&&!e.required)return n();Th.required(e,t,r,o,a),void 0!==t&&(Th.type(e,t,r,o,a),Th.range(e,t,r,o,a))}n(o)},array:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if((void 0===t||null===t)&&!e.required)return n();Th.required(e,t,r,o,a,"array"),void 0!==t&&null!==t&&(Th.type(e,t,r,o,a),Th.range(e,t,r,o,a))}n(o)},object:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t)&&!e.required)return n();Th.required(e,t,r,o,a),void 0!==t&&Th.type(e,t,r,o,a)}n(o)},enum:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t)&&!e.required)return n();Th.required(e,t,r,o,a),void 0!==t&&Th.enum(e,t,r,o,a)}n(o)},pattern:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t,"string")&&!e.required)return n();Th.required(e,t,r,o,a),fh(t,"string")||Th.pattern(e,t,r,o,a)}n(o)},date:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t,"date")&&!e.required)return n();var i;if(Th.required(e,t,r,o,a),!fh(t,"date"))i=t instanceof Date?t:new Date(t),Th.type(e,i,r,o,a),i&&Th.range(e,i.getTime(),r,o,a)}n(o)},url:Ah,hex:Ah,email:Ah,required:Rh,any:function(e,t,n,r,a){var o=[];if(e.required||!e.required&&r.hasOwnProperty(e.field)){if(fh(t)&&!e.required)return n();Th.required(e,t,r,o,a)}n(o)}};var Fh=function(){function e(t){jr(this,e),dr(this,"rules",null),dr(this,"_messages",lh),this.define(t)}return Gr(e,[{key:"define",value:function(e){var t=this;if(!e)throw new Error("Cannot configure a schema with no rules");if("object"!==lr(e)||Array.isArray(e))throw new Error("Rules must be an object");this.rules={},Object.keys(e).forEach((function(n){var r=e[n];t.rules[n]=Array.isArray(r)?r:[r]}))}},{key:"messages",value:function(e){return e&&(this._messages=yh(ch(),e)),this._messages}},{key:"validate",value:function(t){var n=this,r=t,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){};if("function"===typeof a&&(o=a,a={}),!this.rules||0===Object.keys(this.rules).length)return o&&o(null,r),Promise.resolve(r);if(a.messages){var i=this.messages();i===lh&&(i=ch()),yh(i,a.messages),a.messages=i}else a.messages=this.messages();var s={};(a.keys||Object.keys(this.rules)).forEach((function(e){var a=n.rules[e],o=r[e];a.forEach((function(a){var i=a;"function"===typeof i.transform&&(r===t&&(r=xr({},r)),void 0!==(o=r[e]=i.transform(o))&&null!==o&&(i.type=i.type||(Array.isArray(o)?"array":lr(o)))),(i="function"===typeof i?{validator:i}:xr({},i)).validator=n.getValidationMethod(i),i.validator&&(i.field=e,i.fullField=i.fullField||e,i.type=n.getType(i),s[e]=s[e]||[],s[e].push({rule:i,value:o,source:r,field:e}))}))}));var c={};return vh(s,a,(function(t,n){var o,i=t.rule,s=("object"===i.type||"array"===i.type)&&("object"===lr(i.fields)||"object"===lr(i.defaultField));function l(e,t){return xr(xr({},t),{},{fullField:"".concat(i.fullField,".").concat(e),fullFields:i.fullFields?[].concat(br(i.fullFields),[e]):[e]})}function u(){var o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],u=Array.isArray(o)?o:[o];!a.suppressWarning&&u.length&&e.warning("async-validator:",u),u.length&&void 0!==i.message&&(u=[].concat(i.message));var d=u.map(bh(i,r));if(a.first&&d.length)return c[i.field]=1,n(d);if(s){if(i.required&&!t.value)return void 0!==i.message?d=[].concat(i.message).map(bh(i,r)):a.error&&(d=[a.error(i,ph(a.messages.required,i.field))]),n(d);var h={};i.defaultField&&Object.keys(t.value).map((function(e){h[e]=i.defaultField})),h=xr(xr({},h),t.rule.fields);var p={};Object.keys(h).forEach((function(e){var t=h[e],n=Array.isArray(t)?t:[t];p[e]=n.map(l.bind(null,e))}));var f=new e(p);f.messages(a.messages),t.rule.options&&(t.rule.options.messages=a.messages,t.rule.options.error=a.error),f.validate(t.value,t.rule.options||a,(function(e){var t=[];d&&d.length&&t.push.apply(t,br(d)),e&&e.length&&t.push.apply(t,br(e)),n(t.length?t:null)}))}else n(d)}if(s=s&&(i.required||!i.required&&t.value),i.field=t.field,i.asyncValidator)o=i.asyncValidator(i,t.value,u,t.source,a);else if(i.validator){try{o=i.validator(i,t.value,u,t.source,a)}catch(p){var d,h;null===(d=(h=console).error)||void 0===d||d.call(h,p),a.suppressValidatorError||setTimeout((function(){throw p}),0),u(p.message)}!0===o?u():!1===o?u("function"===typeof i.message?i.message(i.fullField||i.field):i.message||"".concat(i.fullField||i.field," fails")):o instanceof Array?u(o):o instanceof Error&&u(o.message)}o&&o.then&&o.then((function(){return u()}),(function(e){return u(e)}))}),(function(e){!function(e){var t=[],n={};function a(e){var n;Array.isArray(e)?t=(n=t).concat.apply(n,br(e)):t.push(e)}for(var i=0;i<e.length;i++)a(e[i]);t.length?(n=hh(t),o(t,n)):o(null,r)}(e)}),r)}},{key:"getType",value:function(e){if(void 0===e.type&&e.pattern instanceof RegExp&&(e.type="pattern"),"function"!==typeof e.validator&&e.type&&!Oh.hasOwnProperty(e.type))throw new Error(ph("Unknown rule type %s",e.type));return e.type||"string"}},{key:"getValidationMethod",value:function(e){if("function"===typeof e.validator)return e.validator;var t=Object.keys(e),n=t.indexOf("message");return-1!==n&&t.splice(n,1),1===t.length&&"required"===t[0]?Oh.required:Oh[this.getType(e)]||void 0}}]),e}();dr(Fh,"register",(function(e,t){if("function"!==typeof t)throw new Error("Cannot register a validator by type, validator is not a function");Oh[e]=t})),dr(Fh,"warning",(function(){})),dr(Fh,"messages",lh),dr(Fh,"validators",Oh);var _h="'${name}' is not a valid ${type}",Dh={default:"Validation error on field '${name}'",required:"'${name}' is required",enum:"'${name}' must be one of [${enum}]",whitespace:"'${name}' cannot be empty",date:{format:"'${name}' is invalid for format date",parse:"'${name}' could not be parsed as date",invalid:"'${name}' is invalid date"},types:{string:_h,method:_h,array:_h,object:_h,number:_h,date:_h,boolean:_h,integer:_h,float:_h,regexp:_h,email:_h,url:_h,hex:_h},string:{len:"'${name}' must be exactly ${len} characters",min:"'${name}' must be at least ${min} characters",max:"'${name}' cannot be longer than ${max} characters",range:"'${name}' must be between ${min} and ${max} characters"},number:{len:"'${name}' must equal ${len}",min:"'${name}' cannot be less than ${min}",max:"'${name}' cannot be greater than ${max}",range:"'${name}' must be between ${min} and ${max}"},array:{len:"'${name}' must be exactly ${len} in length",min:"'${name}' cannot be less than ${min} in length",max:"'${name}' cannot be greater than ${max} in length",range:"'${name}' must be between ${min} and ${max} in length"},pattern:{mismatch:"'${name}' does not match pattern ${pattern}"}},Mh=Fh;function Ph(e,t){return e.replace(/\$\{\w+\}/g,(function(e){var n=e.slice(2,-1);return t[n]}))}var Lh="CODE_LOGIC_ERROR";function zh(e,t,n,r,a){return Bh.apply(this,arguments)}function Bh(){return Bh=nh(eh().mark((function e(t,n,r,a,i){var s,c,l,u,d,h,p,f,g;return eh().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return delete(s=xr({},r)).ruleIndex,Mh.warning=function(){},s.validator&&(c=s.validator,s.validator=function(){try{return c.apply(void 0,arguments)}catch(e){return console.error(e),Promise.reject(Lh)}}),l=null,s&&"array"===s.type&&s.defaultField&&(l=s.defaultField,delete s.defaultField),u=new Mh(dr({},t,[s])),d=Di(Dh,a.validateMessages),u.messages(d),h=[],e.prev=10,e.next=13,Promise.resolve(u.validate(dr({},t,n),xr({},a)));case 13:e.next=18;break;case 15:e.prev=15,e.t0=e.catch(10),e.t0.errors&&(h=e.t0.errors.map((function(e,t){var n=e.message,r=n===Lh?d.default:n;return o.isValidElement(r)?o.cloneElement(r,{key:"error_".concat(t)}):r})));case 18:if(h.length||!l){e.next=23;break}return e.next=21,Promise.all(n.map((function(e,n){return zh("".concat(t,".").concat(n),e,l,a,i)})));case 21:return p=e.sent,e.abrupt("return",p.reduce((function(e,t){return[].concat(br(e),br(t))}),[]));case 23:return f=xr(xr({},r),{},{name:t,enum:(r.enum||[]).join(", ")},i),g=h.map((function(e){return"string"===typeof e?Ph(e,f):e})),e.abrupt("return",g);case 26:case"end":return e.stop()}}),e,null,[[10,15]])}))),Bh.apply(this,arguments)}function Wh(e,t,n,r,a,o){var i,s=e.join("."),c=n.map((function(e,t){var n=e.validator,r=xr(xr({},e),{},{ruleIndex:t});return n&&(r.validator=function(e,t,r){var a=!1,o=n(e,t,(function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];Promise.resolve().then((function(){Ur(!a,"Your validator function has already return a promise. `callback` will be ignored."),a||r.apply(void 0,t)}))}));a=o&&"function"===typeof o.then&&"function"===typeof o.catch,Ur(a,"`callback` is deprecated. Please return a promise instead."),a&&o.then((function(){r()})).catch((function(e){r(e||" ")}))}),r})).sort((function(e,t){var n=e.warningOnly,r=e.ruleIndex,a=t.warningOnly,o=t.ruleIndex;return!!n===!!a?r-o:n?1:-1}));if(!0===a)i=new Promise(function(){var e=nh(eh().mark((function e(n,a){var i,l,u;return eh().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:i=0;case 1:if(!(i<c.length)){e.next=12;break}return l=c[i],e.next=5,zh(s,t,l,r,o);case 5:if(!(u=e.sent).length){e.next=9;break}return a([{errors:u,rule:l}]),e.abrupt("return");case 9:i+=1,e.next=1;break;case 12:n([]);case 13:case"end":return e.stop()}}),e)})));return function(t,n){return e.apply(this,arguments)}}());else{var l=c.map((function(e){return zh(s,t,e,r,o).then((function(t){return{errors:t,rule:e}}))}));i=(a?function(e){return Vh.apply(this,arguments)}(l):function(e){return Uh.apply(this,arguments)}(l)).then((function(e){return Promise.reject(e)}))}return i.catch((function(e){return e})),i}function Uh(){return(Uh=nh(eh().mark((function e(t){return eh().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",Promise.all(t).then((function(e){var t;return(t=[]).concat.apply(t,br(e))})));case 1:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function Vh(){return Vh=nh(eh().mark((function e(t){var n;return eh().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return n=0,e.abrupt("return",new Promise((function(e){t.forEach((function(r){r.then((function(r){r.errors.length&&e([r]),(n+=1)===t.length&&e([])}))}))})));case 2:case"end":return e.stop()}}),e)}))),Vh.apply(this,arguments)}function jh(e){return sh(e)}function Hh(e,t){var n={};return t.forEach((function(t){var r=Ri(e,t);n=Oi(n,t,r)})),n}function Gh(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return e&&e.some((function(e){return qh(t,e,n)}))}function qh(e,t){return!(!e||!t)&&(!(!(arguments.length>2&&void 0!==arguments[2]&&arguments[2])&&e.length!==t.length)&&t.every((function(t,n){return e[n]===t})))}function Kh(e){var t=arguments.length<=1?void 0:arguments[1];return t&&t.target&&"object"===lr(t.target)&&e in t.target?t.target[e]:t}function Xh(e,t,n){var r=e.length;if(t<0||t>=r||n<0||n>=r)return e;var a=e[t],o=t-n;return o>0?[].concat(br(e.slice(0,n)),[a],br(e.slice(n,t)),br(e.slice(t+1,r))):o<0?[].concat(br(e.slice(0,t)),br(e.slice(t+1,n+1)),[a],br(e.slice(n+1,r))):e}var $h=["name"],Yh=[];function Qh(e,t,n,r,a,o){return"function"===typeof e?e(t,n,"source"in o?{source:o.source}:{}):r!==a}var Zh=function(e){Hi(n,e);var t=vc(n);function n(e){var r;(jr(this,n),dr(Wi(r=t.call(this,e)),"state",{resetCount:0}),dr(Wi(r),"cancelRegisterFunc",null),dr(Wi(r),"mounted",!1),dr(Wi(r),"touched",!1),dr(Wi(r),"dirty",!1),dr(Wi(r),"validatePromise",void 0),dr(Wi(r),"prevValidating",void 0),dr(Wi(r),"errors",Yh),dr(Wi(r),"warnings",Yh),dr(Wi(r),"cancelRegister",(function(){var e=r.props,t=e.preserve,n=e.isListField,a=e.name;r.cancelRegisterFunc&&r.cancelRegisterFunc(n,t,jh(a)),r.cancelRegisterFunc=null})),dr(Wi(r),"getNamePath",(function(){var e=r.props,t=e.name,n=e.fieldContext.prefixName;return void 0!==t?[].concat(br(void 0===n?[]:n),br(t)):[]})),dr(Wi(r),"getRules",(function(){var e=r.props,t=e.rules,n=void 0===t?[]:t,a=e.fieldContext;return n.map((function(e){return"function"===typeof e?e(a):e}))})),dr(Wi(r),"refresh",(function(){r.mounted&&r.setState((function(e){return{resetCount:e.resetCount+1}}))})),dr(Wi(r),"metaCache",null),dr(Wi(r),"triggerMetaEvent",(function(e){var t=r.props.onMetaChange;if(t){var n=xr(xr({},r.getMeta()),{},{destroy:e});Vr(r.metaCache,n)||t(n),r.metaCache=n}else r.metaCache=null})),dr(Wi(r),"onStoreChange",(function(e,t,n){var a=r.props,o=a.shouldUpdate,i=a.dependencies,s=void 0===i?[]:i,c=a.onReset,l=n.store,u=r.getNamePath(),d=r.getValue(e),h=r.getValue(l),p=t&&Gh(t,u);switch("valueUpdate"!==n.type||"external"!==n.source||Vr(d,h)||(r.touched=!0,r.dirty=!0,r.validatePromise=null,r.errors=Yh,r.warnings=Yh,r.triggerMetaEvent()),n.type){case"reset":if(!t||p)return r.touched=!1,r.dirty=!1,r.validatePromise=void 0,r.errors=Yh,r.warnings=Yh,r.triggerMetaEvent(),null===c||void 0===c||c(),void r.refresh();break;case"remove":if(o)return void r.reRender();break;case"setField":var f=n.data;if(p)return"touched"in f&&(r.touched=f.touched),"validating"in f&&!("originRCField"in f)&&(r.validatePromise=f.validating?Promise.resolve([]):null),"errors"in f&&(r.errors=f.errors||Yh),"warnings"in f&&(r.warnings=f.warnings||Yh),r.dirty=!0,r.triggerMetaEvent(),void r.reRender();if("value"in f&&Gh(t,u,!0))return void r.reRender();if(o&&!u.length&&Qh(o,e,l,d,h,n))return void r.reRender();break;case"dependenciesUpdate":if(s.map(jh).some((function(e){return Gh(n.relatedFields,e)})))return void r.reRender();break;default:if(p||(!s.length||u.length||o)&&Qh(o,e,l,d,h,n))return void r.reRender()}!0===o&&r.reRender()})),dr(Wi(r),"validateRules",(function(e){var t=r.getNamePath(),n=r.getValue(),a=e||{},o=a.triggerName,i=a.validateOnly,s=void 0!==i&&i,c=Promise.resolve().then(nh(eh().mark((function a(){var i,s,l,u,d,h,p;return eh().wrap((function(a){for(;;)switch(a.prev=a.next){case 0:if(r.mounted){a.next=2;break}return a.abrupt("return",[]);case 2:if(i=r.props,s=i.validateFirst,l=void 0!==s&&s,u=i.messageVariables,d=i.validateDebounce,h=r.getRules(),o&&(h=h.filter((function(e){return e})).filter((function(e){var t=e.validateTrigger;return!t||sh(t).includes(o)}))),!d||!o){a.next=10;break}return a.next=8,new Promise((function(e){setTimeout(e,d)}));case 8:if(r.validatePromise===c){a.next=10;break}return a.abrupt("return",[]);case 10:return(p=Wh(t,n,h,e,l,u)).catch((function(e){return e})).then((function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Yh;if(r.validatePromise===c){var t;r.validatePromise=null;var n=[],a=[];null===(t=e.forEach)||void 0===t||t.call(e,(function(e){var t=e.rule.warningOnly,r=e.errors,o=void 0===r?Yh:r;t?a.push.apply(a,br(o)):n.push.apply(n,br(o))})),r.errors=n,r.warnings=a,r.triggerMetaEvent(),r.reRender()}})),a.abrupt("return",p);case 13:case"end":return a.stop()}}),a)}))));return s||(r.validatePromise=c,r.dirty=!0,r.errors=Yh,r.warnings=Yh,r.triggerMetaEvent(),r.reRender()),c})),dr(Wi(r),"isFieldValidating",(function(){return!!r.validatePromise})),dr(Wi(r),"isFieldTouched",(function(){return r.touched})),dr(Wi(r),"isFieldDirty",(function(){return!(!r.dirty&&void 0===r.props.initialValue)||void 0!==(0,r.props.fieldContext.getInternalHooks(rh).getInitialValue)(r.getNamePath())})),dr(Wi(r),"getErrors",(function(){return r.errors})),dr(Wi(r),"getWarnings",(function(){return r.warnings})),dr(Wi(r),"isListField",(function(){return r.props.isListField})),dr(Wi(r),"isList",(function(){return r.props.isList})),dr(Wi(r),"isPreserve",(function(){return r.props.preserve})),dr(Wi(r),"getMeta",(function(){return r.prevValidating=r.isFieldValidating(),{touched:r.isFieldTouched(),validating:r.prevValidating,errors:r.errors,warnings:r.warnings,name:r.getNamePath(),validated:null===r.validatePromise}})),dr(Wi(r),"getOnlyChild",(function(e){if("function"===typeof e){var t=r.getMeta();return xr(xr({},r.getOnlyChild(e(r.getControlled(),t,r.props.fieldContext))),{},{isFunction:!0})}var n=js(e);return 1===n.length&&o.isValidElement(n[0])?{child:n[0],isFunction:!1}:{child:n,isFunction:!1}})),dr(Wi(r),"getValue",(function(e){var t=r.props.fieldContext.getFieldsValue,n=r.getNamePath();return Ri(e||t(!0),n)})),dr(Wi(r),"getControlled",(function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=r.props,n=t.name,a=t.trigger,o=t.validateTrigger,i=t.getValueFromEvent,s=t.normalize,c=t.valuePropName,l=t.getValueProps,u=t.fieldContext,d=void 0!==o?o:u.validateTrigger,h=r.getNamePath(),p=u.getInternalHooks,f=u.getFieldsValue,g=p(rh).dispatch,m=r.getValue(),v=l||function(e){return dr({},c,e)},b=e[a],y=void 0!==n?v(m):{};var x=xr(xr({},e),y);return x[a]=function(){var e;r.touched=!0,r.dirty=!0,r.triggerMetaEvent();for(var t=arguments.length,n=new Array(t),a=0;a<t;a++)n[a]=arguments[a];e=i?i.apply(void 0,n):Kh.apply(void 0,[c].concat(n)),s&&(e=s(e,m,f(!0))),g({type:"updateValue",namePath:h,value:e}),b&&b.apply(void 0,n)},sh(d||[]).forEach((function(e){var t=x[e];x[e]=function(){t&&t.apply(void 0,arguments);var n=r.props.rules;n&&n.length&&g({type:"validateField",namePath:h,triggerName:e})}})),x})),e.fieldContext)&&(0,(0,e.fieldContext.getInternalHooks)(rh).initEntityValue)(Wi(r));return r}return Gr(n,[{key:"componentDidMount",value:function(){var e=this.props,t=e.shouldUpdate,n=e.fieldContext;if(this.mounted=!0,n){var r=(0,n.getInternalHooks)(rh).registerField;this.cancelRegisterFunc=r(this)}!0===t&&this.reRender()}},{key:"componentWillUnmount",value:function(){this.cancelRegister(),this.triggerMetaEvent(!0),this.mounted=!1}},{key:"reRender",value:function(){this.mounted&&this.forceUpdate()}},{key:"render",value:function(){var e,t=this.state.resetCount,n=this.props.children,r=this.getOnlyChild(n),a=r.child;return r.isFunction?e=a:o.isValidElement(a)?e=o.cloneElement(a,this.getControlled(a.props)):(Ur(!a,"`children` of Field is not validate ReactElement."),e=a),o.createElement(o.Fragment,{key:t},e)}}]),n}(o.Component);dr(Zh,"contextType",oh),dr(Zh,"defaultProps",{trigger:"onChange",valuePropName:"value"});const Jh=function(e){var t=e.name,n=Cs(e,$h),r=o.useContext(oh),a=o.useContext(ih),i=void 0!==t?jh(t):void 0,s="keep";return n.isListField||(s="_".concat((i||[]).join("_"))),o.createElement(Zh,Pa({key:s,name:i,isListField:!!a},n,{fieldContext:r}))};const ep=function(e){var t=e.name,n=e.initialValue,r=e.children,a=e.rules,i=e.validateTrigger,s=e.isListField,c=o.useContext(oh),l=o.useContext(ih),u=o.useRef({keys:[],id:0}).current,d=o.useMemo((function(){var e=jh(c.prefixName)||[];return[].concat(br(e),br(jh(t)))}),[c.prefixName,t]),h=o.useMemo((function(){return xr(xr({},c),{},{prefixName:d})}),[c,d]),p=o.useMemo((function(){return{getKey:function(e){var t=d.length,n=e[t];return[u.keys[n],e.slice(t+1)]}}}),[d]);return"function"!==typeof r?(Ur(!1,"Form.List only accepts function as children."),null):o.createElement(ih.Provider,{value:p},o.createElement(oh.Provider,{value:h},o.createElement(Jh,{name:[],shouldUpdate:function(e,t,n){return"internal"!==n.source&&e!==t},rules:a,validateTrigger:i,initialValue:n,isList:!0,isListField:null!==s&&void 0!==s?s:!!l},(function(e,t){var n=e.value,a=void 0===n?[]:n,o=e.onChange,i=c.getFieldValue,s=function(){return i(d||[])||[]},l={add:function(e,t){var n=s();t>=0&&t<=n.length?(u.keys=[].concat(br(u.keys.slice(0,t)),[u.id],br(u.keys.slice(t))),o([].concat(br(n.slice(0,t)),[e],br(n.slice(t))))):(u.keys=[].concat(br(u.keys),[u.id]),o([].concat(br(n),[e]))),u.id+=1},remove:function(e){var t=s(),n=new Set(Array.isArray(e)?e:[e]);n.size<=0||(u.keys=u.keys.filter((function(e,t){return!n.has(t)})),o(t.filter((function(e,t){return!n.has(t)}))))},move:function(e,t){if(e!==t){var n=s();e<0||e>=n.length||t<0||t>=n.length||(u.keys=Xh(u.keys,e,t),o(Xh(n,e,t)))}}},h=a||[];return Array.isArray(h)||(h=[]),r(h.map((function(e,t){var n=u.keys[t];return void 0===n&&(u.keys[t]=u.id,n=u.keys[t],u.id+=1),{name:t,key:n,isListField:!0}})),l,t)}))))};var tp="__@field_split__";function np(e){return e.map((function(e){return"".concat(lr(e),":").concat(e)})).join(tp)}var rp=function(){function e(){jr(this,e),dr(this,"kvs",new Map)}return Gr(e,[{key:"set",value:function(e,t){this.kvs.set(np(e),t)}},{key:"get",value:function(e){return this.kvs.get(np(e))}},{key:"update",value:function(e,t){var n=t(this.get(e));n?this.set(e,n):this.delete(e)}},{key:"delete",value:function(e){this.kvs.delete(np(e))}},{key:"map",value:function(e){return br(this.kvs.entries()).map((function(t){var n=mr(t,2),r=n[0],a=n[1],o=r.split(tp);return e({key:o.map((function(e){var t=mr(e.match(/^([^:]*):(.*)$/),3),n=t[1],r=t[2];return"number"===n?Number(r):r})),value:a})}))}},{key:"toJSON",value:function(){var e={};return this.map((function(t){var n=t.key,r=t.value;return e[n.join(".")]=r,null})),e}}]),e}();const ap=rp;var op=["name"],ip=Gr((function e(t){var n=this;jr(this,e),dr(this,"formHooked",!1),dr(this,"forceRootUpdate",void 0),dr(this,"subscribable",!0),dr(this,"store",{}),dr(this,"fieldEntities",[]),dr(this,"initialValues",{}),dr(this,"callbacks",{}),dr(this,"validateMessages",null),dr(this,"preserve",null),dr(this,"lastValidatePromise",null),dr(this,"getForm",(function(){return{getFieldValue:n.getFieldValue,getFieldsValue:n.getFieldsValue,getFieldError:n.getFieldError,getFieldWarning:n.getFieldWarning,getFieldsError:n.getFieldsError,isFieldsTouched:n.isFieldsTouched,isFieldTouched:n.isFieldTouched,isFieldValidating:n.isFieldValidating,isFieldsValidating:n.isFieldsValidating,resetFields:n.resetFields,setFields:n.setFields,setFieldValue:n.setFieldValue,setFieldsValue:n.setFieldsValue,validateFields:n.validateFields,submit:n.submit,_init:!0,getInternalHooks:n.getInternalHooks}})),dr(this,"getInternalHooks",(function(e){return e===rh?(n.formHooked=!0,{dispatch:n.dispatch,initEntityValue:n.initEntityValue,registerField:n.registerField,useSubscribe:n.useSubscribe,setInitialValues:n.setInitialValues,destroyForm:n.destroyForm,setCallbacks:n.setCallbacks,setValidateMessages:n.setValidateMessages,getFields:n.getFields,setPreserve:n.setPreserve,getInitialValue:n.getInitialValue,registerWatch:n.registerWatch}):(Ur(!1,"`getInternalHooks` is internal usage. Should not call directly."),null)})),dr(this,"useSubscribe",(function(e){n.subscribable=e})),dr(this,"prevWithoutPreserves",null),dr(this,"setInitialValues",(function(e,t){if(n.initialValues=e||{},t){var r,a=Di(e,n.store);null===(r=n.prevWithoutPreserves)||void 0===r||r.map((function(t){var n=t.key;a=Oi(a,n,Ri(e,n))})),n.prevWithoutPreserves=null,n.updateStore(a)}})),dr(this,"destroyForm",(function(e){if(e)n.updateStore({});else{var t=new ap;n.getFieldEntities(!0).forEach((function(e){n.isMergedPreserve(e.isPreserve())||t.set(e.getNamePath(),!0)})),n.prevWithoutPreserves=t}})),dr(this,"getInitialValue",(function(e){var t=Ri(n.initialValues,e);return e.length?Di(t):t})),dr(this,"setCallbacks",(function(e){n.callbacks=e})),dr(this,"setValidateMessages",(function(e){n.validateMessages=e})),dr(this,"setPreserve",(function(e){n.preserve=e})),dr(this,"watchList",[]),dr(this,"registerWatch",(function(e){return n.watchList.push(e),function(){n.watchList=n.watchList.filter((function(t){return t!==e}))}})),dr(this,"notifyWatch",(function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];if(n.watchList.length){var t=n.getFieldsValue(),r=n.getFieldsValue(!0);n.watchList.forEach((function(n){n(t,r,e)}))}})),dr(this,"timeoutId",null),dr(this,"warningUnhooked",(function(){0})),dr(this,"updateStore",(function(e){n.store=e})),dr(this,"getFieldEntities",(function(){return arguments.length>0&&void 0!==arguments[0]&&arguments[0]?n.fieldEntities.filter((function(e){return e.getNamePath().length})):n.fieldEntities})),dr(this,"getFieldsMap",(function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=new ap;return n.getFieldEntities(e).forEach((function(e){var n=e.getNamePath();t.set(n,e)})),t})),dr(this,"getFieldEntitiesForNamePathList",(function(e){if(!e)return n.getFieldEntities(!0);var t=n.getFieldsMap(!0);return e.map((function(e){var n=jh(e);return t.get(n)||{INVALIDATE_NAME_PATH:jh(e)}}))})),dr(this,"getFieldsValue",(function(e,t){var r,a,o;if(n.warningUnhooked(),!0===e||Array.isArray(e)?(r=e,a=t):e&&"object"===lr(e)&&(o=e.strict,a=e.filter),!0===r&&!a)return n.store;var i=n.getFieldEntitiesForNamePathList(Array.isArray(r)?r:null),s=[];return i.forEach((function(e){var t,n,i,c,l="INVALIDATE_NAME_PATH"in e?e.INVALIDATE_NAME_PATH:e.getNamePath();if(o){if(null!==(i=(c=e).isList)&&void 0!==i&&i.call(c))return}else if(!r&&null!==(t=(n=e).isListField)&&void 0!==t&&t.call(n))return;if(a){var u="getMeta"in e?e.getMeta():null;a(u)&&s.push(l)}else s.push(l)})),Hh(n.store,s.map(jh))})),dr(this,"getFieldValue",(function(e){n.warningUnhooked();var t=jh(e);return Ri(n.store,t)})),dr(this,"getFieldsError",(function(e){return n.warningUnhooked(),n.getFieldEntitiesForNamePathList(e).map((function(t,n){return t&&!("INVALIDATE_NAME_PATH"in t)?{name:t.getNamePath(),errors:t.getErrors(),warnings:t.getWarnings()}:{name:jh(e[n]),errors:[],warnings:[]}}))})),dr(this,"getFieldError",(function(e){n.warningUnhooked();var t=jh(e);return n.getFieldsError([t])[0].errors})),dr(this,"getFieldWarning",(function(e){n.warningUnhooked();var t=jh(e);return n.getFieldsError([t])[0].warnings})),dr(this,"isFieldsTouched",(function(){n.warningUnhooked();for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var a,o=t[0],i=t[1],s=!1;0===t.length?a=null:1===t.length?Array.isArray(o)?(a=o.map(jh),s=!1):(a=null,s=o):(a=o.map(jh),s=i);var c=n.getFieldEntities(!0),l=function(e){return e.isFieldTouched()};if(!a)return s?c.every((function(e){return l(e)||e.isList()})):c.some(l);var u=new ap;a.forEach((function(e){u.set(e,[])})),c.forEach((function(e){var t=e.getNamePath();a.forEach((function(n){n.every((function(e,n){return t[n]===e}))&&u.update(n,(function(t){return[].concat(br(t),[e])}))}))}));var d=function(e){return e.some(l)},h=u.map((function(e){return e.value}));return s?h.every(d):h.some(d)})),dr(this,"isFieldTouched",(function(e){return n.warningUnhooked(),n.isFieldsTouched([e])})),dr(this,"isFieldsValidating",(function(e){n.warningUnhooked();var t=n.getFieldEntities();if(!e)return t.some((function(e){return e.isFieldValidating()}));var r=e.map(jh);return t.some((function(e){var t=e.getNamePath();return Gh(r,t)&&e.isFieldValidating()}))})),dr(this,"isFieldValidating",(function(e){return n.warningUnhooked(),n.isFieldsValidating([e])})),dr(this,"resetWithFieldInitialValue",(function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=new ap,r=n.getFieldEntities(!0);r.forEach((function(e){var n=e.props.initialValue,r=e.getNamePath();if(void 0!==n){var a=t.get(r)||new Set;a.add({entity:e,value:n}),t.set(r,a)}}));var a;e.entities?a=e.entities:e.namePathList?(a=[],e.namePathList.forEach((function(e){var n,r=t.get(e);r&&(n=a).push.apply(n,br(br(r).map((function(e){return e.entity}))))}))):a=r,a.forEach((function(r){if(void 0!==r.props.initialValue){var a=r.getNamePath();if(void 0!==n.getInitialValue(a))Ur(!1,"Form already set 'initialValues' with path '".concat(a.join("."),"'. Field can not overwrite it."));else{var o=t.get(a);if(o&&o.size>1)Ur(!1,"Multiple Field with path '".concat(a.join("."),"' set 'initialValue'. Can not decide which one to pick."));else if(o){var i=n.getFieldValue(a);r.isListField()||e.skipExist&&void 0!==i||n.updateStore(Oi(n.store,a,br(o)[0].value))}}}}))})),dr(this,"resetFields",(function(e){n.warningUnhooked();var t=n.store;if(!e)return n.updateStore(Di(n.initialValues)),n.resetWithFieldInitialValue(),n.notifyObservers(t,null,{type:"reset"}),void n.notifyWatch();var r=e.map(jh);r.forEach((function(e){var t=n.getInitialValue(e);n.updateStore(Oi(n.store,e,t))})),n.resetWithFieldInitialValue({namePathList:r}),n.notifyObservers(t,r,{type:"reset"}),n.notifyWatch(r)})),dr(this,"setFields",(function(e){n.warningUnhooked();var t=n.store,r=[];e.forEach((function(e){var a=e.name,o=Cs(e,op),i=jh(a);r.push(i),"value"in o&&n.updateStore(Oi(n.store,i,o.value)),n.notifyObservers(t,[i],{type:"setField",data:e})})),n.notifyWatch(r)})),dr(this,"getFields",(function(){return n.getFieldEntities(!0).map((function(e){var t=e.getNamePath(),r=xr(xr({},e.getMeta()),{},{name:t,value:n.getFieldValue(t)});return Object.defineProperty(r,"originRCField",{value:!0}),r}))})),dr(this,"initEntityValue",(function(e){var t=e.props.initialValue;if(void 0!==t){var r=e.getNamePath();void 0===Ri(n.store,r)&&n.updateStore(Oi(n.store,r,t))}})),dr(this,"isMergedPreserve",(function(e){var t=void 0!==e?e:n.preserve;return null===t||void 0===t||t})),dr(this,"registerField",(function(e){n.fieldEntities.push(e);var t=e.getNamePath();if(n.notifyWatch([t]),void 0!==e.props.initialValue){var r=n.store;n.resetWithFieldInitialValue({entities:[e],skipExist:!0}),n.notifyObservers(r,[e.getNamePath()],{type:"valueUpdate",source:"internal"})}return function(r,a){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];if(n.fieldEntities=n.fieldEntities.filter((function(t){return t!==e})),!n.isMergedPreserve(a)&&(!r||o.length>1)){var i=r?void 0:n.getInitialValue(t);if(t.length&&n.getFieldValue(t)!==i&&n.fieldEntities.every((function(e){return!qh(e.getNamePath(),t)}))){var s=n.store;n.updateStore(Oi(s,t,i,!0)),n.notifyObservers(s,[t],{type:"remove"}),n.triggerDependenciesUpdate(s,t)}}n.notifyWatch([t])}})),dr(this,"dispatch",(function(e){switch(e.type){case"updateValue":var t=e.namePath,r=e.value;n.updateValue(t,r);break;case"validateField":var a=e.namePath,o=e.triggerName;n.validateFields([a],{triggerName:o})}})),dr(this,"notifyObservers",(function(e,t,r){if(n.subscribable){var a=xr(xr({},r),{},{store:n.getFieldsValue(!0)});n.getFieldEntities().forEach((function(n){(0,n.onStoreChange)(e,t,a)}))}else n.forceRootUpdate()})),dr(this,"triggerDependenciesUpdate",(function(e,t){var r=n.getDependencyChildrenFields(t);return r.length&&n.validateFields(r),n.notifyObservers(e,r,{type:"dependenciesUpdate",relatedFields:[t].concat(br(r))}),r})),dr(this,"updateValue",(function(e,t){var r=jh(e),a=n.store;n.updateStore(Oi(n.store,r,t)),n.notifyObservers(a,[r],{type:"valueUpdate",source:"internal"}),n.notifyWatch([r]);var o=n.triggerDependenciesUpdate(a,r),i=n.callbacks.onValuesChange;i&&i(Hh(n.store,[r]),n.getFieldsValue());n.triggerOnFieldsChange([r].concat(br(o)))})),dr(this,"setFieldsValue",(function(e){n.warningUnhooked();var t=n.store;if(e){var r=Di(n.store,e);n.updateStore(r)}n.notifyObservers(t,null,{type:"valueUpdate",source:"external"}),n.notifyWatch()})),dr(this,"setFieldValue",(function(e,t){n.setFields([{name:e,value:t}])})),dr(this,"getDependencyChildrenFields",(function(e){var t=new Set,r=[],a=new ap;n.getFieldEntities().forEach((function(e){(e.props.dependencies||[]).forEach((function(t){var n=jh(t);a.update(n,(function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Set;return t.add(e),t}))}))}));return function e(n){(a.get(n)||new Set).forEach((function(n){if(!t.has(n)){t.add(n);var a=n.getNamePath();n.isFieldDirty()&&a.length&&(r.push(a),e(a))}}))}(e),r})),dr(this,"triggerOnFieldsChange",(function(e,t){var r=n.callbacks.onFieldsChange;if(r){var a=n.getFields();if(t){var o=new ap;t.forEach((function(e){var t=e.name,n=e.errors;o.set(t,n)})),a.forEach((function(e){e.errors=o.get(e.name)||e.errors}))}var i=a.filter((function(t){var n=t.name;return Gh(e,n)}));i.length&&r(i,a)}})),dr(this,"validateFields",(function(e,t){var r,a;n.warningUnhooked(),Array.isArray(e)||"string"===typeof e||"string"===typeof t?(r=e,a=t):a=e;var o=!!r,i=o?r.map(jh):[],s=[],c=String(Date.now()),l=new Set,u=a||{},d=u.recursive,h=u.dirty;n.getFieldEntities(!0).forEach((function(e){if(o||i.push(e.getNamePath()),e.props.rules&&e.props.rules.length&&(!h||e.isFieldDirty())){var t=e.getNamePath();if(l.add(t.join(c)),!o||Gh(i,t,d)){var r=e.validateRules(xr({validateMessages:xr(xr({},Dh),n.validateMessages)},a));s.push(r.then((function(){return{name:t,errors:[],warnings:[]}})).catch((function(e){var n,r=[],a=[];return null===(n=e.forEach)||void 0===n||n.call(e,(function(e){var t=e.rule.warningOnly,n=e.errors;t?a.push.apply(a,br(n)):r.push.apply(r,br(n))})),r.length?Promise.reject({name:t,errors:r,warnings:a}):{name:t,errors:r,warnings:a}})))}}}));var p=function(e){var t=!1,n=e.length,r=[];return e.length?new Promise((function(a,o){e.forEach((function(e,i){e.catch((function(e){return t=!0,e})).then((function(e){n-=1,r[i]=e,n>0||(t&&o(r),a(r))}))}))})):Promise.resolve([])}(s);n.lastValidatePromise=p,p.catch((function(e){return e})).then((function(e){var t=e.map((function(e){return e.name}));n.notifyObservers(n.store,t,{type:"validateFinish"}),n.triggerOnFieldsChange(t,e)}));var f=p.then((function(){return n.lastValidatePromise===p?Promise.resolve(n.getFieldsValue(i)):Promise.reject([])})).catch((function(e){var t=e.filter((function(e){return e&&e.errors.length}));return Promise.reject({values:n.getFieldsValue(i),errorFields:t,outOfDate:n.lastValidatePromise!==p})}));f.catch((function(e){return e}));var g=i.filter((function(e){return l.has(e.join(c))}));return n.triggerOnFieldsChange(g),f})),dr(this,"submit",(function(){n.warningUnhooked(),n.validateFields().then((function(e){var t=n.callbacks.onFinish;if(t)try{t(e)}catch(r){console.error(r)}})).catch((function(e){var t=n.callbacks.onFinishFailed;t&&t(e)}))})),this.forceRootUpdate=t}));const sp=function(e){var t=o.useRef(),n=mr(o.useState({}),2)[1];if(!t.current)if(e)t.current=e;else{var r=new ip((function(){n({})}));t.current=r.getForm()}return[t.current]};var cp=o.createContext({triggerFormChange:function(){},triggerFormFinish:function(){},registerForm:function(){},unregisterForm:function(){}});const lp=cp;var up=["name","initialValues","fields","form","preserve","children","component","validateMessages","validateTrigger","onValuesChange","onFieldsChange","onFinish","onFinishFailed","clearOnDestroy"];const dp=function(e,t){var n=e.name,r=e.initialValues,a=e.fields,i=e.form,s=e.preserve,c=e.children,l=e.component,u=void 0===l?"form":l,d=e.validateMessages,h=e.validateTrigger,p=void 0===h?"onChange":h,f=e.onValuesChange,g=e.onFieldsChange,m=e.onFinish,v=e.onFinishFailed,b=e.clearOnDestroy,y=Cs(e,up),x=o.useRef(null),w=o.useContext(lp),k=mr(sp(i),1)[0],S=k.getInternalHooks(rh),C=S.useSubscribe,I=S.setInitialValues,E=S.setCallbacks,N=S.setValidateMessages,T=S.setPreserve,R=S.destroyForm;o.useImperativeHandle(t,(function(){return xr(xr({},k),{},{nativeElement:x.current})})),o.useEffect((function(){return w.registerForm(n,k),function(){w.unregisterForm(n)}}),[w,k,n]),N(xr(xr({},w.validateMessages),d)),E({onValuesChange:f,onFieldsChange:function(e){if(w.triggerFormChange(n,e),g){for(var t=arguments.length,r=new Array(t>1?t-1:0),a=1;a<t;a++)r[a-1]=arguments[a];g.apply(void 0,[e].concat(r))}},onFinish:function(e){w.triggerFormFinish(n,e),m&&m(e)},onFinishFailed:v}),T(s);var A,O=o.useRef(null);I(r,!O.current),O.current||(O.current=!0),o.useEffect((function(){return function(){return R(b)}}),[]);var F="function"===typeof c;F?A=c(k.getFieldsValue(!0),k):A=c;C(!F);var _=o.useRef();o.useEffect((function(){(function(e,t){if(e===t)return!0;if(!e&&t||e&&!t)return!1;if(!e||!t||"object"!==lr(e)||"object"!==lr(t))return!1;var n=Object.keys(e),r=Object.keys(t);return br(new Set([].concat(n,r))).every((function(n){var r=e[n],a=t[n];return"function"===typeof r&&"function"===typeof a||r===a}))})(_.current||[],a||[])||k.setFields(a||[]),_.current=a}),[a,k]);var D=o.useMemo((function(){return xr(xr({},k),{},{validateTrigger:p})}),[k,p]),M=o.createElement(ih.Provider,{value:null},o.createElement(oh.Provider,{value:D},A));return!1===u?M:o.createElement(u,Pa({},y,{ref:x,onSubmit:function(e){e.preventDefault(),e.stopPropagation(),k.submit()},onReset:function(e){var t;e.preventDefault(),k.resetFields(),null===(t=y.onReset)||void 0===t||t.call(y,e)}}),M)};function hp(e){try{return JSON.stringify(e)}catch(t){return Math.random()}}var pp=function(){};const fp=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=t[0],a=t[1],i=void 0===a?{}:a,s=function(e){return e&&!!e._init}(i)?{form:i}:i,c=s.form,l=mr((0,o.useState)(),2),u=l[0],d=l[1],h=(0,o.useMemo)((function(){return hp(u)}),[u]),p=(0,o.useRef)(h);p.current=h;var f=(0,o.useContext)(oh),g=c||f,m=g&&g._init,v=jh(r),b=(0,o.useRef)(v);return b.current=v,pp(v),(0,o.useEffect)((function(){if(m){var e=g.getFieldsValue,t=(0,g.getInternalHooks)(rh).registerWatch,n=function(e,t){var n=s.preserve?t:e;return"function"===typeof r?r(n):Ri(n,b.current)},a=t((function(e,t){var r=n(e,t),a=hp(r);p.current!==a&&(p.current=a,d(r))})),o=n(e(),e(!0));return u!==o&&d(o),a}}),[m]),u};var gp=o.forwardRef(dp);gp.FormProvider=function(e){var t=e.validateMessages,n=e.onFormChange,r=e.onFormFinish,a=e.children,i=o.useContext(cp),s=o.useRef({});return o.createElement(cp.Provider,{value:xr(xr({},i),{},{validateMessages:xr(xr({},i.validateMessages),t),triggerFormChange:function(e,t){n&&n(e,{changedFields:t,forms:s.current}),i.triggerFormChange(e,t)},triggerFormFinish:function(e,t){r&&r(e,{values:t,forms:s.current}),i.triggerFormFinish(e,t)},registerForm:function(e,t){e&&(s.current=xr(xr({},s.current),{},dr({},e,t))),i.registerForm(e,t)},unregisterForm:function(e){var t=xr({},s.current);delete t[e],s.current=t,i.unregisterForm(e)}})},a)},gp.Field=Jh,gp.List=ep,gp.useForm=sp,gp.useWatch=fp;const mp=o.createContext({});const vp=(0,o.createContext)(void 0),bp=["outlined","borderless","filled"],yp=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;const n=(0,o.useContext)(vp);let r;r="undefined"!==typeof e?e:!1===t?"borderless":null!==n&&void 0!==n?n:"outlined";return[r,bp.includes(r)]};function xp(e,t,n){const{focusElCls:r,focus:a,borderElCls:o}=n,i=o?"> *":"",s=["hover",a?"focus":null,"active"].filter(Boolean).map((e=>"&:".concat(e," ").concat(i))).join(",");return{["&-item:not(".concat(t,"-last-item)")]:{marginInlineEnd:e.calc(e.lineWidth).mul(-1).equal()},"&-item":Object.assign(Object.assign({[s]:{zIndex:2}},r?{["&".concat(r)]:{zIndex:2}}:{}),{["&[disabled] ".concat(i)]:{zIndex:0}})}}function wp(e,t,n){const{borderElCls:r}=n,a=r?"> ".concat(r):"";return{["&-item:not(".concat(t,"-first-item):not(").concat(t,"-last-item) ").concat(a)]:{borderRadius:0},["&-item:not(".concat(t,"-last-item)").concat(t,"-first-item")]:{["& ".concat(a,", &").concat(e,"-sm ").concat(a,", &").concat(e,"-lg ").concat(a)]:{borderStartEndRadius:0,borderEndEndRadius:0}},["&-item:not(".concat(t,"-first-item)").concat(t,"-last-item")]:{["& ".concat(a,", &").concat(e,"-sm ").concat(a,", &").concat(e,"-lg ").concat(a)]:{borderStartStartRadius:0,borderEndStartRadius:0}}}}function kp(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{focus:!0};const{componentCls:n}=e,r="".concat(n,"-compact");return{[r]:Object.assign(Object.assign({},xp(e,r,t)),wp(n,r,t))}}const Sp=e=>({borderColor:e.hoverBorderColor,backgroundColor:e.hoverBg}),Cp=e=>({color:e.colorTextDisabled,backgroundColor:e.colorBgContainerDisabled,borderColor:e.colorBorder,boxShadow:"none",cursor:"not-allowed",opacity:1,"input[disabled], textarea[disabled]":{cursor:"not-allowed"},"&:hover:not([disabled])":Object.assign({},Sp(es(e,{hoverBorderColor:e.colorBorder,hoverBg:e.colorBgContainerDisabled})))}),Ip=(e,t)=>({background:e.colorBgContainer,borderWidth:e.lineWidth,borderStyle:e.lineType,borderColor:t.borderColor,"&:hover":{borderColor:t.hoverBorderColor,backgroundColor:e.hoverBg},"&:focus, &:focus-within":{borderColor:t.activeBorderColor,boxShadow:t.activeShadow,outline:0,backgroundColor:e.activeBg}}),Ep=(e,t)=>({["&".concat(e.componentCls,"-status-").concat(t.status,":not(").concat(e.componentCls,"-disabled)")]:Object.assign(Object.assign({},Ip(e,t)),{["".concat(e.componentCls,"-prefix, ").concat(e.componentCls,"-suffix")]:{color:t.affixColor}}),["&".concat(e.componentCls,"-status-").concat(t.status).concat(e.componentCls,"-disabled")]:{borderColor:t.borderColor}}),Np=(e,t)=>({"&-outlined":Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},Ip(e,{borderColor:e.colorBorder,hoverBorderColor:e.hoverBorderColor,activeBorderColor:e.activeBorderColor,activeShadow:e.activeShadow})),{["&".concat(e.componentCls,"-disabled, &[disabled]")]:Object.assign({},Cp(e))}),Ep(e,{status:"error",borderColor:e.colorError,hoverBorderColor:e.colorErrorBorderHover,activeBorderColor:e.colorError,activeShadow:e.errorActiveShadow,affixColor:e.colorError})),Ep(e,{status:"warning",borderColor:e.colorWarning,hoverBorderColor:e.colorWarningBorderHover,activeBorderColor:e.colorWarning,activeShadow:e.warningActiveShadow,affixColor:e.colorWarning})),t)}),Tp=(e,t)=>({["&".concat(e.componentCls,"-group-wrapper-status-").concat(t.status)]:{["".concat(e.componentCls,"-group-addon")]:{borderColor:t.addonBorderColor,color:t.addonColor}}}),Rp=e=>({"&-outlined":Object.assign(Object.assign(Object.assign({["".concat(e.componentCls,"-group")]:{"&-addon":{background:e.addonBg,border:"".concat(pa(e.lineWidth)," ").concat(e.lineType," ").concat(e.colorBorder)},"&-addon:first-child":{borderInlineEnd:0},"&-addon:last-child":{borderInlineStart:0}}},Tp(e,{status:"error",addonBorderColor:e.colorError,addonColor:e.colorErrorText})),Tp(e,{status:"warning",addonBorderColor:e.colorWarning,addonColor:e.colorWarningText})),{["&".concat(e.componentCls,"-group-wrapper-disabled")]:{["".concat(e.componentCls,"-group-addon")]:Object.assign({},Cp(e))}})}),Ap=(e,t)=>({"&-borderless":Object.assign({background:"transparent",border:"none","&:focus, &:focus-within":{outline:"none"},["&".concat(e.componentCls,"-disabled, &[disabled]")]:{color:e.colorTextDisabled}},t)}),Op=(e,t)=>({background:t.bg,borderWidth:e.lineWidth,borderStyle:e.lineType,borderColor:"transparent","input&, & input, textarea&, & textarea":{color:null===t||void 0===t?void 0:t.inputColor},"&:hover":{background:t.hoverBg},"&:focus, &:focus-within":{outline:0,borderColor:t.activeBorderColor,backgroundColor:e.activeBg}}),Fp=(e,t)=>({["&".concat(e.componentCls,"-status-").concat(t.status,":not(").concat(e.componentCls,"-disabled)")]:Object.assign(Object.assign({},Op(e,t)),{["".concat(e.componentCls,"-prefix, ").concat(e.componentCls,"-suffix")]:{color:t.affixColor}})}),_p=(e,t)=>({"&-filled":Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},Op(e,{bg:e.colorFillTertiary,hoverBg:e.colorFillSecondary,activeBorderColor:e.colorPrimary})),{["&".concat(e.componentCls,"-disabled, &[disabled]")]:Object.assign({},Cp(e))}),Fp(e,{status:"error",bg:e.colorErrorBg,hoverBg:e.colorErrorBgHover,activeBorderColor:e.colorError,inputColor:e.colorErrorText,affixColor:e.colorError})),Fp(e,{status:"warning",bg:e.colorWarningBg,hoverBg:e.colorWarningBgHover,activeBorderColor:e.colorWarning,inputColor:e.colorWarningText,affixColor:e.colorWarning})),t)}),Dp=(e,t)=>({["&".concat(e.componentCls,"-group-wrapper-status-").concat(t.status)]:{["".concat(e.componentCls,"-group-addon")]:{background:t.addonBg,color:t.addonColor}}}),Mp=e=>({"&-filled":Object.assign(Object.assign(Object.assign({["".concat(e.componentCls,"-group")]:{"&-addon":{background:e.colorFillTertiary},["".concat(e.componentCls,"-filled:not(:focus):not(:focus-within)")]:{"&:not(:first-child)":{borderInlineStart:"".concat(pa(e.lineWidth)," ").concat(e.lineType," ").concat(e.colorSplit)},"&:not(:last-child)":{borderInlineEnd:"".concat(pa(e.lineWidth)," ").concat(e.lineType," ").concat(e.colorSplit)}}}},Dp(e,{status:"error",addonBg:e.colorErrorBg,addonColor:e.colorErrorText})),Dp(e,{status:"warning",addonBg:e.colorWarningBg,addonColor:e.colorWarningText})),{["&".concat(e.componentCls,"-group-wrapper-disabled")]:{["".concat(e.componentCls,"-group")]:{"&-addon":{background:e.colorFillTertiary,color:e.colorTextDisabled},"&-addon:first-child":{borderInlineStart:"".concat(pa(e.lineWidth)," ").concat(e.lineType," ").concat(e.colorBorder),borderTop:"".concat(pa(e.lineWidth)," ").concat(e.lineType," ").concat(e.colorBorder),borderBottom:"".concat(pa(e.lineWidth)," ").concat(e.lineType," ").concat(e.colorBorder)},"&-addon:last-child":{borderInlineEnd:"".concat(pa(e.lineWidth)," ").concat(e.lineType," ").concat(e.colorBorder),borderTop:"".concat(pa(e.lineWidth)," ").concat(e.lineType," ").concat(e.colorBorder),borderBottom:"".concat(pa(e.lineWidth)," ").concat(e.lineType," ").concat(e.colorBorder)}}}})}),Pp=e=>{const{paddingBlockLG:t,lineHeightLG:n,borderRadiusLG:r,paddingInlineLG:a}=e;return{padding:"".concat(pa(t)," ").concat(pa(a)),fontSize:e.inputFontSizeLG,lineHeight:n,borderRadius:r}},Lp=e=>({padding:"".concat(pa(e.paddingBlockSM)," ").concat(pa(e.paddingInlineSM)),fontSize:e.inputFontSizeSM,borderRadius:e.borderRadiusSM}),zp=e=>Object.assign(Object.assign({position:"relative",display:"inline-block",width:"100%",minWidth:0,padding:"".concat(pa(e.paddingBlock)," ").concat(pa(e.paddingInline)),color:e.colorText,fontSize:e.inputFontSize,lineHeight:e.lineHeight,borderRadius:e.borderRadius,transition:"all ".concat(e.motionDurationMid)},{"&::-moz-placeholder":{opacity:1},"&::placeholder":{color:e.colorTextPlaceholder,userSelect:"none"},"&:placeholder-shown":{textOverflow:"ellipsis"}}),{"textarea&":{maxWidth:"100%",height:"auto",minHeight:e.controlHeight,lineHeight:e.lineHeight,verticalAlign:"bottom",transition:"all ".concat(e.motionDurationSlow,", height 0s"),resize:"vertical"},"&-lg":Object.assign({},Pp(e)),"&-sm":Object.assign({},Lp(e)),"&-rtl, &-textarea-rtl":{direction:"rtl"}}),Bp=e=>{const{componentCls:t,antCls:n}=e;return{position:"relative",display:"table",width:"100%",borderCollapse:"separate",borderSpacing:0,"&[class*='col-']":{paddingInlineEnd:e.paddingXS,"&:last-child":{paddingInlineEnd:0}},["&-lg ".concat(t,", &-lg > ").concat(t,"-group-addon")]:Object.assign({},Pp(e)),["&-sm ".concat(t,", &-sm > ").concat(t,"-group-addon")]:Object.assign({},Lp(e)),["&-lg ".concat(n,"-select-single ").concat(n,"-select-selector")]:{height:e.controlHeightLG},["&-sm ".concat(n,"-select-single ").concat(n,"-select-selector")]:{height:e.controlHeightSM},["> ".concat(t)]:{display:"table-cell","&:not(:first-child):not(:last-child)":{borderRadius:0}},["".concat(t,"-group")]:{"&-addon, &-wrap":{display:"table-cell",width:1,whiteSpace:"nowrap",verticalAlign:"middle","&:not(:first-child):not(:last-child)":{borderRadius:0}},"&-wrap > *":{display:"block !important"},"&-addon":{position:"relative",padding:"0 ".concat(pa(e.paddingInline)),color:e.colorText,fontWeight:"normal",fontSize:e.inputFontSize,textAlign:"center",borderRadius:e.borderRadius,transition:"all ".concat(e.motionDurationSlow),lineHeight:1,["".concat(n,"-select")]:{margin:"".concat(pa(e.calc(e.paddingBlock).add(1).mul(-1).equal())," ").concat(pa(e.calc(e.paddingInline).mul(-1).equal())),["&".concat(n,"-select-single:not(").concat(n,"-select-customize-input):not(").concat(n,"-pagination-size-changer)")]:{["".concat(n,"-select-selector")]:{backgroundColor:"inherit",border:"".concat(pa(e.lineWidth)," ").concat(e.lineType," transparent"),boxShadow:"none"}},"&-open, &-focused":{["".concat(n,"-select-selector")]:{color:e.colorPrimary}}},["".concat(n,"-cascader-picker")]:{margin:"-9px ".concat(pa(e.calc(e.paddingInline).mul(-1).equal())),backgroundColor:"transparent",["".concat(n,"-cascader-input")]:{textAlign:"start",border:0,boxShadow:"none"}}}},["".concat(t)]:{width:"100%",marginBottom:0,textAlign:"inherit","&:focus":{zIndex:1,borderInlineEndWidth:1},"&:hover":{zIndex:1,borderInlineEndWidth:1,["".concat(t,"-search-with-button &")]:{zIndex:0}}},["> ".concat(t,":first-child, ").concat(t,"-group-addon:first-child")]:{borderStartEndRadius:0,borderEndEndRadius:0,["".concat(n,"-select ").concat(n,"-select-selector")]:{borderStartEndRadius:0,borderEndEndRadius:0}},["> ".concat(t,"-affix-wrapper")]:{["&:not(:first-child) ".concat(t)]:{borderStartStartRadius:0,borderEndStartRadius:0},["&:not(:last-child) ".concat(t)]:{borderStartEndRadius:0,borderEndEndRadius:0}},["> ".concat(t,":last-child, ").concat(t,"-group-addon:last-child")]:{borderStartStartRadius:0,borderEndStartRadius:0,["".concat(n,"-select ").concat(n,"-select-selector")]:{borderStartStartRadius:0,borderEndStartRadius:0}},["".concat(t,"-affix-wrapper")]:{"&:not(:last-child)":{borderStartEndRadius:0,borderEndEndRadius:0,["".concat(t,"-search &")]:{borderStartStartRadius:e.borderRadius,borderEndStartRadius:e.borderRadius}},["&:not(:first-child), ".concat(t,"-search &:not(:first-child)")]:{borderStartStartRadius:0,borderEndStartRadius:0}},["&".concat(t,"-group-compact")]:Object.assign(Object.assign({display:"block"},{"&::before":{display:"table",content:'""'},"&::after":{display:"table",clear:"both",content:'""'}}),{["".concat(t,"-group-addon, ").concat(t,"-group-wrap, > ").concat(t)]:{"&:not(:first-child):not(:last-child)":{borderInlineEndWidth:e.lineWidth,"&:hover, &:focus":{zIndex:1}}},"& > *":{display:"inline-flex",float:"none",verticalAlign:"top",borderRadius:0},["\n        & > ".concat(t,"-affix-wrapper,\n        & > ").concat(t,"-number-affix-wrapper,\n        & > ").concat(n,"-picker-range\n      ")]:{display:"inline-flex"},"& > *:not(:last-child)":{marginInlineEnd:e.calc(e.lineWidth).mul(-1).equal(),borderInlineEndWidth:e.lineWidth},["".concat(t)]:{float:"none"},["& > ".concat(n,"-select > ").concat(n,"-select-selector,\n      & > ").concat(n,"-select-auto-complete ").concat(t,",\n      & > ").concat(n,"-cascader-picker ").concat(t,",\n      & > ").concat(t,"-group-wrapper ").concat(t)]:{borderInlineEndWidth:e.lineWidth,borderRadius:0,"&:hover, &:focus":{zIndex:1}},["& > ".concat(n,"-select-focused")]:{zIndex:1},["& > ".concat(n,"-select > ").concat(n,"-select-arrow")]:{zIndex:1},["& > *:first-child,\n      & > ".concat(n,"-select:first-child > ").concat(n,"-select-selector,\n      & > ").concat(n,"-select-auto-complete:first-child ").concat(t,",\n      & > ").concat(n,"-cascader-picker:first-child ").concat(t)]:{borderStartStartRadius:e.borderRadius,borderEndStartRadius:e.borderRadius},["& > *:last-child,\n      & > ".concat(n,"-select:last-child > ").concat(n,"-select-selector,\n      & > ").concat(n,"-cascader-picker:last-child ").concat(t,",\n      & > ").concat(n,"-cascader-picker-focused:last-child ").concat(t)]:{borderInlineEndWidth:e.lineWidth,borderStartEndRadius:e.borderRadius,borderEndEndRadius:e.borderRadius},["& > ".concat(n,"-select-auto-complete ").concat(t)]:{verticalAlign:"top"},["".concat(t,"-group-wrapper + ").concat(t,"-group-wrapper")]:{marginInlineStart:e.calc(e.lineWidth).mul(-1).equal(),["".concat(t,"-affix-wrapper")]:{borderRadius:0}},["".concat(t,"-group-wrapper:not(:last-child)")]:{["&".concat(t,"-search > ").concat(t,"-group")]:{["& > ".concat(t,"-group-addon > ").concat(t,"-search-button")]:{borderRadius:0},["& > ".concat(t)]:{borderStartStartRadius:e.borderRadius,borderStartEndRadius:0,borderEndEndRadius:0,borderEndStartRadius:e.borderRadius}}}})}},Wp=e=>{const{componentCls:t,controlHeightSM:n,lineWidth:r,calc:a}=e,o=a(n).sub(a(r).mul(2)).sub(16).div(2).equal();return{[t]:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},Mi(e)),zp(e)),Np(e)),_p(e)),Ap(e)),{'&[type="color"]':{height:e.controlHeight,["&".concat(t,"-lg")]:{height:e.controlHeightLG},["&".concat(t,"-sm")]:{height:n,paddingTop:o,paddingBottom:o}},'&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration':{"-webkit-appearance":"none"}})}},Up=e=>{const{componentCls:t}=e;return{["".concat(t,"-clear-icon")]:{margin:0,color:e.colorTextQuaternary,fontSize:e.fontSizeIcon,verticalAlign:-1,cursor:"pointer",transition:"color ".concat(e.motionDurationSlow),"&:hover":{color:e.colorTextTertiary},"&:active":{color:e.colorText},"&-hidden":{visibility:"hidden"},"&-has-suffix":{margin:"0 ".concat(pa(e.inputAffixPadding))}}}},Vp=e=>{const{componentCls:t,inputAffixPadding:n,colorTextDescription:r,motionDurationSlow:a,colorIcon:o,colorIconHover:i,iconCls:s}=e,c="".concat(t,"-affix-wrapper");return{[c]:Object.assign(Object.assign(Object.assign(Object.assign({},zp(e)),{display:"inline-flex",["&:not(".concat(t,"-disabled):hover")]:{zIndex:1,["".concat(t,"-search-with-button &")]:{zIndex:0}},"&-focused, &:focus":{zIndex:1},["> input".concat(t)]:{padding:0},["> input".concat(t,", > textarea").concat(t)]:{fontSize:"inherit",border:"none",borderRadius:0,outline:"none",background:"transparent",color:"inherit","&::-ms-reveal":{display:"none"},"&:focus":{boxShadow:"none !important"}},"&::before":{display:"inline-block",width:0,visibility:"hidden",content:'"\\a0"'},["".concat(t)]:{"&-prefix, &-suffix":{display:"flex",flex:"none",alignItems:"center","> *:not(:last-child)":{marginInlineEnd:e.paddingXS}},"&-show-count-suffix":{color:r},"&-show-count-has-suffix":{marginInlineEnd:e.paddingXXS},"&-prefix":{marginInlineEnd:n},"&-suffix":{marginInlineStart:n}}}),Up(e)),{["".concat(s).concat(t,"-password-icon")]:{color:o,cursor:"pointer",transition:"all ".concat(a),"&:hover":{color:i}}})}},jp=e=>{const{componentCls:t,borderRadiusLG:n,borderRadiusSM:r}=e;return{["".concat(t,"-group")]:Object.assign(Object.assign(Object.assign({},Mi(e)),Bp(e)),{"&-rtl":{direction:"rtl"},"&-wrapper":Object.assign(Object.assign(Object.assign({display:"inline-block",width:"100%",textAlign:"start",verticalAlign:"top","&-rtl":{direction:"rtl"},"&-lg":{["".concat(t,"-group-addon")]:{borderRadius:n,fontSize:e.inputFontSizeLG}},"&-sm":{["".concat(t,"-group-addon")]:{borderRadius:r}}},Rp(e)),Mp(e)),{["&:not(".concat(t,"-compact-first-item):not(").concat(t,"-compact-last-item)").concat(t,"-compact-item")]:{["".concat(t,", ").concat(t,"-group-addon")]:{borderRadius:0}},["&:not(".concat(t,"-compact-last-item)").concat(t,"-compact-first-item")]:{["".concat(t,", ").concat(t,"-group-addon")]:{borderStartEndRadius:0,borderEndEndRadius:0}},["&:not(".concat(t,"-compact-first-item)").concat(t,"-compact-last-item")]:{["".concat(t,", ").concat(t,"-group-addon")]:{borderStartStartRadius:0,borderEndStartRadius:0}},["&:not(".concat(t,"-compact-last-item)").concat(t,"-compact-item")]:{["".concat(t,"-affix-wrapper")]:{borderStartEndRadius:0,borderEndEndRadius:0}}})})}},Hp=e=>{const{componentCls:t,antCls:n}=e,r="".concat(t,"-search");return{[r]:{["".concat(t)]:{"&:hover, &:focus":{borderColor:e.colorPrimaryHover,["+ ".concat(t,"-group-addon ").concat(r,"-button:not(").concat(n,"-btn-primary)")]:{borderInlineStartColor:e.colorPrimaryHover}}},["".concat(t,"-affix-wrapper")]:{borderRadius:0},["".concat(t,"-lg")]:{lineHeight:e.calc(e.lineHeightLG).sub(2e-4).equal()},["> ".concat(t,"-group")]:{["> ".concat(t,"-group-addon:last-child")]:{insetInlineStart:-1,padding:0,border:0,["".concat(r,"-button")]:{marginInlineEnd:-1,paddingTop:0,paddingBottom:0,borderStartStartRadius:0,borderStartEndRadius:e.borderRadius,borderEndEndRadius:e.borderRadius,borderEndStartRadius:0,boxShadow:"none"},["".concat(r,"-button:not(").concat(n,"-btn-primary)")]:{color:e.colorTextDescription,"&:hover":{color:e.colorPrimaryHover},"&:active":{color:e.colorPrimaryActive},["&".concat(n,"-btn-loading::before")]:{insetInlineStart:0,insetInlineEnd:0,insetBlockStart:0,insetBlockEnd:0}}}},["".concat(r,"-button")]:{height:e.controlHeight,"&:hover, &:focus":{zIndex:1}},["&-large ".concat(r,"-button")]:{height:e.controlHeightLG},["&-small ".concat(r,"-button")]:{height:e.controlHeightSM},"&-rtl":{direction:"rtl"},["&".concat(t,"-compact-item")]:{["&:not(".concat(t,"-compact-last-item)")]:{["".concat(t,"-group-addon")]:{["".concat(t,"-search-button")]:{marginInlineEnd:e.calc(e.lineWidth).mul(-1).equal(),borderRadius:0}}},["&:not(".concat(t,"-compact-first-item)")]:{["".concat(t,",").concat(t,"-affix-wrapper")]:{borderRadius:0}},["> ".concat(t,"-group-addon ").concat(t,"-search-button,\n        > ").concat(t,",\n        ").concat(t,"-affix-wrapper")]:{"&:hover, &:focus, &:active":{zIndex:2}},["> ".concat(t,"-affix-wrapper-focused")]:{zIndex:2}}}}},Gp=e=>{const{componentCls:t,paddingLG:n}=e,r="".concat(t,"-textarea");return{[r]:{position:"relative","&-show-count":{["> ".concat(t)]:{height:"100%"},["".concat(t,"-data-count")]:{position:"absolute",bottom:e.calc(e.fontSize).mul(e.lineHeight).mul(-1).equal(),insetInlineEnd:0,color:e.colorTextDescription,whiteSpace:"nowrap",pointerEvents:"none"}},["\n        &-allow-clear > ".concat(t,",\n        &-affix-wrapper").concat(r,"-has-feedback ").concat(t,"\n      ")]:{paddingInlineEnd:n},["&-affix-wrapper".concat(t,"-affix-wrapper")]:{padding:0,["> textarea".concat(t)]:{fontSize:"inherit",border:"none",outline:"none",background:"transparent","&:focus":{boxShadow:"none !important"}},["".concat(t,"-suffix")]:{margin:0,"> *:not(:last-child)":{marginInline:0},["".concat(t,"-clear-icon")]:{position:"absolute",insetInlineEnd:e.paddingXS,insetBlockStart:e.paddingXS},["".concat(r,"-suffix")]:{position:"absolute",top:0,insetInlineEnd:e.paddingInline,bottom:0,zIndex:1,display:"inline-flex",alignItems:"center",margin:"auto",pointerEvents:"none"}}}}}},qp=e=>{const{componentCls:t}=e;return{["".concat(t,"-out-of-range")]:{["&, & input, & textarea, ".concat(t,"-show-count-suffix, ").concat(t,"-data-count")]:{color:e.colorError}}}},Kp=ls("Input",(e=>{const t=es(e,function(e){return es(e,{inputAffixPadding:e.paddingXXS})}(e));return[Wp(t),Gp(t),Vp(t),jp(t),Hp(t),qp(t),kp(t)]}),(e=>{const{controlHeight:t,fontSize:n,lineHeight:r,lineWidth:a,controlHeightSM:o,controlHeightLG:i,fontSizeLG:s,lineHeightLG:c,paddingSM:l,controlPaddingHorizontalSM:u,controlPaddingHorizontal:d,colorFillAlter:h,colorPrimaryHover:p,colorPrimary:f,controlOutlineWidth:g,controlOutline:m,colorErrorOutline:v,colorWarningOutline:b,colorBgContainer:y}=e;return{paddingBlock:Math.max(Math.round((t-n*r)/2*10)/10-a,0),paddingBlockSM:Math.max(Math.round((o-n*r)/2*10)/10-a,0),paddingBlockLG:Math.ceil((i-s*c)/2*10)/10-a,paddingInline:l-a,paddingInlineSM:u-a,paddingInlineLG:d-a,addonBg:h,activeBorderColor:f,hoverBorderColor:p,activeShadow:"0 0 0 ".concat(g,"px ").concat(m),errorActiveShadow:"0 0 0 ".concat(g,"px ").concat(v),warningActiveShadow:"0 0 0 ".concat(g,"px ").concat(b),hoverBg:y,activeBg:y,inputFontSize:n,inputFontSizeLG:s,inputFontSizeSM:n}}),{resetFont:!1});var Xp=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const $p=(0,o.forwardRef)(((e,t)=>{var n,r;const{prefixCls:a,bordered:i=!0,size:s,disabled:c,status:l,allowClear:u,classNames:d,rootClassName:h,className:p,style:f,styles:g,variant:m}=e,v=Xp(e,["prefixCls","bordered","size","disabled","status","allowClear","classNames","rootClassName","className","style","styles","variant"]);const{getPrefixCls:b,direction:y,textArea:x}=o.useContext(fi),w=Jd(s),k=o.useContext(Xd),S=null!==c&&void 0!==c?c:k,{status:C,hasFeedback:I,feedbackIcon:E}=o.useContext(mp),N=((e,t)=>t||e)(C,l),T=o.useRef(null);o.useImperativeHandle(t,(()=>{var e;return{resizableTextArea:null===(e=T.current)||void 0===e?void 0:e.resizableTextArea,focus:e=>{var t,n;!function(e,t){if(!e)return;e.focus(t);const{cursor:n}=t||{};if(n){const t=e.value.length;switch(n){case"start":e.setSelectionRange(0,0);break;case"end":e.setSelectionRange(t,t);break;default:e.setSelectionRange(0,t)}}}(null===(n=null===(t=T.current)||void 0===t?void 0:t.resizableTextArea)||void 0===n?void 0:n.textArea,e)},blur:()=>{var e;return null===(e=T.current)||void 0===e?void 0:e.blur()}}}));const R=b("input",a),A=$d(R),[O,F,_]=Kp(R,A),[D,M]=yp(m,i),P=Hd(null!==u&&void 0!==u?u:null===x||void 0===x?void 0:x.allowClear);return O(o.createElement(Wd,Object.assign({autoComplete:null===x||void 0===x?void 0:x.autoComplete},v,{style:Object.assign(Object.assign({},null===x||void 0===x?void 0:x.style),f),styles:Object.assign(Object.assign({},null===x||void 0===x?void 0:x.styles),g),disabled:S,allowClear:P,className:cr()(_,A,p,h,null===x||void 0===x?void 0:x.className),classNames:Object.assign(Object.assign(Object.assign({},d),null===x||void 0===x?void 0:x.classNames),{textarea:cr()({["".concat(R,"-sm")]:"small"===w,["".concat(R,"-lg")]:"large"===w},F,null===d||void 0===d?void 0:d.textarea,null===(n=null===x||void 0===x?void 0:x.classNames)||void 0===n?void 0:n.textarea),variant:cr()({["".concat(R,"-").concat(D)]:M},Gd(R,N)),affixWrapper:cr()("".concat(R,"-textarea-affix-wrapper"),{["".concat(R,"-affix-wrapper-rtl")]:"rtl"===y,["".concat(R,"-affix-wrapper-sm")]:"small"===w,["".concat(R,"-affix-wrapper-lg")]:"large"===w,["".concat(R,"-textarea-show-count")]:e.showCount||(null===(r=e.count)||void 0===r?void 0:r.show)},F)}),prefixCls:R,suffix:I&&o.createElement("span",{className:"".concat(R,"-textarea-suffix")},E),ref:T})))})),Yp=$p,Qp=e=>({color:e.colorLink,textDecoration:"none",outline:"none",cursor:"pointer",transition:"color ".concat(e.motionDurationSlow),"&:focus, &:hover":{color:e.colorLinkHover},"&:active":{color:e.colorLinkActive}}),Zp=e=>{const t={};return[1,2,3,4,5].forEach((n=>{t["\n      h".concat(n,"&,\n      div&-h").concat(n,",\n      div&-h").concat(n," > textarea,\n      h").concat(n,"\n    ")]=((e,t,n,r)=>{const{titleMarginBottom:a,fontWeightStrong:o}=r;return{marginBottom:a,color:n,fontWeight:o,fontSize:e,lineHeight:t}})(e["fontSizeHeading".concat(n)],e["lineHeightHeading".concat(n)],e.colorTextHeading,e)})),t},Jp=e=>{const{componentCls:t}=e;return{"a&, a":Object.assign(Object.assign({},Qp(e)),{textDecoration:e.linkDecoration,"&:active, &:hover":{textDecoration:e.linkHoverDecoration},["&[disabled], &".concat(t,"-disabled")]:{color:e.colorTextDisabled,cursor:"not-allowed","&:active, &:hover":{color:e.colorTextDisabled},"&:active":{pointerEvents:"none"}}})}},ef=e=>({code:{margin:"0 0.2em",paddingInline:"0.4em",paddingBlock:"0.2em 0.1em",fontSize:"85%",fontFamily:e.fontFamilyCode,background:"rgba(150, 150, 150, 0.1)",border:"1px solid rgba(100, 100, 100, 0.2)",borderRadius:3},kbd:{margin:"0 0.2em",paddingInline:"0.4em",paddingBlock:"0.15em 0.1em",fontSize:"90%",fontFamily:e.fontFamilyCode,background:"rgba(150, 150, 150, 0.06)",border:"1px solid rgba(100, 100, 100, 0.2)",borderBottomWidth:2,borderRadius:3},mark:{padding:0,backgroundColor:Wo[2]},"u, ins":{textDecoration:"underline",textDecorationSkipInk:"auto"},"s, del":{textDecoration:"line-through"},strong:{fontWeight:600},"ul, ol":{marginInline:0,marginBlock:"0 1em",padding:0,li:{marginInline:"20px 0",marginBlock:0,paddingInline:"4px 0",paddingBlock:0}},ul:{listStyleType:"circle",ul:{listStyleType:"disc"}},ol:{listStyleType:"decimal"},"pre, blockquote":{margin:"1em 0"},pre:{padding:"0.4em 0.6em",whiteSpace:"pre-wrap",wordWrap:"break-word",background:"rgba(150, 150, 150, 0.1)",border:"1px solid rgba(100, 100, 100, 0.2)",borderRadius:3,fontFamily:e.fontFamilyCode,code:{display:"inline",margin:0,padding:0,fontSize:"inherit",fontFamily:"inherit",background:"transparent",border:0}},blockquote:{paddingInline:"0.6em 0",paddingBlock:0,borderInlineStart:"4px solid rgba(100, 100, 100, 0.2)",opacity:.85}}),tf=e=>{const{componentCls:t,paddingSM:n}=e,r=n;return{"&-edit-content":{position:"relative","div&":{insetInlineStart:e.calc(e.paddingSM).mul(-1).equal(),marginTop:e.calc(r).mul(-1).equal(),marginBottom:"calc(1em - ".concat(pa(r),")")},["".concat(t,"-edit-content-confirm")]:{position:"absolute",insetInlineEnd:e.calc(e.marginXS).add(2).equal(),insetBlockEnd:e.marginXS,color:e.colorTextDescription,fontWeight:"normal",fontSize:e.fontSize,fontStyle:"normal",pointerEvents:"none"},textarea:{margin:"0!important",MozTransition:"none",height:"1em"}}}},nf=e=>({["".concat(e.componentCls,"-copy-success")]:{"\n    &,\n    &:hover,\n    &:focus":{color:e.colorSuccess}},["".concat(e.componentCls,"-copy-icon-only")]:{marginInlineStart:0}}),rf=e=>{const{componentCls:t,titleMarginTop:n}=e;return{[t]:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({color:e.colorText,wordBreak:"break-word",lineHeight:e.lineHeight,["&".concat(t,"-secondary")]:{color:e.colorTextDescription},["&".concat(t,"-success")]:{color:e.colorSuccess},["&".concat(t,"-warning")]:{color:e.colorWarning},["&".concat(t,"-danger")]:{color:e.colorError,"a&:active, a&:focus":{color:e.colorErrorActive},"a&:hover":{color:e.colorErrorHover}},["&".concat(t,"-disabled")]:{color:e.colorTextDisabled,cursor:"not-allowed",userSelect:"none"},"\n        div&,\n        p\n      ":{marginBottom:"1em"}},Zp(e)),{["\n      & + h1".concat(t,",\n      & + h2").concat(t,",\n      & + h3").concat(t,",\n      & + h4").concat(t,",\n      & + h5").concat(t,"\n      ")]:{marginTop:n},"\n      div,\n      ul,\n      li,\n      p,\n      h1,\n      h2,\n      h3,\n      h4,\n      h5":{"\n        + h1,\n        + h2,\n        + h3,\n        + h4,\n        + h5\n        ":{marginTop:n}}}),ef(e)),Jp(e)),{["\n        ".concat(t,"-expand,\n        ").concat(t,"-collapse,\n        ").concat(t,"-edit,\n        ").concat(t,"-copy\n      ")]:Object.assign(Object.assign({},Qp(e)),{marginInlineStart:e.marginXXS})}),tf(e)),nf(e)),{"\n  a&-ellipsis,\n  span&-ellipsis\n  ":{display:"inline-block",maxWidth:"100%"},"&-ellipsis-single-line":{whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis","a&, span&":{verticalAlign:"bottom"},"> code":{paddingBlock:0,maxWidth:"calc(100% - 1.2em)",display:"inline-block",overflow:"hidden",textOverflow:"ellipsis",verticalAlign:"bottom",boxSizing:"content-box"}},"&-ellipsis-multiple-line":{display:"-webkit-box",overflow:"hidden",WebkitLineClamp:3,WebkitBoxOrient:"vertical"}}),{"&-rtl":{direction:"rtl"}})}},af=ls("Typography",(e=>[rf(e)]),(()=>({titleMarginTop:"1.2em",titleMarginBottom:"0.5em"}))),of=e=>{const{prefixCls:t,"aria-label":n,className:r,style:a,direction:i,maxLength:s,autoSize:c=!0,value:l,onSave:u,onCancel:d,onEnd:h,component:p,enterIcon:f=o.createElement(Id,null)}=e,g=o.useRef(null),m=o.useRef(!1),v=o.useRef(),[b,y]=o.useState(l);o.useEffect((()=>{y(l)}),[l]),o.useEffect((()=>{if(g.current&&g.current.resizableTextArea){const{textArea:e}=g.current.resizableTextArea;e.focus();const{length:t}=e.value;e.setSelectionRange(t,t)}}),[]);const x=()=>{u(b.trim())},w=p?"".concat(t,"-").concat(p):"",[k,S,C]=af(t),I=cr()(t,"".concat(t,"-edit-content"),{["".concat(t,"-rtl")]:"rtl"===i},r,w,S,C);return k(o.createElement("div",{className:I,style:a},o.createElement(Yp,{ref:g,maxLength:s,value:b,onChange:e=>{let{target:t}=e;y(t.value.replace(/[\n\r]/g,""))},onKeyDown:e=>{let{keyCode:t}=e;m.current||(v.current=t)},onKeyUp:e=>{let{keyCode:t,ctrlKey:n,altKey:r,metaKey:a,shiftKey:o}=e;v.current!==t||m.current||n||r||a||o||(t===Tc.ENTER?(x(),null===h||void 0===h||h()):t===Tc.ESC&&d())},onCompositionStart:()=>{m.current=!0},onCompositionEnd:()=>{m.current=!1},onBlur:()=>{x()},"aria-label":n,rows:1,autoSize:c}),null!==f?Xu(f,{className:"".concat(t,"-edit-content-confirm")}):null))};var sf=n(270),cf=n.n(sf),lf=function(e,t,n,r){return new(n||(n=Promise))((function(a,o){function i(e){try{c(r.next(e))}catch(f0){o(f0)}}function s(e){try{c(r.throw(e))}catch(f0){o(f0)}}function c(e){var t;e.done?a(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,s)}c((r=r.apply(e,t||[])).next())}))};const uf=e=>{let{copyConfig:t,children:n}=e;const[r,a]=o.useState(!1),[i,s]=o.useState(!1),c=o.useRef(null),l=()=>{c.current&&clearTimeout(c.current)},u={};t.format&&(u.format=t.format),o.useEffect((()=>l),[]);return{copied:r,copyLoading:i,onClick:yi((e=>lf(void 0,void 0,void 0,(function*(){var r;null===e||void 0===e||e.preventDefault(),null===e||void 0===e||e.stopPropagation(),s(!0);try{const o="function"===typeof t.text?yield t.text():t.text;cf()(o||String(n)||"",u),s(!1),a(!0),l(),c.current=setTimeout((()=>{a(!1)}),3e3),null===(r=t.onCopy)||void 0===r||r.call(t,e)}catch(o){throw s(!1),o}}))))}};function df(e,t){return o.useMemo((()=>{const n=!!e;return[n,Object.assign(Object.assign({},t),n&&"object"===typeof e?e:null)]}),[e])}const hf=(e,t)=>{const n=o.useRef(!1);o.useEffect((()=>{n.current?e():n.current=!0}),t)},pf=e=>{const t=(0,o.useRef)();return(0,o.useEffect)((()=>{t.current=e})),t.current};var ff=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const gf=o.forwardRef(((e,t)=>{const{prefixCls:n,component:r="article",className:a,rootClassName:i,setContentRef:s,children:c,direction:l,style:u}=e,d=ff(e,["prefixCls","component","className","rootClassName","setContentRef","children","direction","style"]),{getPrefixCls:h,direction:p,typography:f}=o.useContext(fi),g=null!==l&&void 0!==l?l:p;let m=t;s&&(m=Ii(t,s));const v=h("typography",n),[b,y,x]=af(v),w=cr()(v,null===f||void 0===f?void 0:f.className,{["".concat(v,"-rtl")]:"rtl"===g},a,i,y,x),k=Object.assign(Object.assign({},null===f||void 0===f?void 0:f.style),u);return b(o.createElement(r,Object.assign({className:w,style:k,ref:m},d),c))}));const mf=gf;const vf={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z"}}]},name:"check",theme:"outlined"};var bf=function(e,t){return o.createElement(Ws,Pa({},e,{ref:t,icon:vf}))};const yf=o.forwardRef(bf);const xf={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z"}}]},name:"copy",theme:"outlined"};var wf=function(e,t){return o.createElement(Ws,Pa({},e,{ref:t,icon:xf}))};const kf=o.forwardRef(wf);const Sf={icon:{tag:"svg",attrs:{viewBox:"0 0 1024 1024",focusable:"false"},children:[{tag:"path",attrs:{d:"M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z"}}]},name:"loading",theme:"outlined"};var Cf=function(e,t){return o.createElement(Ws,Pa({},e,{ref:t,icon:Sf}))};const If=o.forwardRef(Cf);function Ef(e){return!1===e?[!1,!1]:Array.isArray(e)?e:[e]}function Nf(e,t,n){return!0===e||void 0===e?t:e||n&&t}const Tf=e=>{const{prefixCls:t,copied:n,locale:r,iconOnly:a,tooltips:i,icon:s,loading:c,tabIndex:l,onCopy:u}=e,d=Ef(i),h=Ef(s),{copied:p,copy:f}=null!==r&&void 0!==r?r:{},g=n?Nf(d[1],p):Nf(d[0],f),m="string"===typeof g?g:n?p:f;return o.createElement(kd,{key:"copy",title:g},o.createElement(Fc,{className:cr()("".concat(t,"-copy"),{["".concat(t,"-copy-success")]:n,["".concat(t,"-copy-icon-only")]:a}),onClick:u,"aria-label":m,tabIndex:l},n?Nf(h[1],o.createElement(yf,null),!0):Nf(h[0],c?o.createElement(If,null):o.createElement(kf,null),!0)))},Rf=o.forwardRef(((e,t)=>{let{style:n,children:r}=e;const a=o.useRef(null);return o.useImperativeHandle(t,(()=>({isExceed:()=>{const e=a.current;return e.scrollHeight>e.clientHeight},getHeight:()=>a.current.clientHeight}))),o.createElement("span",{"aria-hidden":!0,ref:a,style:Object.assign({position:"fixed",display:"block",left:0,top:0,pointerEvents:"none",backgroundColor:"rgba(255, 0, 0, 0.65)"},n)},r)}));function Af(e){const t=typeof e;return"string"===t||"number"===t}function Of(e,t){let n=0;const r=[];for(let a=0;a<e.length;a+=1){if(n===t)return r;const o=e[a],i=n+(Af(o)?String(o).length:1);if(i>t){const e=t-n;return r.push(String(o).slice(0,e)),r}r.push(o),n=i}return e}const Ff={display:"-webkit-box",overflow:"hidden",WebkitBoxOrient:"vertical"};function _f(e){const{enableMeasure:t,width:n,text:r,children:a,rows:i,expanded:s,miscDeps:c,onEllipsis:l}=e,u=o.useMemo((()=>js(r)),[r]),d=o.useMemo((()=>function(e){let t=0;return e.forEach((e=>{Af(e)?t+=String(e).length:t+=1})),t}(u)),[r]),h=o.useMemo((()=>a(u,!1)),[r]),[p,f]=o.useState(null),g=o.useRef(null),m=o.useRef(null),v=o.useRef(null),b=o.useRef(null),[y,x]=o.useState(!1),[w,k]=o.useState(0),[S,C]=o.useState(0);wa((()=>{k(t&&n&&d?1:0)}),[n,r,i,t,u]),wa((()=>{var e,t,n,r;if(1===w){const a=!!(null===(e=m.current)||void 0===e?void 0:e.isExceed());k(a?2:3),f(a?[0,d]:null),x(a);const o=(null===(t=m.current)||void 0===t?void 0:t.getHeight())||0,s=(1===i?0:(null===(n=v.current)||void 0===n?void 0:n.getHeight())||0)+((null===(r=b.current)||void 0===r?void 0:r.getHeight())||0),c=Math.max(o,s);C(c+1),l(a)}}),[w]);const I=p?Math.ceil((p[0]+p[1])/2):0;wa((()=>{var e;const[t,n]=p||[0,0];if(t!==n){const r=((null===(e=g.current)||void 0===e?void 0:e.getHeight())||0)>S;let a=I;n-t===1&&(a=r?t:n),f(r?[t,a]:[a,n])}}),[p,I]);const E=o.useMemo((()=>{if(2!==w||!p||p[0]!==p[1]){const e=a(u,!1);return 3!==w&&0!==w?o.createElement("span",{style:Object.assign(Object.assign({},Ff),{WebkitLineClamp:i})},e):e}return a(s?u:Of(u,p[0]),y)}),[s,w,p,u].concat(br(c))),N={width:n,margin:0,padding:0};return o.createElement(o.Fragment,null,E,1===w&&o.createElement(o.Fragment,null,o.createElement(Rf,{style:Object.assign(Object.assign(Object.assign({},N),Ff),{WebkitLineClamp:i}),ref:m},h),o.createElement(Rf,{style:Object.assign(Object.assign(Object.assign({},N),Ff),{WebkitLineClamp:i-1}),ref:v},h),o.createElement(Rf,{style:Object.assign(Object.assign(Object.assign({},N),Ff),{WebkitLineClamp:1}),ref:b},a([],!0))),2===w&&p&&p[0]!==p[1]&&o.createElement(Rf,{style:Object.assign(Object.assign({},N),{top:400}),ref:g},a(Of(u,I),!0)))}const Df=e=>{let{enableEllipsis:t,isEllipsis:n,children:r,tooltipProps:a}=e;return(null===a||void 0===a?void 0:a.title)&&t?o.createElement(kd,Object.assign({open:!!n&&void 0},a),r):r};var Mf=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const Pf=o.forwardRef(((e,t)=>{var n,r,a;const{prefixCls:i,className:s,style:c,type:l,disabled:u,children:d,ellipsis:h,editable:p,copyable:f,component:g,title:m}=e,v=Mf(e,["prefixCls","className","style","type","disabled","children","ellipsis","editable","copyable","component","title"]),{getPrefixCls:b,direction:y}=o.useContext(fi),[x]=Wc("Text"),w=o.useRef(null),k=o.useRef(null),S=b("typography",i),C=Cc(v,["mark","code","delete","underline","strong","keyboard","italic"]),[I,E]=df(p),[N,T]=ki(!1,{value:E.editing}),{triggerType:R=["icon"]}=E,A=e=>{var t;e&&(null===(t=E.onStart)||void 0===t||t.call(E)),T(e)},O=pf(N);hf((()=>{var e;!N&&O&&(null===(e=k.current)||void 0===e||e.focus())}),[N]);const F=e=>{null===e||void 0===e||e.preventDefault(),A(!0)},_=e=>{var t;null===(t=E.onChange)||void 0===t||t.call(E,e),A(!1)},D=()=>{var e;null===(e=E.onCancel)||void 0===e||e.call(E),A(!1)},[M,P]=df(f),{copied:L,copyLoading:z,onClick:B}=uf({copyConfig:P,children:d}),[W,U]=o.useState(!1),[V,j]=o.useState(!1),[H,G]=o.useState(!1),[q,K]=o.useState(!1),[X,$]=o.useState(!0),[Y,Q]=df(h,{expandable:!1,symbol:e=>e?null===x||void 0===x?void 0:x.collapse:null===x||void 0===x?void 0:x.expand}),[Z,J]=ki(Q.defaultExpanded||!1,{value:Q.expanded}),ee=Y&&(!Z||"collapsible"===Q.expandable),{rows:te=1}=Q,ne=o.useMemo((()=>ee&&(void 0!==Q.suffix||Q.onEllipsis||Q.expandable||I||M)),[ee,Q,I,M]);wa((()=>{Y&&!ne&&(U(Ec("webkitLineClamp")),j(Ec("textOverflow")))}),[ne,Y]);const[re,ae]=o.useState(ee),oe=o.useMemo((()=>!ne&&(1===te?V:W)),[ne,V,W]);wa((()=>{ae(oe&&ee)}),[oe,ee]);const ie=ee&&(re?q:H),se=ee&&1===te&&re,ce=ee&&te>1&&re,[le,ue]=o.useState(0),de=e=>{var t;G(e),H!==e&&(null===(t=Q.onEllipsis)||void 0===t||t.call(Q,e))};o.useEffect((()=>{const e=w.current;if(Y&&re&&e){const t=ce?e.offsetHeight<e.scrollHeight:e.offsetWidth<e.scrollWidth;q!==t&&K(t)}}),[Y,re,d,ce,X,le]),o.useEffect((()=>{const e=w.current;if("undefined"===typeof IntersectionObserver||!e||!re||!ee)return;const t=new IntersectionObserver((()=>{$(!!e.offsetParent)}));return t.observe(e),()=>{t.disconnect()}}),[re,ee]);let he={};he=!0===Q.tooltip?{title:null!==(n=E.text)&&void 0!==n?n:d}:o.isValidElement(Q.tooltip)?{title:Q.tooltip}:"object"===typeof Q.tooltip?Object.assign({title:null!==(r=E.text)&&void 0!==r?r:d},Q.tooltip):{title:Q.tooltip};const pe=o.useMemo((()=>{const e=e=>["string","number"].includes(typeof e);if(Y&&!re)return e(E.text)?E.text:e(d)?d:e(m)?m:e(he.title)?he.title:void 0}),[Y,re,m,he.title,ie]);if(N)return o.createElement(of,{value:null!==(a=E.text)&&void 0!==a?a:"string"===typeof d?d:"",onSave:_,onCancel:D,onEnd:E.onEnd,prefixCls:S,className:s,style:c,direction:y,component:g,maxLength:E.maxLength,autoSize:E.autoSize,enterIcon:E.enterIcon});const fe=()=>{const{expandable:e,symbol:t}=Q;return e?Z&&"collapsible"!==e?null:o.createElement("a",{key:"expand",className:"".concat(S,"-").concat(Z?"collapse":"expand"),onClick:e=>((e,t)=>{var n;J(t.expanded),null===(n=Q.onExpand)||void 0===n||n.call(Q,e,t)})(e,{expanded:!Z}),"aria-label":Z?x.collapse:null===x||void 0===x?void 0:x.expand},"function"===typeof t?t(Z):t):null},ge=()=>{if(!I)return;const{icon:e,tooltip:t,tabIndex:n}=E,r=js(t)[0]||(null===x||void 0===x?void 0:x.edit),a="string"===typeof r?r:"";return R.includes("icon")?o.createElement(kd,{key:"edit",title:!1===t?"":r},o.createElement(Fc,{ref:k,className:"".concat(S,"-edit"),onClick:F,"aria-label":a,tabIndex:n},e||o.createElement(Vs,{role:"button"}))):null},me=e=>[e&&fe(),ge(),M?o.createElement(Tf,Object.assign({key:"copy"},P,{prefixCls:S,copied:L,locale:x,onCopy:B,loading:z,iconOnly:null===d||void 0===d})):null];return o.createElement(Sc,{onResize:e=>{let{offsetWidth:t}=e;ue(t)},disabled:!ee},(n=>o.createElement(Df,{tooltipProps:he,enableEllipsis:ee,isEllipsis:ie},o.createElement(mf,Object.assign({className:cr()({["".concat(S,"-").concat(l)]:l,["".concat(S,"-disabled")]:u,["".concat(S,"-ellipsis")]:Y,["".concat(S,"-ellipsis-single-line")]:se,["".concat(S,"-ellipsis-multiple-line")]:ce},s),prefixCls:i,style:Object.assign(Object.assign({},c),{WebkitLineClamp:ce?te:void 0}),component:g,ref:Ii(n,w,t),direction:y,onClick:R.includes("text")?F:void 0,"aria-label":null===pe||void 0===pe?void 0:pe.toString(),title:m},C),o.createElement(_f,{enableMeasure:ee&&!re,text:d,rows:te,width:le,onEllipsis:de,expanded:Z,miscDeps:[L,Z,z,I,M]},((t,n)=>function(e,t){let{mark:n,code:r,underline:a,delete:i,strong:s,keyboard:c,italic:l}=e,u=t;function d(e,t){t&&(u=o.createElement(e,{},u))}return d("strong",s),d("u",a),d("del",i),d("code",r),d("mark",n),d("kbd",c),d("i",l),u}(e,o.createElement(o.Fragment,null,t.length>0&&n&&!Z&&pe?o.createElement("span",{key:"show-content","aria-hidden":!0},t):t,(e=>[e&&!Z&&o.createElement("span",{"aria-hidden":!0,key:"ellipsis"},"..."),Q.suffix,me(e)])(n)))))))))})),Lf=Pf;var zf=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const Bf=o.forwardRef(((e,t)=>{var{ellipsis:n,rel:r}=e,a=zf(e,["ellipsis","rel"]);const i=Object.assign(Object.assign({},a),{rel:void 0===r&&"_blank"===a.target?"noopener noreferrer":r});return delete i.navigate,o.createElement(Lf,Object.assign({},i,{ref:t,ellipsis:!!n,component:"a"}))})),Wf=o.forwardRef(((e,t)=>o.createElement(Lf,Object.assign({ref:t},e,{component:"div"}))));var Uf=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const Vf=(e,t)=>{var{ellipsis:n}=e,r=Uf(e,["ellipsis"]);const a=o.useMemo((()=>n&&"object"===typeof n?Cc(n,["expandable","rows"]):n),[n]);return o.createElement(Lf,Object.assign({ref:t},r,{ellipsis:a,component:"span"}))},jf=o.forwardRef(Vf);var Hf=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const Gf=[1,2,3,4,5],qf=o.forwardRef(((e,t)=>{const{level:n=1}=e,r=Hf(e,["level"]);let a;return a=Gf.includes(n)?"h".concat(n):"h1",o.createElement(Lf,Object.assign({ref:t},r,{component:a}))})),Kf=mf;Kf.Text=jf,Kf.Link=Bf,Kf.Title=qf,Kf.Paragraph=Wf;const Xf=Kf;var $f,Yf=xr({},u),Qf=Yf.version,Zf=Yf.render;Yf.unmountComponentAtNode;try{Number((Qf||"").split(".")[0])>=18&&($f=Yf.createRoot)}catch(f0){}function Jf(e){var t=Yf.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;t&&"object"===lr(t)&&(t.usingClientEntryPoint=e)}var eg="__rc_react_root__";function tg(e,t){$f?function(e,t){Jf(!0);var n=t[eg]||$f(t);Jf(!1),n.render(e),t[eg]=n}(e,t):function(e,t){Zf(e,t)}(e,t)}const ng=o.createContext({}),rg=(0,o.createContext)(void 0);let ag=Object.assign({},Bc.Modal),og=[];const ig=()=>og.reduce(((e,t)=>Object.assign(Object.assign({},e),t)),Bc.Modal);const sg=e=>{const{locale:t={},children:n,_ANT_MARK__:r}=e;o.useEffect((()=>{const e=function(e){if(e){const t=Object.assign({},e);return og.push(t),ag=ig(),()=>{og=og.filter((e=>e!==t)),ag=ig()}}ag=Object.assign({},Bc.Modal)}(t&&t.Modal);return e}),[t]);const a=o.useMemo((()=>Object.assign(Object.assign({},t),{exist:!0})),[t]);return o.createElement(_c.Provider,{value:a},n)},cg="-ant-".concat(Date.now(),"-").concat(Math.random());function lg(e,t){const n=function(e,t){const n={},r=(e,t)=>{let n=e.clone();return n=(null===t||void 0===t?void 0:t(n))||n,n.toRgbString()},a=(e,t)=>{const a=new Ho(e),o=Po(a.toRgbString());n["".concat(t,"-color")]=r(a),n["".concat(t,"-color-disabled")]=o[1],n["".concat(t,"-color-hover")]=o[4],n["".concat(t,"-color-active")]=o[6],n["".concat(t,"-color-outline")]=a.clone().setAlpha(.2).toRgbString(),n["".concat(t,"-color-deprecated-bg")]=o[0],n["".concat(t,"-color-deprecated-border")]=o[2]};if(t.primaryColor){a(t.primaryColor,"primary");const e=new Ho(t.primaryColor),o=Po(e.toRgbString());o.forEach(((e,t)=>{n["primary-".concat(t+1)]=e})),n["primary-color-deprecated-l-35"]=r(e,(e=>e.lighten(35))),n["primary-color-deprecated-l-20"]=r(e,(e=>e.lighten(20))),n["primary-color-deprecated-t-20"]=r(e,(e=>e.tint(20))),n["primary-color-deprecated-t-50"]=r(e,(e=>e.tint(50))),n["primary-color-deprecated-f-12"]=r(e,(e=>e.setAlpha(.12*e.getAlpha())));const i=new Ho(o[0]);n["primary-color-active-deprecated-f-30"]=r(i,(e=>e.setAlpha(.3*e.getAlpha()))),n["primary-color-active-deprecated-d-02"]=r(i,(e=>e.darken(2)))}t.successColor&&a(t.successColor,"success"),t.warningColor&&a(t.warningColor,"warning"),t.errorColor&&a(t.errorColor,"error"),t.infoColor&&a(t.infoColor,"info");const o=Object.keys(n).map((t=>"--".concat(e,"-").concat(t,": ").concat(n[t],";")));return"\n  :root {\n    ".concat(o.join("\n"),"\n  }\n  ").trim()}(e,t);kr()&&_r(n,"".concat(cg,"-dynamic-theme"))}const ug=function(){return{componentDisabled:(0,o.useContext)(Xd),componentSize:(0,o.useContext)(Zd)}},dg=Object.assign({},i),{useId:hg}=dg,pg="undefined"===typeof hg?()=>"":hg;function fg(e){const{children:t}=e,[,n]=ui(),{motion:r}=n,a=o.useRef(!1);return a.current=a.current||!1===r,a.current?o.createElement(rl,{motion:r},t):t}const gg=()=>null;var mg=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const vg=["getTargetContainer","getPopupContainer","renderEmpty","input","pagination","form","select","button"];let bg,yg,xg,wg;function kg(){return bg||"ant"}function Sg(){return yg||pi}const Cg=()=>({getPrefixCls:(e,t)=>t||(e?"".concat(kg(),"-").concat(e):kg()),getIconPrefixCls:Sg,getRootPrefixCls:()=>bg||kg(),getTheme:()=>xg,holderRender:wg}),Ig=e=>{const{children:t,csp:n,autoInsertSpaceInButton:r,alert:a,anchor:i,form:s,locale:c,componentSize:l,direction:u,space:d,virtual:h,dropdownMatchSelectWidth:p,popupMatchSelectWidth:f,popupOverflow:g,legacyLocale:m,parentContext:v,iconPrefixCls:b,theme:y,componentDisabled:x,segmented:w,statistic:k,spin:S,calendar:C,carousel:I,cascader:E,collapse:N,typography:T,checkbox:R,descriptions:A,divider:O,drawer:F,skeleton:_,steps:D,image:M,layout:P,list:L,mentions:z,modal:B,progress:W,result:U,slider:V,breadcrumb:j,menu:H,pagination:G,input:q,textArea:K,empty:X,badge:$,radio:Y,rate:Q,switch:Z,transfer:J,avatar:ee,message:te,tag:ne,table:re,card:ae,tabs:oe,timeline:ie,timePicker:se,upload:ce,notification:le,tree:ue,colorPicker:de,datePicker:he,rangePicker:pe,flex:fe,wave:ge,dropdown:me,warning:ve,tour:be,floatButtonGroup:ye}=e,xe=o.useCallback(((t,n)=>{const{prefixCls:r}=e;if(n)return n;const a=r||v.getPrefixCls("");return t?"".concat(a,"-").concat(t):a}),[v.getPrefixCls,e.prefixCls]),we=b||v.iconPrefixCls||pi,ke=n||v.csp;as(we,ke);const Se=function(e,t,n){var r;Qu("ConfigProvider");const a=e||{},o=!1!==a.inherit&&t?t:Object.assign(Object.assign({},Jo),{hashed:null!==(r=null===t||void 0===t?void 0:t.hashed)&&void 0!==r?r:Jo.hashed,cssVar:null===t||void 0===t?void 0:t.cssVar}),i=pg();return Dr((()=>{var r,s;if(!e)return t;const c=Object.assign({},o.components);Object.keys(e.components||{}).forEach((t=>{c[t]=Object.assign(Object.assign({},c[t]),e.components[t])}));const l="css-var-".concat(i.replace(/:/g,"")),u=(null!==(r=a.cssVar)&&void 0!==r?r:o.cssVar)&&Object.assign(Object.assign(Object.assign({prefix:null===n||void 0===n?void 0:n.prefixCls},"object"===typeof o.cssVar?o.cssVar:{}),"object"===typeof a.cssVar?a.cssVar:{}),{key:"object"===typeof a.cssVar&&(null===(s=a.cssVar)||void 0===s?void 0:s.key)||l});return Object.assign(Object.assign(Object.assign({},o),a),{token:Object.assign(Object.assign({},o.token),a.token),components:c,cssVar:u})}),[a,o],((e,t)=>e.some(((e,n)=>{const r=t[n];return!Vr(e,r,!0)}))))}(y,v.theme,{prefixCls:xe("")});const Ce={csp:ke,autoInsertSpaceInButton:r,alert:a,anchor:i,locale:c||m,direction:u,space:d,virtual:h,popupMatchSelectWidth:null!==f&&void 0!==f?f:p,popupOverflow:g,getPrefixCls:xe,iconPrefixCls:we,theme:Se,segmented:w,statistic:k,spin:S,calendar:C,carousel:I,cascader:E,collapse:N,typography:T,checkbox:R,descriptions:A,divider:O,drawer:F,skeleton:_,steps:D,image:M,input:q,textArea:K,layout:P,list:L,mentions:z,modal:B,progress:W,result:U,slider:V,breadcrumb:j,menu:H,pagination:G,empty:X,badge:$,radio:Y,rate:Q,switch:Z,transfer:J,avatar:ee,message:te,tag:ne,table:re,card:ae,tabs:oe,timeline:ie,timePicker:se,upload:ce,notification:le,tree:ue,colorPicker:de,datePicker:he,rangePicker:pe,flex:fe,wave:ge,dropdown:me,warning:ve,tour:be,floatButtonGroup:ye};const Ie=Object.assign({},v);Object.keys(Ce).forEach((e=>{void 0!==Ce[e]&&(Ie[e]=Ce[e])})),vg.forEach((t=>{const n=e[t];n&&(Ie[t]=n)})),"undefined"!==typeof r&&(Ie.button=Object.assign({autoInsertSpace:r},Ie.button));const Ee=Dr((()=>Ie),Ie,((e,t)=>{const n=Object.keys(e),r=Object.keys(t);return n.length!==r.length||n.some((n=>e[n]!==t[n]))})),Ne=o.useMemo((()=>({prefixCls:we,csp:ke})),[we,ke]);let Te=o.createElement(o.Fragment,null,o.createElement(gg,{dropdownMatchSelectWidth:p}),t);const Re=o.useMemo((()=>{var e,t,n,r;return Di((null===(e=Bc.Form)||void 0===e?void 0:e.defaultValidateMessages)||{},(null===(n=null===(t=Ee.locale)||void 0===t?void 0:t.Form)||void 0===n?void 0:n.defaultValidateMessages)||{},(null===(r=Ee.form)||void 0===r?void 0:r.validateMessages)||{},(null===s||void 0===s?void 0:s.validateMessages)||{})}),[Ee,null===s||void 0===s?void 0:s.validateMessages]);Object.keys(Re).length>0&&(Te=o.createElement(rg.Provider,{value:Re},Te)),c&&(Te=o.createElement(sg,{locale:c,_ANT_MARK__:"internalMark"},Te)),(we||ke)&&(Te=o.createElement(Is.Provider,{value:Ne},Te)),l&&(Te=o.createElement(Qd,{size:l},Te)),Te=o.createElement(fg,null,Te);const Ae=o.useMemo((()=>{const e=Se||{},{algorithm:t,token:n,components:r,cssVar:a}=e,o=mg(e,["algorithm","token","components","cssVar"]),i=t&&(!Array.isArray(t)||t.length>0)?ia(t):Zo,s={};Object.entries(r||{}).forEach((e=>{let[t,n]=e;const r=Object.assign({},n);"algorithm"in r&&(!0===r.algorithm?r.theme=i:(Array.isArray(r.algorithm)||"function"===typeof r.algorithm)&&(r.theme=ia(r.algorithm)),delete r.algorithm),s[t]=r}));const c=Object.assign(Object.assign({},jo),n);return Object.assign(Object.assign({},o),{theme:i,token:c,components:s,override:Object.assign({override:c},s),cssVar:a})}),[Se]);return y&&(Te=o.createElement(ei.Provider,{value:Ae},Te)),Ee.warning&&(Te=o.createElement(Yu.Provider,{value:Ee.warning},Te)),void 0!==x&&(Te=o.createElement(Kd,{disabled:x},Te)),o.createElement(fi.Provider,{value:Ee},Te)},Eg=e=>{const t=o.useContext(fi),n=o.useContext(_c);return o.createElement(Ig,Object.assign({parentContext:t,legacyLocale:n},e))};Eg.ConfigContext=fi,Eg.SizeContext=Zd,Eg.config=e=>{const{prefixCls:t,iconPrefixCls:n,theme:r,holderRender:a}=e;void 0!==t&&(bg=t),void 0!==n&&(yg=n),"holderRender"in e&&(wg=a),r&&(!function(e){return Object.keys(e).some((e=>e.endsWith("Color")))}(r)?xg=r:lg(kg(),r))},Eg.useConfig=ug,Object.defineProperty(Eg,"SizeContext",{get:()=>Zd});const Ng=Eg;const Tg={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z"}}]},name:"check-circle",theme:"filled"};var Rg=function(e,t){return o.createElement(Ws,Pa({},e,{ref:t,icon:Tg}))};const Ag=o.forwardRef(Rg);const Og={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"}}]},name:"exclamation-circle",theme:"filled"};var Fg=function(e,t){return o.createElement(Ws,Pa({},e,{ref:t,icon:Og}))};const _g=o.forwardRef(Fg);const Dg={icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"}}]},name:"info-circle",theme:"filled"};var Mg=function(e,t){return o.createElement(Ws,Pa({},e,{ref:t,icon:Dg}))};const Pg=o.forwardRef(Mg);var Lg="".concat("accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap"," ").concat("onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError").split(/[\s\n]+/);function zg(e,t){return 0===e.indexOf(t)}var Bg=o.forwardRef((function(e,t){var n=e.prefixCls,r=e.style,a=e.className,i=e.duration,s=void 0===i?4.5:i,c=e.showProgress,l=e.pauseOnHover,u=void 0===l||l,d=e.eventKey,h=e.content,p=e.closable,f=e.closeIcon,g=void 0===f?"x":f,m=e.props,v=e.onClick,b=e.onNoticeClose,y=e.times,x=e.hovering,w=mr(o.useState(!1),2),k=w[0],S=w[1],C=mr(o.useState(0),2),I=C[0],E=C[1],N=mr(o.useState(0),2),T=N[0],R=N[1],A=x||k,O=s>0&&c,F=function(){b(d)};o.useEffect((function(){if(!A&&s>0){var e=Date.now()-T,t=setTimeout((function(){F()}),1e3*s-T);return function(){u&&clearTimeout(t),R(Date.now()-e)}}}),[s,A,y]),o.useEffect((function(){if(!A&&O&&(u||0===T)){var e,t=performance.now();return function n(){cancelAnimationFrame(e),e=requestAnimationFrame((function(e){var r=e+T-t,a=Math.min(r/(1e3*s),1);E(100*a),a<1&&n()}))}(),function(){u&&cancelAnimationFrame(e)}}}),[s,T,A,O,y]);var _=o.useMemo((function(){return"object"===lr(p)&&null!==p?p:p?{closeIcon:g}:{}}),[p,g]),D=function(e){var t,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t=!1===n?{aria:!0,data:!0,attr:!0}:!0===n?{aria:!0}:xr({},n);var r={};return Object.keys(e).forEach((function(n){(t.aria&&("role"===n||zg(n,"aria-"))||t.data&&zg(n,"data-")||t.attr&&Lg.includes(n))&&(r[n]=e[n])})),r}(_,!0),M=100-(!I||I<0?0:I>100?100:I),P="".concat(n,"-notice");return o.createElement("div",Pa({},m,{ref:t,className:cr()(P,a,dr({},"".concat(P,"-closable"),p)),style:r,onMouseEnter:function(e){var t;S(!0),null===m||void 0===m||null===(t=m.onMouseEnter)||void 0===t||t.call(m,e)},onMouseLeave:function(e){var t;S(!1),null===m||void 0===m||null===(t=m.onMouseLeave)||void 0===t||t.call(m,e)},onClick:v}),o.createElement("div",{className:"".concat(P,"-content")},h),p&&o.createElement("a",Pa({tabIndex:0,className:"".concat(P,"-close"),onKeyDown:function(e){"Enter"!==e.key&&"Enter"!==e.code&&e.keyCode!==Tc.ENTER||F()},"aria-label":"Close"},D,{onClick:function(e){e.preventDefault(),e.stopPropagation(),F()}}),_.closeIcon),O&&o.createElement("progress",{className:"".concat(P,"-progress"),max:"100",value:M},M+"%"))}));const Wg=Bg;var Ug=o.createContext({});const Vg=function(e){var t=e.children,n=e.classNames;return o.createElement(Ug.Provider,{value:{classNames:n}},t)};const jg=function(e){var t,n,r,a={offset:8,threshold:3,gap:16};e&&"object"===lr(e)&&(a.offset=null!==(t=e.offset)&&void 0!==t?t:8,a.threshold=null!==(n=e.threshold)&&void 0!==n?n:3,a.gap=null!==(r=e.gap)&&void 0!==r?r:16);return[!!e,a]};var Hg=["className","style","classNames","styles"];const Gg=function(e){var t=e.configList,n=e.placement,r=e.prefixCls,a=e.className,i=e.style,s=e.motion,c=e.onAllNoticeRemoved,l=e.onNoticeClose,u=e.stack,d=(0,o.useContext)(Ug).classNames,h=(0,o.useRef)({}),p=mr((0,o.useState)(null),2),f=p[0],g=p[1],m=mr((0,o.useState)([]),2),v=m[0],b=m[1],y=t.map((function(e){return{config:e,key:String(e.key)}})),x=mr(jg(u),2),w=x[0],k=x[1],S=k.offset,C=k.threshold,I=k.gap,E=w&&(v.length>0||y.length<=C),N="function"===typeof s?s(n):s;return(0,o.useEffect)((function(){w&&v.length>1&&b((function(e){return e.filter((function(e){return y.some((function(t){var n=t.key;return e===n}))}))}))}),[v,y,w]),(0,o.useEffect)((function(){var e,t;w&&h.current[null===(e=y[y.length-1])||void 0===e?void 0:e.key]&&g(h.current[null===(t=y[y.length-1])||void 0===t?void 0:t.key])}),[y,w]),o.createElement(Jl,Pa({key:n,className:cr()(r,"".concat(r,"-").concat(n),null===d||void 0===d?void 0:d.list,a,dr(dr({},"".concat(r,"-stack"),!!w),"".concat(r,"-stack-expanded"),E)),style:i,keys:y,motionAppear:!0},N,{onAllRemoved:function(){c(n)}}),(function(e,t){var a=e.config,i=e.className,s=e.style,c=e.index,u=a,p=u.key,g=u.times,m=String(p),x=a,k=x.className,C=x.style,N=x.classNames,T=x.styles,R=Cs(x,Hg),A=y.findIndex((function(e){return e.key===m})),O={};if(w){var F=y.length-1-(A>-1?A:c-1),_="top"===n||"bottom"===n?"-50%":"0";if(F>0){var D,M,P;O.height=E?null===(D=h.current[m])||void 0===D?void 0:D.offsetHeight:null===f||void 0===f?void 0:f.offsetHeight;for(var L=0,z=0;z<F;z++){var B;L+=(null===(B=h.current[y[y.length-1-z].key])||void 0===B?void 0:B.offsetHeight)+I}var W=(E?L:F*S)*(n.startsWith("top")?1:-1),U=!E&&null!==f&&void 0!==f&&f.offsetWidth&&null!==(M=h.current[m])&&void 0!==M&&M.offsetWidth?((null===f||void 0===f?void 0:f.offsetWidth)-2*S*(F<3?F:3))/(null===(P=h.current[m])||void 0===P?void 0:P.offsetWidth):1;O.transform="translate3d(".concat(_,", ").concat(W,"px, 0) scaleX(").concat(U,")")}else O.transform="translate3d(".concat(_,", 0, 0)")}return o.createElement("div",{ref:t,className:cr()("".concat(r,"-notice-wrapper"),i,null===N||void 0===N?void 0:N.wrapper),style:xr(xr(xr({},s),O),null===T||void 0===T?void 0:T.wrapper),onMouseEnter:function(){return b((function(e){return e.includes(m)?e:[].concat(br(e),[m])}))},onMouseLeave:function(){return b((function(e){return e.filter((function(e){return e!==m}))}))}},o.createElement(Wg,Pa({},R,{ref:function(e){A>-1?h.current[m]=e:delete h.current[m]},prefixCls:r,classNames:N,styles:T,className:cr()(k,null===d||void 0===d?void 0:d.notice),style:C,times:g,key:p,eventKey:p,onNoticeClose:l,hovering:w&&v.length>0})))}))};var qg=o.forwardRef((function(e,t){var n=e.prefixCls,r=void 0===n?"rc-notification":n,a=e.container,i=e.motion,s=e.maxCount,c=e.className,u=e.style,d=e.onAllRemoved,h=e.stack,p=e.renderNotifications,f=mr(o.useState([]),2),g=f[0],m=f[1],v=function(e){var t,n=g.find((function(t){return t.key===e}));null===n||void 0===n||null===(t=n.onClose)||void 0===t||t.call(n),m((function(t){return t.filter((function(t){return t.key!==e}))}))};o.useImperativeHandle(t,(function(){return{open:function(e){m((function(t){var n,r=br(t),a=r.findIndex((function(t){return t.key===e.key})),o=xr({},e);a>=0?(o.times=((null===(n=t[a])||void 0===n?void 0:n.times)||0)+1,r[a]=o):(o.times=0,r.push(o));return s>0&&r.length>s&&(r=r.slice(-s)),r}))},close:function(e){v(e)},destroy:function(){m([])}}}));var b=mr(o.useState({}),2),y=b[0],x=b[1];o.useEffect((function(){var e={};g.forEach((function(t){var n=t.placement,r=void 0===n?"topRight":n;r&&(e[r]=e[r]||[],e[r].push(t))})),Object.keys(y).forEach((function(t){e[t]=e[t]||[]})),x(e)}),[g]);var w=function(e){x((function(t){var n=xr({},t);return(n[e]||[]).length||delete n[e],n}))},k=o.useRef(!1);if(o.useEffect((function(){Object.keys(y).length>0?k.current=!0:k.current&&(null===d||void 0===d||d(),k.current=!1)}),[y]),!a)return null;var S=Object.keys(y);return(0,l.createPortal)(o.createElement(o.Fragment,null,S.map((function(e){var t=y[e],n=o.createElement(Gg,{key:e,configList:t,placement:e,prefixCls:r,className:null===c||void 0===c?void 0:c(e),style:null===u||void 0===u?void 0:u(e),motion:i,onNoticeClose:v,onAllNoticeRemoved:w,stack:h});return p?p(n,{prefixCls:r,key:e}):n}))),a)}));const Kg=qg;var Xg=["getContainer","motion","prefixCls","maxCount","className","style","onAllRemoved","stack","renderNotifications"],$g=function(){return document.body},Yg=0;function Qg(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.getContainer,n=void 0===t?$g:t,r=e.motion,a=e.prefixCls,i=e.maxCount,s=e.className,c=e.style,l=e.onAllRemoved,u=e.stack,d=e.renderNotifications,h=Cs(e,Xg),p=mr(o.useState(),2),f=p[0],g=p[1],m=o.useRef(),v=o.createElement(Kg,{container:f,ref:m,prefixCls:a,motion:r,maxCount:i,className:s,style:c,onAllRemoved:l,stack:u,renderNotifications:d}),b=mr(o.useState([]),2),y=b[0],x=b[1],w=o.useMemo((function(){return{open:function(e){var t=function(){for(var e={},t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return n.forEach((function(t){t&&Object.keys(t).forEach((function(n){var r=t[n];void 0!==r&&(e[n]=r)}))})),e}(h,e);null!==t.key&&void 0!==t.key||(t.key="rc-notification-".concat(Yg),Yg+=1),x((function(e){return[].concat(br(e),[{type:"open",config:t}])}))},close:function(e){x((function(t){return[].concat(br(t),[{type:"close",key:e}])}))},destroy:function(){x((function(e){return[].concat(br(e),[{type:"destroy"}])}))}}}),[]);return o.useEffect((function(){g(n())})),o.useEffect((function(){m.current&&y.length&&(y.forEach((function(e){switch(e.type){case"open":m.current.open(e.config);break;case"close":m.current.close(e.key);break;case"destroy":m.current.destroy()}})),x((function(e){return e.filter((function(e){return!y.includes(e)}))})))}),[y]),[w,v]}const Zg=e=>{const{componentCls:t,iconCls:n,boxShadow:r,colorText:a,colorSuccess:o,colorError:i,colorWarning:s,colorInfo:c,fontSizeLG:l,motionEaseInOutCirc:u,motionDurationSlow:d,marginXS:h,paddingXS:p,borderRadiusLG:f,zIndexPopup:g,contentPadding:m,contentBg:v}=e,b="".concat(t,"-notice"),y=new eo("MessageMoveIn",{"0%":{padding:0,transform:"translateY(-100%)",opacity:0},"100%":{padding:p,transform:"translateY(0)",opacity:1}}),x=new eo("MessageMoveOut",{"0%":{maxHeight:e.height,padding:p,opacity:1},"100%":{maxHeight:0,padding:0,opacity:0}}),w={padding:p,textAlign:"center",["".concat(t,"-custom-content > ").concat(n)]:{verticalAlign:"text-bottom",marginInlineEnd:h,fontSize:l},["".concat(b,"-content")]:{display:"inline-block",padding:m,background:v,borderRadius:f,boxShadow:r,pointerEvents:"all"},["".concat(t,"-success > ").concat(n)]:{color:o},["".concat(t,"-error > ").concat(n)]:{color:i},["".concat(t,"-warning > ").concat(n)]:{color:s},["".concat(t,"-info > ").concat(n,",\n      ").concat(t,"-loading > ").concat(n)]:{color:c}};return[{[t]:Object.assign(Object.assign({},Mi(e)),{color:a,position:"fixed",top:h,width:"100%",pointerEvents:"none",zIndex:g,["".concat(t,"-move-up")]:{animationFillMode:"forwards"},["\n        ".concat(t,"-move-up-appear,\n        ").concat(t,"-move-up-enter\n      ")]:{animationName:y,animationDuration:d,animationPlayState:"paused",animationTimingFunction:u},["\n        ".concat(t,"-move-up-appear").concat(t,"-move-up-appear-active,\n        ").concat(t,"-move-up-enter").concat(t,"-move-up-enter-active\n      ")]:{animationPlayState:"running"},["".concat(t,"-move-up-leave")]:{animationName:x,animationDuration:d,animationPlayState:"paused",animationTimingFunction:u},["".concat(t,"-move-up-leave").concat(t,"-move-up-leave-active")]:{animationPlayState:"running"},"&-rtl":{direction:"rtl",span:{direction:"rtl"}}})},{[t]:{["".concat(b,"-wrapper")]:Object.assign({},w)}},{["".concat(t,"-notice-pure-panel")]:Object.assign(Object.assign({},w),{padding:0,textAlign:"start"})}]},Jg=ls("Message",(e=>{const t=es(e,{height:150});return[Zg(t)]}),(e=>({zIndexPopup:e.zIndexPopupBase+1e3+10,contentBg:e.colorBgElevated,contentPadding:"".concat((e.controlHeightLG-e.fontSize*e.lineHeight)/2,"px ").concat(e.paddingSM,"px")})));var em=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const tm={info:o.createElement(Pg,null),success:o.createElement(Ag,null),error:o.createElement(jd,null),warning:o.createElement(_g,null),loading:o.createElement(If,null)},nm=e=>{let{prefixCls:t,type:n,icon:r,children:a}=e;return o.createElement("div",{className:cr()("".concat(t,"-custom-content"),"".concat(t,"-").concat(n))},r||tm[n],o.createElement("span",null,a))},rm=e=>{const{prefixCls:t,className:n,type:r,icon:a,content:i}=e,s=em(e,["prefixCls","className","type","icon","content"]),{getPrefixCls:c}=o.useContext(fi),l=t||c("message"),u=$d(l),[d,h,p]=Jg(l,u);return d(o.createElement(Wg,Object.assign({},s,{prefixCls:l,className:cr()(n,h,"".concat(l,"-notice-pure-panel"),p,u),eventKey:"pure",duration:null,content:o.createElement(nm,{prefixCls:l,type:r,icon:a},i)})))};const am={icon:{tag:"svg",attrs:{"fill-rule":"evenodd",viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z"}}]},name:"close",theme:"outlined"};var om=function(e,t){return o.createElement(Ws,Pa({},e,{ref:t,icon:am}))};const im=o.forwardRef(om);function sm(e){let t;const n=new Promise((n=>{t=e((()=>{n(!0)}))})),r=()=>{null===t||void 0===t||t()};return r.then=(e,t)=>n.then(e,t),r.promise=n,r}var cm=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};const lm=3,um=e=>{let{children:t,prefixCls:n}=e;const r=$d(n),[a,i,s]=Jg(n,r);return a(o.createElement(Vg,{classNames:{list:cr()(i,s,r)}},t))},dm=(e,t)=>{let{prefixCls:n,key:r}=t;return o.createElement(um,{prefixCls:n,key:r},e)},hm=o.forwardRef(((e,t)=>{const{top:n,prefixCls:r,getContainer:a,maxCount:i,duration:s=lm,rtl:c,transitionName:l,onAllRemoved:u}=e,{getPrefixCls:d,getPopupContainer:h,message:p,direction:f}=o.useContext(fi),g=r||d("message"),m=o.createElement("span",{className:"".concat(g,"-close-x")},o.createElement(im,{className:"".concat(g,"-close-icon")})),[v,b]=Qg({prefixCls:g,style:()=>({left:"50%",transform:"translateX(-50%)",top:null!==n&&void 0!==n?n:8}),className:()=>cr()({["".concat(g,"-rtl")]:null!==c&&void 0!==c?c:"rtl"===f}),motion:()=>function(e,t){return{motionName:null!==t&&void 0!==t?t:"".concat(e,"-move-up")}}(g,l),closable:!1,closeIcon:m,duration:s,getContainer:()=>(null===a||void 0===a?void 0:a())||(null===h||void 0===h?void 0:h())||document.body,maxCount:i,onAllRemoved:u,renderNotifications:dm});return o.useImperativeHandle(t,(()=>Object.assign(Object.assign({},v),{prefixCls:g,message:p}))),b}));let pm=0;function fm(e){const t=o.useRef(null),n=(Qu("Message"),o.useMemo((()=>{const e=e=>{var n;null===(n=t.current)||void 0===n||n.close(e)},n=n=>{if(!t.current){const e=()=>{};return e.then=()=>{},e}const{open:r,prefixCls:a,message:i}=t.current,s="".concat(a,"-notice"),{content:c,icon:l,type:u,key:d,className:h,style:p,onClose:f}=n,g=cm(n,["content","icon","type","key","className","style","onClose"]);let m=d;return void 0!==m&&null!==m||(pm+=1,m="antd-message-".concat(pm)),sm((t=>(r(Object.assign(Object.assign({},g),{key:m,content:o.createElement(nm,{prefixCls:a,type:u,icon:l},c),placement:"top",className:cr()(u&&"".concat(s,"-").concat(u),h,null===i||void 0===i?void 0:i.className),style:Object.assign(Object.assign({},null===i||void 0===i?void 0:i.style),p),onClose:()=>{null===f||void 0===f||f(),t()}})),()=>{e(m)})))},r={open:n,destroy:n=>{var r;void 0!==n?e(n):null===(r=t.current)||void 0===r||r.destroy()}};return["info","success","warning","error","loading"].forEach((e=>{r[e]=(t,r,a)=>{let o,i,s;o=t&&"object"===typeof t&&"content"in t?t:{content:t},"function"===typeof r?s=r:(i=r,s=a);const c=Object.assign(Object.assign({onClose:s,duration:i},o),{type:e});return n(c)}})),r}),[]));return[n,o.createElement(hm,Object.assign({key:"message-holder"},e,{ref:t}))]}let gm=null,mm=e=>e(),vm=[],bm={};function ym(){const{getContainer:e,duration:t,rtl:n,maxCount:r,top:a}=bm,o=(null===e||void 0===e?void 0:e())||document.body;return{getContainer:()=>o,duration:t,rtl:n,maxCount:r,top:a}}const xm=o.forwardRef(((e,t)=>{const{messageConfig:n,sync:r}=e,{getPrefixCls:a}=(0,o.useContext)(fi),i=bm.prefixCls||a("message"),s=(0,o.useContext)(ng),[c,l]=fm(Object.assign(Object.assign(Object.assign({},n),{prefixCls:i}),s.message));return o.useImperativeHandle(t,(()=>{const e=Object.assign({},c);return Object.keys(e).forEach((t=>{e[t]=function(){return r(),c[t].apply(c,arguments)}})),{instance:e,sync:r}})),l})),wm=o.forwardRef(((e,t)=>{const[n,r]=o.useState(ym),a=()=>{r(ym)};o.useEffect(a,[]);const i=Cg(),s=i.getRootPrefixCls(),c=i.getIconPrefixCls(),l=i.getTheme(),u=o.createElement(xm,{ref:t,sync:a,messageConfig:n});return o.createElement(Ng,{prefixCls:s,iconPrefixCls:c,theme:l},i.holderRender?i.holderRender(u):u)}));function km(){if(!gm){const e=document.createDocumentFragment(),t={fragment:e};return gm=t,void mm((()=>{tg(o.createElement(wm,{ref:e=>{const{instance:n,sync:r}=e||{};Promise.resolve().then((()=>{!t.instance&&n&&(t.instance=n,t.sync=r,km())}))}}),e)}))}gm.instance&&(vm.forEach((e=>{const{type:t,skipped:n}=e;if(!n)switch(t){case"open":mm((()=>{const t=gm.instance.open(Object.assign(Object.assign({},bm),e.config));null===t||void 0===t||t.then(e.resolve),e.setCloseFn(t)}));break;case"destroy":mm((()=>{null===gm||void 0===gm||gm.instance.destroy(e.key)}));break;default:mm((()=>{var n;const r=(n=gm.instance)[t].apply(n,br(e.args));null===r||void 0===r||r.then(e.resolve),e.setCloseFn(r)}))}})),vm=[])}const Sm={open:function(e){const t=sm((t=>{let n;const r={type:"open",config:e,resolve:t,setCloseFn:e=>{n=e}};return vm.push(r),()=>{n?mm((()=>{n()})):r.skipped=!0}}));return km(),t},destroy:e=>{vm.push({type:"destroy",key:e}),km()},config:function(e){bm=Object.assign(Object.assign({},bm),e),mm((()=>{var e;null===(e=null===gm||void 0===gm?void 0:gm.sync)||void 0===e||e.call(gm)}))},useMessage:function(e){return fm(e)},_InternalPanelDoNotUseOrYouWillBeFired:rm},Cm=Sm;["success","info","warning","error","loading"].forEach((e=>{Cm[e]=function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return function(e,t){Cg();const n=sm((n=>{let r;const a={type:e,args:t,resolve:n,setCloseFn:e=>{r=e}};return vm.push(a),()=>{r?mm((()=>{r()})):a.skipped=!0}}));return km(),n}(e,n)}}));const Im=Cm;var Em=n(29),Nm=n.n(Em),Tm=n(579);function Rm(){return(0,Tm.jsx)(Nm(),{videoConstraints:{width:1280,height:720,facingMode:"user"},onUserMediaError:e=>{console.error("Error: ",e),Im.error("unexpected Error Occured: ",e)}})}class Am{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Om{refCount(e){return Fm("refCount")}incRef(e){return Fm("incRef")}timerAvailable(){return!0}time(e){return Fm("time")}read(e){return Fm("read")}readSync(e){return Fm("readSync")}readToGPU(e,t){return Fm("readToGPU")}numDataIds(){return Fm("numDataIds")}disposeData(e,t){return Fm("disposeData")}write(e,t,n){return Fm("write")}move(e,t,n,r,a){return Fm("move")}createTensorFromGPUData(e,t,n){return Fm("createTensorFromGPUData")}memory(){return Fm("memory")}floatPrecision(){return Fm("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Fm("dispose")}}function Fm(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function _m(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Pm(e,t,n)}function Dm(e,t,n){return Math.max(e,Math.min(t,n))}function Mm(e){return e%2===0?e:e+1}function Pm(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function Lm(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function zm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Lm(Um(e,t),(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}function Bm(e){Lm(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Wm(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Um(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Vm(e){return e%1===0}function jm(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Hm(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Gm(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,o)=>{let i=0;const s=()=>{if(e())return void a();i++;const c=t(i);null!=n&&i>=n?o():null!=r?r(s,c):setTimeout(s,c)};s()}))}function qm(e,t){let n=1,r=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(-1===e[o]){if(-1!==r)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(r," and dim ").concat(o));r=o}else if(e[o]<0)throw Error("Shapes can not be < 0. Found ".concat(e[o]," at dim ").concat(o));if(-1===r){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const a=e.slice();return a[r]=t/n,a}function Km(e,t){const n=t.length;return Lm((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e))),Lm(e.every((e=>Vm(e))),(()=>"All values in axis param must be integers but "+"got axis ".concat(e))),e.map((e=>e<0?n+e:e))}function Xm(e,t){const n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||a?null:Km(t,e).sort();let i=0;for(let s=0;s<e.length;++s){if(null!=o){if(o[i]===s&&1!==e[s])throw new Error("Can't squeeze axis ".concat(s," since its dim '").concat(e[s],"' is not 1"));(null==o[i]||o[i]>s)&&1===e[s]&&(n.push(e[s]),r.push(s)),o[i]<=s&&i++}1!==e[s]&&(n.push(e[s]),r.push(s))}return{newShape:n,keptDims:r}}function $m(e,t){return Ym(e,t)}function Ym(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function Qm(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function Zm(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function Jm(e){return"string"===typeof e||e instanceof String}function ev(e){return"number"===typeof e}function tv(e){return Array.isArray(e)?tv(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":ev(e)?"float32":Jm(e)?"string":"boolean"===typeof e?"bool":"float32"}function nv(e){return!!(e&&e.constructor&&e.call&&e.apply)}function rv(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function av(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function ov(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===t.length){const o=t[0]*(r?2:1);for(let t=0;t<o;t++)a[t]=n[e+t]}else{const o=t[0],i=t.slice(1),s=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<o;t++)a[t]=ov(e+t*s,i,n,r)}return a}function iv(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return ov(0,e,t,n)}function sv(e,t){const n=cv(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function cv(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function lv(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return iv(e,new Float32Array(n));if("int32"===t)return iv(e,new Int32Array(n));if("bool"===t)return iv(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function uv(e){e.forEach((t=>{Lm(Number.isInteger(t)&&t>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"].")))}))}function dv(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function hv(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function pv(e){return e&&e.then&&"function"===typeof e.then}const fv="tfjsflags";class gv{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=mv,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(vv().getBool("IS_TEST")||vv().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];vv().getBool("IS_TEST")||vv().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(pv(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(fv in e){e[fv].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:t}(0,n)}))}}}function mv(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function vv(){return yv}let bv,yv=null;function xv(){if(null==bv){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}bv=e}return bv}function wv(e,t){const n=function(){const e=xv();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const kv="Abs",Sv="Acos",Cv="Acosh",Iv="Add",Ev="AddN",Nv="All",Tv="Any",Rv="ArgMax",Av="ArgMin",Ov="Asin",Fv="Asinh",_v="Atan",Dv="Atanh",Mv="Atan2",Pv="AvgPool",Lv="AvgPoolGrad",zv="AvgPool3D",Bv="AvgPool3DGrad",Wv="BatchMatMul",Uv="BatchToSpaceND",Vv="Bincount",jv="BitwiseAnd",Hv="BroadcastArgs",Gv="Cast",qv="Ceil",Kv="ClipByValue",Xv="Complex",$v="ComplexAbs",Yv="Concat",Qv="Conv2D",Zv="Conv2DBackpropFilter",Jv="Conv2DBackpropInput",eb="Conv3D",tb="Conv3DBackpropFilterV2",nb="Conv3DBackpropInputV2",rb="Cos",ab="Cosh",ob="Cumprod",ib="Cumsum",sb="CropAndResize",cb="DenseBincount",lb="DepthToSpace",ub="DepthwiseConv2dNative",db="DepthwiseConv2dNativeBackpropFilter",hb="DepthwiseConv2dNativeBackpropInput",pb="Diag",fb="Dilation2D",gb="Dilation2DBackpropInput",mb="Dilation2DBackpropFilter",vb="Draw",bb="RealDiv",yb="Einsum",xb="Elu",wb="EluGrad",kb="Erf",Sb="Equal",Cb="Exp",Ib="ExpandDims",Eb="Expm1",Nb="FFT",Tb="Fill",Rb="FlipLeftRight",Ab="Floor",Ob="FloorDiv",Fb="FusedBatchNorm",_b="GatherV2",Db="GatherNd",Mb="Greater",Pb="GreaterEqual",Lb="Identity",zb="IFFT",Bb="Imag",Wb="IsFinite",Ub="IsInf",Vb="IsNan",jb="LeakyRelu",Hb="Less",Gb="LessEqual",qb="LinSpace",Kb="Log",Xb="Log1p",$b="LogicalAnd",Yb="LogicalNot",Qb="LogicalOr",Zb="LRN",Jb="LRNGrad",ey="Max",ty="Maximum",ny="MaxPool",ry="MaxPoolGrad",ay="MaxPool3D",oy="MaxPool3DGrad",iy="MaxPoolWithArgmax",sy="Mean",cy="Min",ly="Minimum",uy="MirrorPad",dy="Mod",hy="Multinomial",py="Multiply",fy="Neg",gy="NotEqual",my="NonMaxSuppressionV3",vy="NonMaxSuppressionV4",by="NonMaxSuppressionV5",yy="OnesLike",xy="OneHot",wy="Pack",ky="PadV2",Sy="Pow",Cy="Prelu",Iy="Prod",Ey="RaggedGather",Ny="RaggedRange",Ty="RaggedTensorToTensor",Ry="Range",Ay="Real",Oy="Reciprocal",Fy="Relu",_y="Reshape",Dy="ResizeNearestNeighbor",My="ResizeNearestNeighborGrad",Py="ResizeBilinear",Ly="ResizeBilinearGrad",zy="Relu6",By="Reverse",Wy="Round",Uy="Rsqrt",Vy="ScatterNd",jy="TensorScatterUpdate",Hy="SearchSorted",Gy="Select",qy="Selu",Ky="Slice",Xy="Sin",$y="Sinh",Yy="Sign",Qy="Sigmoid",Zy="Softplus",Jy="Sqrt",ex="Sum",tx="SpaceToBatchND",nx="SplitV",rx="Softmax",ax="SparseFillEmptyRows",ox="SparseReshape",ix="SparseSegmentMean",sx="SparseSegmentSum",cx="SparseToDense",lx="SquaredDifference",ux="Square",dx="StaticRegexReplace",hx="StridedSlice",px="StringNGrams",fx="StringSplit",gx="StringToHashBucketFast",mx="Sub",vx="Tan",bx="Tanh",yx="Tile",xx="TopK",wx="Transform",kx="Transpose",Sx="Unique",Cx="Unpack",Ix="UnsortedSegmentSum",Ex="ZerosLike",Nx="Step",Tx="FromPixels",Rx="RotateWithOffset",Ax="_FusedMatMul",Ox="FusedConv2D",Fx="FusedDepthwiseConv2D";function _x(){vv().getBool("IS_TEST")||vv().getBool("PROD")||console.warn(...arguments)}function Dx(){vv().getBool("IS_TEST")||vv().getBool("PROD")||console.log(...arguments)}const Mx=wv("kernelRegistry",(()=>new Map)),Px=wv("gradRegistry",(()=>new Map));function Lx(e,t){const n=Vx(e,t);return Mx.get(n)}function zx(e){return Px.get(e)}function Bx(e){const t=Mx.entries(),n=[];for(;;){const{done:r,value:a}=t.next();if(r)break;const[o,i]=a,[s]=o.split("_");s===e&&n.push(i)}return n}function Wx(e){const{kernelName:t,backendName:n}=e,r=Vx(t,n);Mx.has(r)&&_x("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),Mx.set(r,e)}function Ux(e){const{kernelName:t}=e;Px.has(t)&&vv().getBool("DEBUG")&&_x("Overriding the gradient for '".concat(t,"'")),Px.set(t,e)}function Vx(e,t){return"".concat(t,"_").concat(e)}function jx(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Hx=n(353);const Gx=n.n(Hx)()||Hx;function qx(e){return Gx.fromString(e,!0,16)}const Kx=qx("c3a5c85c97cb3127"),Xx=qx("b492b66fbe98f273"),$x=qx("9ae16a3b2f90404f");function Yx(e){return e.xor(e.shru(47))}function Qx(e,t,n){const r=e.slice(t,t+n);return Gx.fromBytes(Array.from(r),!0,!0)}function Zx(e,t){return Qx(e,t,8)}function Jx(e,t){return Qx(e,t,4)}function ew(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function tw(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:qx("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function nw(e,t,n,r){return function(e,t,n,r,a,o){a=a.add(e),o=ew(o.add(a).add(r),21);const i=a;return a=(a=a.add(t)).add(n),o=o.add(ew(a,44)),[a.add(r),o.add(i)]}(Zx(e,t),Zx(e,t+8),Zx(e,t+16),Zx(e,t+24),n,r)}function rw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Gx.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=$x.add(2*t),r=Zx(e,0).add($x),a=Zx(e,t-8);return tw(ew(a,37).mul(n).add(r),ew(r,25).add(a).mul(n),n)}if(t>=4){const n=$x.add(2*t);return tw(Jx(e,0).shl(3).add(t),Jx(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return Yx($x.mul(n).xor(Kx.mul(r))).mul($x)}return $x}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=$x.add(2*t),r=Zx(e,0).mul(Xx),a=Zx(e,8),o=Zx(e,t-8).mul(n),i=Zx(e,t-16).mul($x);return tw(ew(r.add(a),43).add(ew(o,30)).add(i),r.add(ew(a.add($x),18)).add(o),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=$x.add(2*t),r=Zx(e,0).mul($x),a=Zx(e,8),o=Zx(e,t-8).mul(n),i=Zx(e,t-16).mul($x),s=ew(r.add(a),43).add(ew(o,30)).add(i),c=tw(s,r.add(ew(a.add($x),18)).add(o),n),l=Zx(e,16).mul(n),u=Zx(e,24),d=s.add(Zx(e,t-32)).mul(n),h=c.add(Zx(e,t-24)).mul(n);return tw(ew(l.add(u),43).add(ew(d,30)).add(h),l.add(ew(u.add(r),18)).add(d),n)}(e,t);let r=n,a=n.mul(Xx).add(113),o=Yx(a.mul($x).add(113)).mul($x),i=[Gx.UZERO,Gx.UZERO],s=[Gx.UZERO,Gx.UZERO];r=r.mul($x).add(Zx(e,0));let c=0;const l=64*(t-1>>6),u=l+(t-1&63)-63;do{r=ew(r.add(a).add(i[0]).add(Zx(e,c+8)),37).mul(Xx),a=ew(a.add(i[1]).add(Zx(e,c+48)),42).mul(Xx),r=r.xor(s[1]),a=a.add(i[0]).add(Zx(e,c+40)),o=ew(o.add(s[0]),33).mul(Xx),i=nw(e,c,i[1].mul(Xx),r.add(s[0])),s=nw(e,c+32,o.add(s[1]),a.add(Zx(e,c+16))),[o,r]=[r,o],c+=64}while(c!==l);const d=Xx.add(o.and(255).shl(1));return c=u,s[0]=s[0].add(t-1&63),i[0]=i[0].add(s[0]),s[0]=s[0].add(i[0]),r=ew(r.add(a).add(i[0]).add(Zx(e,c+8)),37).mul(d),a=ew(a.add(i[1]).add(Zx(e,c+48)),42).mul(d),r=r.xor(s[1].mul(9)),a=a.add(i[0].mul(9).add(Zx(e,c+40))),o=ew(o.add(s[0]),33).mul(d),i=nw(e,c,i[1].mul(d),r.add(s[0])),s=nw(e,c+32,o.add(s[1]),a.add(Zx(e,c+16))),[o,r]=[r,o],tw(tw(i[0],s[0],d).add(Yx(a).mul(Kx)).add(o),tw(i[1],s[1],d).add(r),d)}function aw(e,t){return"string"===t?sw(e):ow([e],t)}function ow(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=uw(e)),vv().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(r,"."))}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function iw(){return vv().platform.now()}function sw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",vv().platform.encode(e,t)}function cw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",vv().platform.decode(e,t)}function lw(e){return null!=vv().platform.isTypedArray?vv().platform.isTypedArray(e):jx(e)}function uw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||pv(e)||null==e||lw(e)&&n)t.push(e);else if(Array.isArray(e)||lw(e))for(let r=0;r<e.length;++r)uw(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)uw(e[a],t,n)}return t}class dw{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new pw)}profileKernel(e,t,n){let r;const a=()=>{r=n()};let o;const i=iw();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const e of r)e.dataSync();o=Promise.resolve({kernelMs:iw()-i})}if(vv().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let s=0;s<r.length;s++){const t=r[s];t.data().then((n=>{hw(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then((e=>e.kernelMs)),extraInfo:o.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:o}=e;n.forEach((e=>{Promise.all([e.data(),r,o]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}}function hw(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class pw{logKernelProfile(e,t,n,r,a,o){const i="number"===typeof r?Hm("".concat(r,"ms"),9):r.error,s=Hm(e,25),c=t.rank,l=t.size,u=Hm(t.shape.toString(),14);let d="";for(const h in a){const e=a[h];if(null!=e){const n=e.shape||t.shape,r=n.length;d+="".concat(h,": ").concat(r,"D ").concat(r>0?n:""," ")}}console.log("%c".concat(s,"\t%c").concat(i,"\t%c").concat(c,"D ").concat(u,"\t%c").concat(l,"\t%c").concat(d,"\t%c").concat(o),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const fw=20,gw=3,mw=7;function vw(e,t,n,r){const a=av(t),o=function(e,t,n,r){const a=Wm(t),o=r[r.length-1],i=new Array(o).fill(0),s=t.length,c="complex64"===n?ww(e):e;if(s>1)for(let l=0;l<a/o;l++){const e=l*o;for(let t=0;t<o;t++)i[t]=Math.max(i[t],bw(c[e+t],0,n).length)}return i}(e,t,n,a),i=t.length,s=xw(e,t,n,a,o),c=["Tensor"];return r&&(c.push("  dtype: ".concat(n)),c.push("  rank: ".concat(i)),c.push("  shape: [".concat(t,"]")),c.push("  values:")),c.push(s.map((e=>"    "+e)).join("\n")),c.join("\n")}function bw(e,t,n){let r;return r=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(mw))," + ")+"".concat(parseFloat(e[1].toFixed(mw)),"j"):Jm(e)?"'".concat(e,"'"):"bool"===n?yw(e):parseFloat(e.toFixed(mw)).toString(),Hm(r,t)}function yw(e){return 0===e?"false":"true"}function xw(e,t,n,r,a){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i="complex64"===n?2:1,s=t[0],c=t.length;if(0===c){if("complex64"===n){return[bw(ww(e)[0],0,n)]}return"bool"===n?[yw(e[0])]:[e[0].toString()]}if(1===c){if(s>fw){const t=gw*i;let r=Array.from(e.slice(0,t)),o=Array.from(e.slice((s-gw)*i,s*i));return"complex64"===n&&(r=ww(r),o=ww(o)),["["+r.map(((e,t)=>bw(e,a[t],n))).join(", ")+", ..., "+o.map(((e,t)=>bw(e,a[s-gw+t],n))).join(", ")+"]"]}return["["+("complex64"===n?ww(e):Array.from(e)).map(((e,t)=>bw(e,a[t],n))).join(", ")+"]"]}const l=t.slice(1),u=r.slice(1),d=r[0]*i,h=[];if(s>fw){for(let t=0;t<gw;t++){const r=t*d,o=r+d;h.push(...xw(e.slice(r,o),l,n,u,a,!1))}h.push("...");for(let t=s-gw;t<s;t++){const r=t*d,o=r+d;h.push(...xw(e.slice(r,o),l,n,u,a,t===s-1))}}else for(let g=0;g<s;g++){const t=g*d,r=t+d;h.push(...xw(e.slice(t,r),l,n,u,a,g===s-1))}const p=2===c?",":"";h[0]="["+(s>0?h[0]+p:"");for(let g=1;g<h.length-1;g++)h[g]=" "+h[g]+p;let f=",\n";for(let g=2;g<c;g++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":f),h}function ww(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class kw{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Wm(e),null!=n){const e=n.length;Lm(e===this.size,(()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Ym(t,this.size),this.strides=av(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),Lm(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const a=this.locToIndex(n);this.values[a]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(const o of t){if(o<0||o>=this.shape[r]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}r++}let a=t[t.length-1];for(let o=0;o<t.length-1;++o)a+=this.strides[o]*t[o];return this.values[a]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Sw().makeTensor(this.values,this.shape,this.dtype)}}let Sw=null,Cw=null,Iw=null;class Ew{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Wm(e),this.strides=av(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Cw.buffer(this.shape,this.dtype,e)}bufferSync(){return Cw.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return iv(this.shape,e,"complex64"===this.dtype)}arraySync(){return iv(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=Sw().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>cw(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Sw().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Sw().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>cw(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Sw().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Sw().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Cw.print(this,e)}clone(){return this.throwIfDisposed(),Cw.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return vw(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Cw.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Sw().makeVariable(this,e,t,n)}}function Nw(){return wv("Tensor",(()=>Ew))}Object.defineProperty(Ew,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Nw();class Tw extends Ew{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!Um(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));Sw().disposeTensor(this),this.dataId=e.dataId,Sw().incRef(this,null)}dispose(){Sw().disposeVariable(this),this.isDisposedInternal=!0}}var Rw,Aw,Ow,Fw,_w;Object.defineProperty(Tw,Symbol.hasInstance,{value:e=>e instanceof Ew&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Rw||(Rw={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Aw||(Aw={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Ow||(Ow={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Fw||(Fw={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(_w||(_w={}));const Dw={float32:Fw,int32:Aw,bool:Ow,complex64:_w};function Mw(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return Dw[e][t]}function Pw(e){return Mw(e,"int32")}function Lw(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function zw(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Bw(e,t){if(e.dtype===t.dtype)return[e,t];const n=Mw(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Ww(e,t){return t.some((t=>t.id===e.id))}function Uw(e){const t=[];return Vw(e,t,new Set),t}function Vw(e,t,n){if(null==e)return;if(e instanceof Ew)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!==typeof r)return;var r;const a=e;for(const o in a){const e=a[o];n.has(e)||(n.add(e),Vw(e,t,n))}}function jw(e){return null!=e.kernelName}class Hw{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Gw{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Hw}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(_x("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new dw(this.backendInstance),!0}setupRegisteredKernels(){Bx(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Bx(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof Om||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,_x("Initialization of backend ".concat(e," failed")),_x(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return _x("Initialization of backend ".concat(e," failed")),_x(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return Gw.nextTensorId++}nextVariableId(){return Gw.nextVariableId++}clone(e){const t=Kw.runKernel(Lb,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Kw.runKernel(Gv,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Lx(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-o;if(i>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(i," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;let i,s;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=jw(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(jw(e)){const{kernelName:t,inputs:a,attrs:o}=e;null==this.backendName&&this.backend;const c=Lx(t,this.backendName);Lm(null!=c,(()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'"))),i=()=>{const e=this.backend.numDataIds();s=c.kernelFunc({inputs:a,attrs:o,backend:this.backend});const i=Array.isArray(s)?s:[s];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const l=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,a,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,a=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();s=this.tidy((()=>t(this.backend,a)));const n=Array.isArray(s)?s:[s];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:l,attrs:u}=e,d=jw(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(c,l,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=i()})),r&&this.addTapeNode(c,l,t,d,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(s)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const r=zx(e);if(null!=r){const e=r.inputsToSave||[],a=r.outputsToSave||[];let o;r.saveAllInputs?(Lm(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),o=Object.keys(t).map((e=>t[e]))):o=e.map((e=>t[e]));const i=n.filter(((e,t)=>a[t]));return o.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&Jm(e[0])&&(a=e.map((e=>sw(e))));const o=r.write(a,t,n),i=new Ew(t,n,o,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(o),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:a}=e,o=new Ew(r,a,n,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const a=new Tw(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error("Variable with name ".concat(a.name," was already registered"));return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Zm(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Tw||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Zm(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,o){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},s=zx(e);null!=s&&(r=s.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=cv(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,o))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Uw(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const e=this.state.activeScope.track[a];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Lm(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Lm(a instanceof Ew,(()=>"The result y returned by f() must be a tensor."));const o=function(e,t,n){const r={},a={};for(let c=0;c<t.length;c++)r[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],o=n.inputs;for(const e in o){const i=o[e];let s=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),s=!0,a[n.id]=!0;break}if(s)break}}const o={};o[n.id]=!0;const i={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(o[t.outputs[e].id]){for(const e in n)o[n[e].id]=!0,i[t.id]=!0;break}}const s=[];for(let c=0;c<e.length;c++){const t=e[c];if(a[t.id]&&i[t.id]){const e={};for(const a in t.inputs){const n=t.inputs[a];r[n.id]&&(e[a]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,s.push(n)}}return s}(this.state.activeTape,t,a);if(!r&&0===o.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[a.id]=null==n?function(e){const t=sv(Wm(e),"float32");return Kw.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){const o=t[a],i=[];if(o.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(o.kernelName,"."));const s=o.gradient(i);for(const t in o.inputs){if(!(t in s))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(s),"."));const a=n((()=>s[t]()));if("float32"!==a.dtype)throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(a.dtype,"'"));const i=o.inputs[t];if(!Um(a.shape,i.shape))throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(a.shape,"', which does not match ")+"the shape of the input '".concat(i.shape,"'"));if(null==e[i.id])e[i.id]=a;else{const t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}(e,o,(e=>this.tidy(e)),Xw);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){var t=this;return Lm(nv(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let o;Lm(r.every((e=>e instanceof Ew)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(o=e(...r,n),Lm(o.value instanceof Ew,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Lm(nv(o.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),o.value),backwardsFunc:(e,t)=>{const n=o.gradFunc(e,t),a=Array.isArray(n)?n:[n];Lm(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Lm(a.every((e=>e instanceof Ew)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=iw(),n=await this.backend.time(e);return n.wallMs=iw()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Hw;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function qw(){const e=xv();if(null==e._tfengine){const t=new gv(e);e._tfengine=new Gw(t)}var t;return t=e._tfengine.ENV,yv=t,Sw=()=>e._tfengine,e._tfengine}Gw.nextTensorId=0,Gw.nextVariableId=0;const Kw=qw();function Xw(e,t){const n={a:e,b:t};return Kw.runKernel(Iv,n)}let $w;function Yw(e){if(void 0!==$w)return $w;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Qw(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const Zw=vv();function Jw(e,t){let n=e;if(lw(e))return"string"===t?[]:[e.length];if(Lw(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(zw(e))return[e.buffer.size/(null==t?4:Zm(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||lw(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&vv().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ek(e,r,[]),r}function ek(e,t,n){if(n=n||[],!Array.isArray(e)&&!lw(e))return void Lm(0===t.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements")));Lm(t.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements"))),Lm(e.length===t[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements")));const r=t.slice(1);for(let a=0;a<e.length;++a)ek(e[a],r,n.concat(a))}function tk(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(r,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function nk(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof Nw())return tk(r,e.dtype,t,n),e;let a=tv(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),tk(r,a,t,n),null==e||!lw(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(r,"'"))}const o=Jw(e,a);lw(e)||Array.isArray(e)||(e=[e]);const i="string"!==a?ow(e,a):uw(e,[],!0);return Kw.makeTensor(i,o,a)}function rk(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map(((e,a)=>nk(e,"".concat(t,"[").concat(a,"]"),n,r)))}Zw.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Zw.registerFlag("IS_BROWSER",(()=>Qw())),Zw.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Zw.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Zw.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Zw.registerFlag("PROD",(()=>!1)),Zw.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Zw.getBool("DEBUG"))),Zw.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Zw.registerFlag("IS_TEST",(()=>!1)),Zw.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Zw.getBool("DEBUG"))),Zw.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Zw.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Zw.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function ak(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=function(){Kw.startScope(n);try{const e=r(...arguments);return pv(e)&&console.error("Cannot return a Promise inside of tidy."),Kw.endScope(e),e}catch(e){throw Kw.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const ok=ak({complex_:function(e,t){const n=nk(e,"real","complex"),r=nk(t,"imag","complex");zm(n.shape,r.shape,"real and imag shapes, ".concat(n.shape," and ").concat(r.shape,", ")+"must match in call to tf.complex().");const a={real:n,imag:r};return Kw.runKernel(Xv,a)}});function ik(e,t,n,r){if(null==r)r=tv(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(zw(e)||Lw(e)){if("float32"!==r&&"int32"!==r)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(r,"."));return Kw.backend.createTensorFromGPUData(e,t||n,r)}if(!lw(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){uv(t);const e=Wm(t),r=Wm(n);Lm(e===r,(()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(r)));for(let a=0;a<n.length;++a){const e=n[a],r=a!==n.length-1||e!==Wm(t.slice(a));Lm(n[a]===t[a]||!r,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). ")))}}return lw(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?ow(e,r):uw(e,[],!0),Kw.makeTensor(e,t,r)}function sk(e,t,n){return ik(e,t,Jw(e,n),n)}class ck{static join(e){return new ck(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>lw(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error("Could not find start shard for byte ".concat(e));const r=new ArrayBuffer(t-e),a=new Uint8Array(r);let o=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],r=e+o-n.start,s=o,c=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,r,c-r);if(a.set(l,s),o+=l.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const a=Math.floor((r-n)/2)+n,o=t(e[a]);if(0===o)return a;o<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function lk(){return Kw}function uk(){return Kw.memory()}function dk(e,t){return Kw.tidy(e,t)}function hk(e){Uw(e).forEach((e=>e.dispose()))}function pk(e){return Kw.keep(e)}function fk(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Kw.registerBackend(e,t,n)}function gk(){return Kw.backend}Iw=function(e){vv().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const mk=4;async function vk(e,t){const n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let o=0;o<a.length;++o){const i=a[o],s=Array.isArray(e)?e[o].tensor:e[i];if("float32"!==s.dtype&&"int32"!==s.dtype&&"bool"!==s.dtype&&"string"!==s.dtype&&"complex64"!==s.dtype)throw new Error("Unsupported dtype in weight '".concat(i,"': ").concat(s.dtype));const c={name:i,shape:s.shape,dtype:s.dtype};if("string"===s.dtype){const e=new Promise((async e=>{const t=await s.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+mk*t.length,r=new Uint8Array(n);let a=0;for(let o=0;o<t.length;o++){const e=t[o],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=mk,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(s.data());null!=t&&(c.group=t),n.push(c)}return{data:bk(await Promise.all(r)),specs:n}}function bk(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))}));const r=new Uint8Array(t);let a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}const yk="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function xk(e){return yk?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function wk(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function kk(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),function(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}(e,n,r)}function Sk(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:xk(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:xk(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new ck(e.weightData).byteLength}}function Ck(e){const t=[];for(const n of e)t.push(...n.weights);return t}class Ik{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ik.instance&&(Ik.instance=new Ik),Ik.instance}static registerSaveRouter(e){Ik.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ik.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ik.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ik.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?Ik.getInstance().loadRouters:Ik.getInstance().saveRouters).forEach((t=>{const a=t(e,n);null!==a&&r.push(a)})),r}}const Ek="tensorflowjs",Nk="models_store",Tk="model_info_store";function Rk(){if(!vv().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Ak(e){const t=e.result;t.createObjectStore(Nk,{keyPath:"modelPath"}),t.createObjectStore(Tk,{keyPath:"modelPath"})}class Ok{constructor(e){if(this.indexedDB=Rk(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(Ek,1);r.onupgradeneeded=()=>Ak(r),r.onsuccess=()=>{const a=r.result;if(null==t){const t=a.transaction(Nk,"readonly"),r=t.objectStore(Nk).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=ck.join(t.weightData);const r=Sk(t),i=a.transaction(Tk,"readwrite");let s,c,l=i.objectStore(Tk);try{s=l.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(o){return n(o)}s.onsuccess=()=>{c=a.transaction(Nk,"readwrite");const s=c.objectStore(Nk);let u;try{u=s.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(o){return n(o)}u.onsuccess=()=>e({modelArtifactsInfo:r}),u.onerror=e=>{l=i.objectStore(Tk);const t=l.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(u.error)),t.onerror=e=>(a.close(),n(u.error))}},s.onerror=e=>(a.close(),n(s.error)),i.oncomplete=()=>{null==c?a.close():c.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}}Ok.URL_SCHEME="indexeddb://";const Fk=e=>{return vv().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ok.URL_SCHEME)?(t=e.slice(Ok.URL_SCHEME.length),new Ok(t)):null;var t};Ik.registerSaveRouter(Fk),Ik.registerLoadRouter(Fk);class _k{constructor(){this.indexedDB=Rk()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(Ek,1);n.onupgradeneeded=()=>Ak(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(Tk,"readonly"),o=a.objectStore(Tk).getAll();o.onsuccess=()=>{const t={};for(const e of o.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},o.onerror=e=>(r.close(),t(o.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(Ok.URL_SCHEME)?t.slice(Ok.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(Ek,1);r.onupgradeneeded=()=>Ak(r),r.onsuccess=()=>{const a=r.result,o=a.transaction(Tk,"readwrite"),i=o.objectStore(Tk),s=i.get(e);let c;s.onsuccess=()=>{if(null==s.result)return a.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const r=i.delete(e),o=()=>{c=a.transaction(Nk,"readwrite");const r=c.objectStore(Nk).delete(e);r.onsuccess=()=>t(s.result.modelArtifactsInfo),r.onerror=e=>n(s.error)};r.onsuccess=o,r.onerror=e=>(o(),a.close(),n(s.error))}},s.onerror=e=>(a.close(),n(s.error)),o.oncomplete=()=>{null==c?a.close():c.oncomplete=()=>a.close()}},r.onerror=e=>n(r.error)}))}}const Dk="/",Mk="tensorflowjs_models",Pk="info",Lk="model_topology",zk="weight_specs",Bk="weight_data",Wk="model_metadata";function Uk(e){return{info:[Mk,e,Pk].join(Dk),topology:[Mk,e,Lk].join(Dk),weightSpecs:[Mk,e,zk].join(Dk),weightData:[Mk,e,Bk].join(Dk),modelMetadata:[Mk,e,Wk].join(Dk)}}function Vk(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function jk(e){const t=e.split(Dk);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(Dk)}class Hk{constructor(e){if(!vv().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Uk(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=Sk(e),o=ck.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(yk)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(o));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw Vk(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(a.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(a.weightSpecsBytes,", ")+"weightDataBytes=".concat(a.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(null==o)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if(yk){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(o),t}}Hk.URL_SCHEME="localstorage://";const Gk=e=>{return vv().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Hk.URL_SCHEME)?(t=e.slice(Hk.URL_SCHEME.length),new Hk(t)):null;var t};Ik.registerSaveRouter(Gk),Ik.registerLoadRouter(Gk);class qk{constructor(){Lm(vv().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Lm("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Mk+Dk,n=Dk+Pk;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){e[jk(a)]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){var t;const n=Uk(e=(t=e).startsWith(Hk.URL_SCHEME)?t.slice(Hk.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const r=JSON.parse(this.LS.getItem(n.info));return Vk(n),r}}const Kk="://";class Xk{constructor(){this.managers={}}static getInstance(){return null==Xk.instance&&(Xk.instance=new Xk),Xk.instance}static registerManager(e,t){Lm(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Kk)&&(e=e.slice(0,e.indexOf(Kk))),Lm(e.length>0,(()=>"scheme must not be an empty string."));const n=Xk.getInstance();Lm(null==n.managers[e],(()=>"A model store manager is already registered for scheme '".concat(e,"'."))),n.managers[e]=t}static getManager(e){const t=Xk.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(Xk.getInstance().managers)}}class $k{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&vv().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return jx(e)}}if(vv().get("IS_BROWSER")){vv().setPlatform("browser",new $k);try{Xk.registerManager(Hk.URL_SCHEME,new qk)}catch(g0){}try{Xk.registerManager(Ok.URL_SCHEME,new _k)}catch(g0){}}const Yk=()=>n(817);let Qk;class Zk{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=vv().global.fetch?vv().global.fetch(e,t):(null==Qk&&(Qk=Yk()),Qk(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function Jk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",uv(e),new kw(e,t,n)}vv().get("IS_NODE")&&!vv().get("IS_BROWSER")&&vv().setPlatform("node",new Zk);const eS=ak({cast_:function(e,t){const n=nk(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:t};return Kw.runKernel(Gv,r,a)}});const tS=ak({clone_:function(e){const t={x:nk(e,"x","clone","string_or_numeric")};return Kw.runKernel(Lb,t)}});qw();const nS={buffer:Jk,cast:eS,clone:tS,print:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}};Cw=nS;const rS=ak({add_:function(e,t){let n=nk(e,"a","add"),r=nk(t,"b","add");[n,r]=Bw(n,r);const a={a:n,b:r};return Kw.runKernel(Iv,a)}});const aS=ak({floorDiv_:function(e,t){let n=nk(e,"a","floorDiv"),r=nk(t,"b","floorDiv");[n,r]=Bw(n,r);const a={a:n,b:r};return Kw.runKernel(Ob,a)}});const oS=ak({div_:function(e,t){let n=nk(e,"a","div"),r=nk(t,"b","div");if([n,r]=Bw(n,r),"int32"===n.dtype&&"int32"===r.dtype)return aS(n,r);const a={a:n,b:r};return Kw.runKernel(bb,a,{})}});const iS=ak({mul_:function(e,t){let n=nk(e,"a","mul"),r=nk(t,"b","mul");[n,r]=Bw(n,r);const a={a:n,b:r};return Kw.runKernel(py,a)}});const sS=ak({sqrt_:function(e){const t={x:nk(e,"x","sqrt","float32")};return Kw.runKernel(Jy,t)}});const cS=ak({square_:function(e){const t=nk(e,"x","square");return Kw.runKernel("Square",{x:t},{})}});const lS=ak({zerosLike_:function(e){const t={x:nk(e,"x","zerosLike")};return Kw.runKernel(Ex,t)}});function uS(e){return Kw.customGrad(e)}function dS(e,t){if((lw(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&lw(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ik(e,[],[],t)}const hS=new Map,pS=new Map;class fS{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class gS{constructor(){this.classNameMap={}}static getMap(){return null==gS.instance&&(gS.instance=new gS),gS.instance}static register(e){gS.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function mS(e,t,n){Lm(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Lm("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Lm(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const r=t+">"+n;return gS.register(e),hS.set(r,e),pS.set(e,r),e}class vS extends fS{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return hk(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Lm(nv(e),(()=>"The f passed in variableGrads(f) must be a function")),Lm(null==t||Array.isArray(t)&&t.every((e=>e instanceof Tw)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Kw.registeredVariables)t.push(Kw.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,a=t.length;t=t.filter((e=>e.trainable)),Lm(t.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(a," variables is ")+"trainable."));const{value:o,grads:i}=Kw.gradients(e,t,null,!0);Lm(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Lm(0===o.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(o.rank," tensor")));const s={};return t.forEach(((e,t)=>{null!=i[t]&&(s[e.name]=i[t])})),null!=r&&r.forEach((e=>s[e.name]=null)),{value:o,grads:s}}(e,t)}dispose(){null!=this.iterations_&&hk(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:dS(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(vS,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class bS extends vS{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Kw.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Kw.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:dk((()=>lS(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:dk((()=>lS(r).variable(a)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const i=this.accumulatedGrads[n].variable,s=this.accumulatedUpdates[n].variable;dk((()=>{const e=rS(iS(i,this.rho),iS(cS(o),1-this.rho)),t=iS(oS(sS(rS(s,this.epsilon)),sS(rS(i,this.epsilon))),o),n=rS(iS(s,this.rho),iS(cS(t),1-this.rho));i.assign(e),s.assign(n);const a=rS(iS(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(hk(this.accumulatedGrads.map((e=>e.variable))),hk(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function yS(e,t,n){uv(e);const r={shape:e,value:t,dtype:n=n||tv(t)};return Kw.runKernel(Tb,{},r)}class xS extends vS{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Kw.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:dk((()=>yS(r.shape,this.initialAccumulatorValue).variable(e)))}}const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const o=this.accumulatedGrads[n].variable;dk((()=>{const e=rS(o,cS(a));o.assign(e);const t=rS(iS(oS(a,sS(rS(e,Kw.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&hk(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const wS=ak({pow_:function(e,t){let n=nk(e,"base","pow"),r=nk(t,"exp","pow");[n,r]=Bw(n,r);const a={a:n,b:r};return Kw.runKernel(Sy,a)}});const kS=ak({sub_:function(e,t){let n=nk(e,"a","sub"),r=nk(t,"b","sub");[n,r]=Bw(n,r);const a={a:n,b:r};return Kw.runKernel(mx,a)}});class SS extends vS{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],dk((()=>{this.accBeta1=dS(t).variable(),this.accBeta2=dS(n).variable()})),null==r&&(this.epsilon=Kw.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);dk((()=>{const n=kS(1,this.accBeta1),r=kS(1,this.accBeta2);t.forEach(((t,a)=>{const o=Kw.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(t,"/m"),variable:dk((()=>lS(o).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:"".concat(t,"/v"),variable:dk((()=>lS(o).variable(i)))});const s=Array.isArray(e)?e[a].tensor:e[t];if(null==s)return;const c=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,u=rS(iS(c,this.beta1),iS(s,1-this.beta1)),d=rS(iS(l,this.beta2),iS(cS(s),1-this.beta2)),h=oS(u,n),p=oS(d,r);c.assign(u),l.assign(d);const f=rS(iS(oS(h,rS(sS(p),this.epsilon)),-this.learningRate),o);o.assign(f)})),this.accBeta1.assign(iS(this.accBeta1,this.beta1)),this.accBeta2.assign(iS(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&hk(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&hk(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),dk((()=>{this.accBeta1.assign(wS(this.beta1,this.iterations_+1)),this.accBeta2.assign(wS(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const CS=ak({abs_:function(e){const t=nk(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Kw.runKernel($v,e)}{const e={x:t};return Kw.runKernel(kv,e)}}});function IS(e,t){const n=e.length,r=[];for(let a=0;a<n;a++){const o=n-1-a,i=e[o]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(o)}return r}function ES(e,t){const n=[];for(let r=0;r<t.length;r++){const a=e[e.length-r-1],o=t.length-r-1,i=t[o];(null==a||1===a&&i>1)&&n.unshift(o)}return n}function NS(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let o=e[e.length-a-1];null==o&&(o=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===o)r[n-a-1]=i;else if(1===i)r[n-a-1]=o;else{if(o!==i){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}r[n-a-1]=o}}return r}const TS=ak({maximum_:function(e,t){let n=nk(e,"a","maximum"),r=nk(t,"b","maximum");[n,r]=Bw(n,r),"bool"===n.dtype&&(n=eS(n,"int32"),r=eS(r,"int32")),NS(n.shape,r.shape);const a={a:n,b:r};return Kw.runKernel(ty,a)}});class RS extends vS{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],dk((()=>{this.iteration=dS(0).variable(),this.accBeta1=dS(t).variable()})),null==r&&(this.epsilon=Kw.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);dk((()=>{const n=kS(1,this.accBeta1),r=oS(-this.learningRate,rS(iS(this.iteration,this.decay),1));t.forEach(((t,a)=>{const o=Kw.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(t,"/m"),variable:lS(o).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:"".concat(t,"/v"),variable:lS(o).variable(i)});const s=Array.isArray(e)?e[a].tensor:e[t];if(null==s)return;const c=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,u=rS(iS(c,this.beta1),iS(s,1-this.beta1)),d=iS(l,this.beta2),h=CS(s),p=TS(d,h);c.assign(u),l.assign(p);const f=rS(iS(oS(r,n),oS(u,rS(p,this.epsilon))),o);o.assign(f)})),this.iteration.assign(rS(this.iteration,1)),this.accBeta1.assign(iS(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&hk(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&hk(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class AS extends vS{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=Kw.registeredVariables[t];dk((()=>{const e=rS(iS(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=pk(dS(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class OS extends AS{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=dS(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Kw.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:dk((()=>lS(r).variable(e)))}}const a=this.accumulations[n].variable,o=Array.isArray(e)?e[n].tensor:e[t];null!=o&&dk((()=>{let e;const t=rS(iS(this.m,a),o);e=this.useNesterov?rS(iS(this.c,rS(o,iS(t,this.m))),r):rS(iS(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&hk(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class FS extends vS{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Kw.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Kw.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:dk((()=>lS(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:dk((()=>lS(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:dk((()=>lS(r).variable(a)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const i=this.accumulatedMeanSquares[n].variable,s=this.accumulatedMoments[n].variable;dk((()=>{const e=rS(iS(i,this.decay),iS(cS(o),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,a=rS(iS(t,this.decay),iS(o,1-this.decay)),c=oS(iS(o,this.learningRate),sS(kS(e,rS(cS(a),this.epsilon)))),l=rS(iS(s,this.momentum),c);i.assign(e),t.assign(a),s.assign(l);const u=kS(r,l);r.assign(u)}else{const e=rS(iS(i,this.decay),iS(cS(o),1-this.decay)),t=rS(iS(s,this.momentum),oS(iS(o,this.learningRate),sS(rS(e,this.epsilon))));i.assign(e),s.assign(t);const n=kS(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&hk(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&hk(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&hk(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const _S=[bS,xS,SS,RS,OS,FS,AS];function DS(e){return new Promise((e=>setTimeout(e))).then(e)}class MS{constructor(e){if(!vv().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(MS.URL_SCHEME)&&(e=e.slice(MS.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=ck.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=wk(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await DS((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await DS((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Sk(e)}}}}MS.URL_SCHEME="downloads://";function PS(e,t,n,r){!function(e){Lm(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Lm(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e))),Lm(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t))),Lm(t>=e,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t)))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(e.map((o=>(o.then((o=>{const i=n+ ++a/e.length*(r-n);return t(i),o})),o))))}async function LS(e,t){null==t&&(t={});const n=null==t.fetchFunc?vv().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await PS(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await PS(a,t.onProgress,.5,1)}Ik.registerSaveRouter((e=>vv().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(MS.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new MS(e)}(e.slice(MS.URL_SCHEME.length)):null));class zS{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Lm("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=vv().platform.fetch,Lm(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Lm(2===e.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,")."))),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=wk(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=ck.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Sk(e),responses:[r]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(r.status,"."))}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(f0){let t="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return kk(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=Ck(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?vv().platform.fetch:t.fetchFunc;let a,o=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;o<e.length;){if(!a){const n=(await r(e[o],t.requestInit,{isBinary:!0})).body;a=n.getReader()}const{done:s,value:c}=await a.read();if(!s)return void n.enqueue(c);o++,a=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,o/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,o=[],i=[];for(const s of e)for(const e of s.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):o.push(a+e+r);return this.weightUrlConverter&&o.push(...await Promise.all(i)),o}async loadWeights(e){const t=await this.getWeightUrls(e);return[Ck(e),await LS(t,this.loadOptions)]}}function BS(e){return null!=e.match(zS.URL_SCHEME_REGEX)}zS.URL_SCHEME_REGEX=/^https?:\/\//;const WS=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>BS(e))):BS(e),n)return US(e,t)}return null};function US(e,t){return new zS(e,t)}Ik.registerSaveRouter(WS),Ik.registerLoadRouter(WS);const VS=-2,jS=-1;function HS(e,t,n){const r=e.shape.length;Lm(r===t.length,(()=>"Error in slice".concat(r,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(r,")."))),Lm(r===n.length,(()=>"Error in slice".concat(r,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(r,").")));for(let a=0;a<r;++a)Lm(t[a]+n[a]<=e.shape[a],(()=>"Error in slice".concat(r,"D: begin[").concat(a,"] + size[").concat(a,"] ")+"(".concat(t[a]+n[a],") would overflow input.shape[").concat(a,"] (").concat(e.shape[a],")")))}function GS(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function qS(e,t,n){const r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function KS(e,t,n,r){const a=[...e];for(let o=a.length;o<r.length;o++)a.push(1);for(let o=0;o<n;o++)0===o?a[t]=1:(a.splice(t,0,1),a.pop());return a}function XS(e,t,n){return n<=e?n:n-(t-1)}function $S(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function YS(e,t,n,r,a,o,i,s,c){const l=e.length;let u=new Array(l),d=new Array(l),h=new Array(l);if(t.length&&n>0){const c=t[0],l=n+1;u=QS(i,c,l,r,e),d=ZS(s,c,l,a,e),h=KS(o,c,l,e)}else for(let p=0;p<l;p++)u[p]=eC(i,r,o,e,p,c),d[p]=tC(s,a,o,e,p,c),h[p]=JS(o,p,c);return{begin:u,end:d,strides:h}}function QS(e,t,n,r,a){const o=[...a],i=$S(n,t);for(let s=0;s<o.length;s++)if(i.indexOf(s)>-1)o[s]=0;else{const a=XS(t,n,s);let i=r[a];e&1<<a&&(i=0),o[s]=i}return o}function ZS(e,t,n,r,a){const o=[...a],i=$S(n,t);for(let s=0;s<o.length;s++)if(i.indexOf(s)>-1)o[s]=Number.MAX_SAFE_INTEGER;else{const a=XS(t,n,s);let i=r[a];e&1<<a&&(i=Number.MAX_SAFE_INTEGER),o[s]=i}for(let s=0;s<o.length;s++){const e=a[s];o[s]<0&&(o[s]+=e),o[s]=Dm(0,o[s],a[s])}return o}function JS(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function eC(e,t,n,r,a,o){let i=t[a];const s=n[a]||1;(e&1<<a||o&1<<a||null==i)&&(i=s>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=r[a];return i<0&&(i+=c),i=Dm(0,i,c-1),i}function tC(e,t,n,r,a,o){let i=t[a];const s=n[a]||1;(e&1<<a||o&1<<a||null==i)&&(i=s>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=r[a];return i<0&&(i+=c),i=s>0?Dm(0,i,c):Dm(-1,i,c-1),i}function nC(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function rC(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function aC(e,t,n){let r;const a=e.shape.length;let o;return r="number"===typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),r.forEach((e=>{Lm(-1!==e,(()=>"slice() does not support negative begin indexing."))})),o=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,o=o.map(((t,n)=>t>=0?t:(Lm(-1===t,(()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,"."))),e.shape[n]-r[n]))),[r,o]}function oC(e,t,n,r,a,o,i,s,c){let l;if(null==r?(l=new Array(t.length),l.fill(1)):l=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:a,endMask:o,ellipsisMask:i,newAxisMask:s,shrinkAxisMask:c};for(let b=0;b<d.dims;b++)u&&0!==(1<<b&s)&&d.numAddAxisAfterEllipsis++,1<<b&i&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(VS),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(jS),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,g=!0;const m=[],v=[];for(let b=0;b<e.length;++b){if(0===h.strides[b])throw Error("strides[".concat(b,"] must be non-zero"));const t=!!(h.shrinkAxisMask&1<<b),n=e[b];if(-1===n){m.push(t?1:-1);continue}const r=[h.beginMask&1<<b,h.endMask&1<<b],a=[h.strides[b]>0?0:-1,h.strides[b]>0?n:n-1];if(t&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===h.strides[b];const o=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(t){const e=h.begin[b]<0?n+h.begin[b]:h.begin[b];if(h.begin[b]=e,h.end[b]=h.begin[b]+1,e<0||e>=n)throw Error("slice index ".concat(h.begin[b]," of dimension ").concat(b," out of bounds."))}else h.begin[b]=iC(h.begin[b],0,h.strides[b],n,r,a),h.end[b]=iC(h.end[b],1,h.strides[b],n,r,a);const e=1===h.strides[b]&&0===h.begin[b]&&h.end[b]===n;p=p&&e,f=f&&(0===b&&1===h.strides[b]||e)}else p=p&&1===h.strides[b]&&o,f=f&&(0===b&&1===h.strides[b]||o);let i,s=!1;if(h.beginValid&&h.endValid?(i=h.end[b]-h.begin[b],s=!0):t?(i=1,s=!0):o&&n>=0&&(i=h.strides[b]<0?-n:n,s=!0),s){let e;e=0===i||i<0!==h.strides[b]<0?0:Math.trunc(i/h.strides[b])+(i%h.strides[b]!==0?1:0),m.push(e)}else m.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){const e=h.finalShapeGatherIndices[b];e>=0?v.push(m[e]):e===VS&&v.push(1)}return{finalShapeSparse:v.filter(((e,t)=>h.finalShapeGatherIndices[t]!==VS)),finalShape:v,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:h.begin,end:h.end,strides:h.strides}}function iC(e,t,n,r,a,o){if(a[t])return n>0?o[t]:o[t+1&1];{const t=e<0?r+e:e;return t<o[0]?o[0]:t>o[1]?o[1]:t}}const sC=ak({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:nk(e,"x","all","bool")},a={axis:t,keepDims:n};return Kw.runKernel(Nv,r,a)}});const cC=ak({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:nk(e,"x","any","bool")},a={axis:t,keepDims:n};return Kw.runKernel(Tv,r,a)}});const lC=ak({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:nk(e,"x","argMax")},r={axis:t};return Kw.runKernel(Rv,n,r)}});function uC(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5?arguments[5]:void 0;return pC(e,[...t,e[3]],n,o,r,null,null,SC(a))}function dC(e,t,n,r,a,o){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[s,c]=mC(t);let l;if("channelsLast"===i)l=[s,c,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));l=[s,c,e[1],e[1]]}return pC(e,l,n,r,a,o,!1,i)}function hC(e,t,n,r,a,o){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[s,c,l]=vC(t);let u,d;if("NDHWC"===i)d="channelsLast",u=[s,c,l,e[4],e[4]];else{if("NCDHW"!==i)throw new Error("Unknown dataFormat ".concat(i));d="channelsFirst",u=[s,c,l,e[1],e[1]]}return fC(e,u,n,r,a,!1,d,o)}function pC(e,t,n,r,a,o){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,u,d]=[-1,-1,-1,-1];if("channelsLast"===s)[c,l,u,d]=e;else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));[c,d,l,u]=e}const[h,p,,f]=t,[g,m]=mC(n),[v,b]=mC(r),y=bC(h,v),x=bC(p,b),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,r,a,o,i,s,c){let l,u,d;if("number"===typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,r,a){null==r&&(r=gC(e,t,n));const o=e[0],i=e[1],s=yC((o-t+2*r)/n+1,a),c=yC((i-t+2*r)/n+1,a);return[s,c]}([t,n],o,r,e,s);u=a[0],d=a[1]}else if("same"===e){u=Math.ceil(t/r),d=Math.ceil(n/a);const e=Math.max(0,(u-1)*r+o-t),s=Math.max(0,(d-1)*a+i-n),c=Math.floor(e/2),h=e-c,p=Math.floor(s/2);l={top:c,bottom:h,left:p,right:s-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-o+1)/r),d=Math.ceil((n-i+1)/a);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const h="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],g="channelsLast"===c?e[2][1]:e[3][1];l={top:h,bottom:p,left:f,right:g,type:0===h&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},u=yC((t-o+h+p)/r+1,s),d=yC((n-i+f+g)/a+1,s)}}return{padInfo:l,outHeight:u,outWidth:d}}(a,l,u,g,m,y,x,o,s),C=i?f*d:f;let I;return"channelsFirst"===s?I=[c,C,k,S]:"channelsLast"===s&&(I=[c,k,S,C]),{batchSize:c,dataFormat:s,inHeight:l,inWidth:u,inChannels:d,outHeight:k,outWidth:S,outChannels:C,padInfo:w,strideHeight:g,strideWidth:m,filterHeight:h,filterWidth:p,effectiveFilterHeight:y,effectiveFilterWidth:x,dilationHeight:v,dilationWidth:b,inShape:e,outShape:I,filterShape:t}}function fC(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",s=arguments.length>7?arguments[7]:void 0,[c,l,u,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,d,h]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,h,l,u,d]=e}const[p,f,g,,m]=t,[v,b,y]=vC(n),[x,w,k]=vC(r),S=bC(p,x),C=bC(f,w),I=bC(g,k),{padInfo:E,outDepth:N,outHeight:T,outWidth:R}=function(e,t,n,r,a,o,i,s,c,l,u){let d,h,p,f;"valid"===e&&(e=0);if("number"===typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const g=function(e,t,n,r,a,o){null==a&&(a=gC(e,t[0],r[0]));const i=[0,0,0,n];for(let s=0;s<3;s++)e[s]+2*a>=t[s]&&(i[s]=yC((e[s]-t[s]+2*a)/r[s]+1,o));return i}([t,n,r,1],[s,c,l],1,[a,o,i],e,u);h=g[0],p=g[1],f=g[2]}else{if("same"!==e)throw Error("Unknown padding parameter: ".concat(e));{h=Math.ceil(t/a),p=Math.ceil(n/o),f=Math.ceil(r/i);const e=(h-1)*a+s-t,u=(p-1)*o+c-n,g=(f-1)*i+l-r,m=Math.floor(e/2),v=e-m,b=Math.floor(u/2),y=u-b,x=Math.floor(g/2);d={top:b,bottom:y,left:x,right:g-x,front:m,back:v,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(a,l,u,d,v,b,y,S,C,I,s),A=o?m*h:m;let O;return"channelsFirst"===i?O=[c,A,N,T,R]:"channelsLast"===i&&(O=[c,N,T,R,A]),{batchSize:c,dataFormat:i,inDepth:l,inHeight:u,inWidth:d,inChannels:h,outDepth:N,outHeight:T,outWidth:R,outChannels:A,padInfo:E,strideDepth:v,strideHeight:b,strideWidth:y,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:C,effectiveFilterWidth:I,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:O,filterShape:t}}function gC(e,t,n){const r=bC(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function mC(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function vC(e){return"number"===typeof e?[e,e,e]:e}function bC(e,t){return t<=1?e:e+(e-1)*(t-1)}function yC(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function xC(e){const[t,n,r]=mC(e);return 1===t&&1===n&&1===r}function wC(e,t){return xC(e)||xC(t)}function kC(e){return mC(e).every((e=>e>0))}function SC(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function CC(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)Lm(Vm(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach((t=>{t.forEach((t=>{Lm(Vm(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")))}))}))}}}const IC=ak({reshape_:function(e,t){const n={x:nk(e,"x","reshape","string_or_numeric")},r={shape:t};return Kw.runKernel(_y,n,r)}});const EC=ak({avgPool_:function(e,t,n,r,a){const o=nk(e,"x","avgPool","float32");Lm(wC(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let i=o,s=!1;3===o.rank&&(s=!0,i=IC(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Lm(4===i.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(i.rank,"."))),CC("avgPool",r,a);const c={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:a};let u=Kw.runKernel(Pv,c,l);return u=eS(u,o.dtype),s?IC(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const NC=ak({avgPool3d_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=nk(e,"x","avgPool3d","float32");let s=i,c=!1;4===i.rank&&(c=!0,s=IC(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Lm(5===s.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(s.rank,"."))),Lm("NDHWC"===o,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),Lm("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'"))),CC("avgPool3d",r,a);const l={x:s},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:o};let d=Kw.runKernel(zv,l,u);return d=eS(d,s.dtype),c?IC(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const TC=ak({batchNorm_:function(e,t,n,r,a,o){null==o&&(o=.001);const i=nk(e,"x","batchNorm"),s=nk(t,"mean","batchNorm"),c=nk(n,"variance","batchNorm");let l,u;null!=a&&(l=nk(a,"scale","batchNorm")),null!=r&&(u=nk(r,"offset","batchNorm")),Lm(s.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Lm(null==u||s.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Lm(null==l||s.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d=function(e){let t;return t=0===e.rank||1===e.rank?IC(e,[1,1,1,e.size]):2===e.rank?IC(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?IC(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),h={x:d,scale:l,offset:u,mean:s,variance:c},p={varianceEpsilon:o},f=Kw.runKernel(Fb,h,p);return IC(f,i.shape)}});const RC=ak({batchNorm2d_:function(e,t,n,r,a,o){const i=nk(e,"x","batchNorm"),s=nk(t,"mean","batchNorm"),c=nk(n,"variance","batchNorm");let l,u;return null!=a&&(l=nk(a,"scale","batchNorm")),null!=r&&(u=nk(r,"offset","batchNorm")),Lm(2===i.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(i.rank,"."))),Lm(2===s.rank||1===s.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(s.rank,"."))),Lm(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Lm(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&Lm(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),TC(i,s,c,u,l,o)}});const AC=ak({batchNorm3d_:function(e,t,n,r,a,o){const i=nk(e,"x","batchNorm"),s=nk(t,"mean","batchNorm"),c=nk(n,"variance","batchNorm");let l,u;return null!=a&&(l=nk(a,"scale","batchNorm")),null!=r&&(u=nk(r,"offset","batchNorm")),Lm(3===i.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(i.rank,"."))),Lm(3===s.rank||1===s.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(s.rank,"."))),Lm(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Lm(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&Lm(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),TC(i,s,c,u,l,o)}});const OC=ak({batchNorm4d_:function(e,t,n,r,a,o){const i=nk(e,"x","batchNorm"),s=nk(t,"mean","batchNorm"),c=nk(n,"variance","batchNorm");let l,u;return null!=a&&(l=nk(a,"scale","batchNorm")),null!=r&&(u=nk(r,"offset","batchNorm")),Lm(4===i.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(i.rank,"."))),Lm(4===s.rank||1===s.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(s.rank,"."))),Lm(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Lm(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&Lm(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),TC(i,s,c,u,l,o)}});const FC=ak({broadcastTo_:function(e,t){let n=nk(e,"broadcastTo","x");const r=n.shape;if(uv(t),t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=IC(n,e)}const a=n.shape,o=Array.from(t);for(let c=t.length-1;c>=0;c--)if(a[c]===t[c])o[c]=1;else if(1!==n.shape[c])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(t,"]."));if(0===o.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return tS(n);const i={x:n},s={reps:o};return Kw.runKernel(yx,i,s)}});const _C=ak({clipByValue_:function(e,t,n){const r=nk(e,"x","clipByValue");if(Lm(t<=n,(()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,")."))),t===n)return yS(r.shape,t,r.dtype);const a={x:r},o={clipValueMin:t,clipValueMax:n};return Kw.runKernel(Kv,a,o)}});const DC=ak({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Lm(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=rk(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))})),1===n.length)return tS(n[0]);const r=n,a={axis:t};return Kw.runKernel(Yv,r,a)}});const MC=ak({concat1d_:function(e){return DC(e,0)}});const PC=ak({concat2d_:function(e,t){return DC(e,t)}});const LC=ak({concat3d_:function(e,t){return DC(e,t)}});const zC=ak({concat4d_:function(e,t){return DC(e,t)}});const BC=ak({conv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const s=nk(e,"x","conv2d","float32"),c=nk(t,"filter","conv2d","float32");let l=s,u=!1;3===s.rank&&(u=!0,l=IC(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Lm(4===l.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(l.rank,"."))),Lm(4===c.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(c.rank,"."))),CC("conv2d",r,i);const d="NHWC"===a?l.shape[3]:l.shape[1];Lm(d===c.shape[2],(()=>"Error in conv2d: depth of input (".concat(d,") must match ")+"input depth for filter ".concat(c.shape[2],"."))),Lm(wC(n,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),Lm(kC(o),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Lm(kC(n),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:l,filter:c},p={strides:n,pad:r,dataFormat:a,dilations:o,dimRoundingMode:i},f=Kw.runKernel(Qv,h,p);return u?IC(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const WC=ak({conv1d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0;const s=nk(e,"x","conv1d"),c=nk(t,"filter","conv1d");let l=s,u=!1;2===s.rank&&(u=!0,l=IC(s,[1,s.shape[0],s.shape[1]])),Lm(3===l.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(l.rank,"."))),Lm(3===c.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(c.rank,"."))),CC("conv1d",r,i),Lm(l.shape[2]===c.shape[1],(()=>"Error in conv1d: depth of input (".concat(l.shape[2],") must match ")+"input depth for filter ".concat(c.shape[1],"."))),Lm(wC(n,o),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(o,"'"))),Lm(kC(o),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Lm(kC(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Lm("NWC"===a,(()=>"Error in conv1d: got dataFormat of ".concat(a," but only NWC is currently supported.")));const d=IC(c,[1,c.shape[0],c.shape[1],c.shape[2]]),h=IC(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=BC(h,d,[1,n],r,"NHWC",[1,o],i);return IC(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const UC=ak({conv2DBackpropInput_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;Lm(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let s=e,c=t,l=!1;3===t.rank&&(l=!0,c=IC(t,[1,t.shape[0],t.shape[1],t.shape[2]]),s=[1,e[0],e[1],e[2]]),Lm(4===s.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(s.length,"."))),Lm(4===c.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(c.rank))),Lm(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===o?s[3]:s[1],d="NHWC"===o?c.shape[3]:c.shape[1];Lm(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),Lm(d===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(d,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),CC("conv2dDerInput",a,i);const h={dy:c,filter:n},p={strides:r,pad:a,dataFormat:o,dimRoundingMode:i,inputShape:s},f=Kw.runKernel(Jv,h,p);return l?IC(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const VC=ak({conv2dTranspose_:function(e,t,n,r,a,o){const i=nk(e,"x","conv2dTranspose"),s=nk(t,"filter","conv2dTranspose");return UC(n,i,s,r,a,"NHWC",o)}});const jC=ak({conv3d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=nk(e,"x","conv3d"),s=nk(t,"filter","conv3d");let c=i,l=!1;4===i.rank&&(l=!0,c=IC(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Lm(5===c.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(c.rank,"."))),Lm(5===s.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(s.rank,"."))),Lm(c.shape[4]===s.shape[3],(()=>"Error in conv3d: depth of input (".concat(c.shape[4],") must match ")+"input depth for filter ".concat(s.shape[3],"."))),Lm(wC(n,o),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),Lm("NDHWC"===a,(()=>"Error in conv3d: got dataFormat of ".concat(a," but only NDHWC is currently supported."))),Lm(kC(o),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Lm(kC(n),(()=>"Error in conv3D: Strides should be larger than 0."));const u={x:c,filter:s},d={strides:n,pad:r,dataFormat:a,dilations:o},h=Kw.runKernel(eb,u,d);return l?IC(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const HC=ak({conv3DBackpropInput_:function(e,t,n,r,a){Lm(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let o=e,i=t,s=!1;4===t.rank&&(s=!0,i=IC(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,e[0],e[1],e[2],e[3]]);const c=o[4],l=i.shape[4];Lm(5===o.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(o.length,"."))),Lm(5===i.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(i.rank))),Lm(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),Lm(c===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(c,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),Lm(l===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(l,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:i,filter:n},d={pad:a,strides:r,inputShape:o},h=Kw.runKernel(nb,u,d);return s?IC(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const GC=ak({conv3dTranspose_:function(e,t,n,r,a){const o=nk(e,"x","conv3dTranspose"),i=nk(t,"filter","conv3dTranspose");return HC(n,o,i,r,a)}});const qC=ak({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=nk(e,"x","denseBincount"),o=nk(t,"weights","denseBincount");Lm("int32"===a.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(a.dtype))),Lm(a.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(a.rank,"."))),Lm(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Lm(o.size===a.size||0===o.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(a.shape,", weights shape: ")+"".concat(o.shape,".")));const i={x:a,weights:o},s={size:n,binaryOutput:r};return Kw.runKernel(cb,i,s)}});const KC=ak({depthwiseConv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const s=nk(e,"x","depthwiseConv2d","float32"),c=nk(t,"filter","depthwiseConv2d","float32");let l=s,u=!1;3===s.rank&&(u=!0,l=IC(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Lm(4===l.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(l.rank,"."))),Lm(4===c.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(c.rank,".")));const d="NHWC"===a?l.shape[3]:l.shape[1];Lm(d===c.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(d,") must match the inChannels dimension in ")+"filter ".concat(c.shape[2],"."))),CC("depthwiseConv2d",r,i);const h={x:l,filter:c},p={strides:n,pad:r,dataFormat:a,dilations:o,dimRoundingMode:i},f=Kw.runKernel(ub,h,p);return u?IC(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const XC=ak({elu_:function(e){const t={x:nk(e,"x","elu","float32")};return Kw.runKernel(xb,t)}});const $C=ak({equal_:function(e,t){let n=nk(e,"a","equal","string_or_numeric"),r=nk(t,"b","equal","string_or_numeric");[n,r]=Bw(n,r),NS(n.shape,r.shape);const a={a:n,b:r};return Kw.runKernel(Sb,a)}});const YC=ak({erf_:function(e){let t=nk(e,"x","erf");Lm("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=eS(t,"float32"));const n={x:t};return Kw.runKernel(kb,n)}});const QC=ak({exp_:function(e){const t={x:nk(e,"x","exp")};return Kw.runKernel(Cb,t)}});const ZC=ak({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=nk(e,"x","expandDims","string_or_numeric");Lm(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:t};return Kw.runKernel(Ib,r,a)}});const JC=ak({tile_:function(e,t){const n=nk(e,"x","tile","string_or_numeric");Lm(n.rank===t.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,".")));const r={x:n},a={reps:t};return Kw.runKernel(yx,r,a)}});const eI=ak({eye_:function(e,t,n){null==t&&(t=e);const r=Jk([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=e<=t?e:t;for(let i=0;i<a;++i)r.set(1,i,i);const o=IC(r.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return JC(ZC(o,0),[n[0],1,1]);if(2===n.length)return JC(ZC(ZC(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return JC(ZC(ZC(ZC(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const tI=ak({floor_:function(e){const t={x:nk(e,"x","floor","float32")};return Kw.runKernel(Ab,t)}});const nI=ak({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a={x:nk(e,"x","gather"),indices:nk(t,"indices","gather","int32")},o={axis:n,batchDims:r};return Kw.runKernel(_b,a,o)}});const rI=ak({greater_:function(e,t){let n=nk(e,"a","greater","string_or_numeric"),r=nk(t,"b","greater","string_or_numeric");[n,r]=Bw(n,r),NS(n.shape,r.shape);const a={a:n,b:r};return Kw.runKernel(Mb,a)}});const aI=ak({greaterEqual_:function(e,t){let n=nk(e,"a","greaterEqual","string_or_numeric"),r=nk(t,"b","greaterEqual","string_or_numeric");[n,r]=Bw(n,r),NS(n.shape,r.shape);const a={a:n,b:r};return Kw.runKernel(Pb,a)}});const oI=ak({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:nk(e,"x","leakyRelu")},r={alpha:t};return Kw.runKernel(jb,n,r)}});const iI=ak({log_:function(e){const t={x:nk(e,"x","log","float32")};return Kw.runKernel(Kb,t)}});const sI=ak({log1p_:function(e){const t={x:nk(e,"x","log1p")};return Kw.runKernel(Xb,t)}});const cI=ak({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:nk(e,"x","max")},a={reductionIndices:t,keepDims:n};return Kw.runKernel(ey,r,a)}});const lI=ak({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=nk(e,"x","sum");"bool"===r.dtype&&(r=eS(r,"int32"));const a={x:r},o={axis:t,keepDims:n};return Kw.runKernel(ex,a,o)}});const uI=ak({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=nk(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const r=uS(((e,n)=>{const r=cI(e,t,!0),a=kS(e,r),o=kS(eS(a,"float32"),iI(lI(QC(a),t,!0)));n([o]);return{value:o,gradFunc:(e,n)=>{const[r]=n,a=QC(r);return kS(e,iS(lI(e,t,!0),a))}}}));return r(n)}});function dI(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function hI(e,t,n){const r=e.length+t.length,a=[];let o=0,i=0;for(let s=0;s<r;s++)-1===n.indexOf(s)?a.push(e[o++]):a.push(t[i++]);return a}function pI(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function fI(e,t){return hI(e,t.map((e=>1)),t)}function gI(e,t,n){Lm(dI(t,n),(()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input.")))}function mI(e,t){if(dI(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function vI(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function bI(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const yI=ak({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=nk(e,"x","logSumExp"),a=Km(t,r.shape),o=cI(r,a,!0),i=kS(r,o),s=QC(i),c=lI(s,a),l=iI(c),u=rS(IC(o,l.shape),l);if(n){const e=fI(u.shape,a);return IC(u,e)}return u}});const xI=ak({logicalAnd_:function(e,t){const n=nk(e,"a","logicalAnd","bool"),r=nk(t,"b","logicalAnd","bool");NS(n.shape,r.shape);const a={a:n,b:r};return Kw.runKernel($b,a)}});const wI=ak({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=nk(e,"a","matMul"),o=nk(t,"b","matMul");[a,o]=Bw(a,o);const i={a:a,b:o},s={transposeA:n,transposeB:r};return Kw.runKernel(Wv,i,s)}});const kI=ak({maxPool_:function(e,t,n,r,a){const o=nk(e,"x","maxPool");let i=o,s=!1;3===o.rank&&(s=!0,i=IC(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Lm(4===i.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(i.rank,"."))),Lm(wC(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),CC("maxPool",r,a);const c={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:a},u=Kw.runKernel(ny,c,l);return s?IC(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const SI=ak({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=nk(e,"x","maxPool3d");let s=i,c=!1;4===i.rank&&(c=!0,s=IC(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Lm(5===s.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(s.rank,"."))),Lm("NDHWC"===o,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),CC("maxPool3d",r,a);const l={x:s},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:o},d=Kw.runKernel(ay,l,u);return c?IC(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const CI=ak({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:nk(e,"x","mean")},a={axis:t,keepDims:n};return Kw.runKernel(sy,r,a)}});const II=ak({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:nk(e,"x","min")},a={axis:t,keepDims:n};return Kw.runKernel(cy,r,a)}});const EI=ak({minimum_:function(e,t){let n=nk(e,"a","minimum"),r=nk(t,"b","minimum");[n,r]=Bw(n,r),"bool"===n.dtype&&(n=eS(n,"int32"),r=eS(r,"int32")),NS(n.shape,r.shape);const a={a:n,b:r};return Kw.runKernel(ly,a)}});const NI=ak({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Km(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=nk(e,"x","moments")).shape),r=CI(e,n,t);let a=r.shape;t||(a=fI(r.shape,n));const o=cS(kS(eS(e,"float32"),IC(r,a)));return{mean:r,variance:CI(o,n,t)}}});const TI=ak({neg_:function(e){const t={x:nk(e,"x","neg")};return Kw.runKernel(fy,t)}});const RI=ak({notEqual_:function(e,t){let n=nk(e,"a","notEqual","string_or_numeric"),r=nk(t,"b","notEqual","string_or_numeric");[n,r]=Bw(n,r),NS(n.shape,r.shape);const a={a:n,b:r};return Kw.runKernel(gy,a)}});const AI=ak({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const o={indices:nk(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return Kw.runKernel(xy,o,i)}});function OI(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(uv(e),"complex64"===t){const t=OI(e,"float32"),n=OI(e,"float32");return ok(t,n)}const n=cv(Wm(e),t);return Kw.makeTensor(n,e,t)}function FI(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(uv(e),"complex64"===t){const t=FI(e,"float32"),n=OI(e,"float32");return ok(t,n)}const n=sv(Wm(e),t);return Kw.makeTensor(n,e,t)}const _I=ak({onesLike_:function(e){const t={x:nk(e,"x","onesLike")};return Kw.runKernel(yy,t)}});const DI=ak({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=nk(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:t,constantValue:n},o={x:r};return Kw.runKernel(ky,o,a)}});const MI=ak({prelu_:function(e,t){const n={x:nk(e,"x","prelu"),alpha:nk(t,"alpha","prelu")};return Kw.runKernel(Cy,n)}});var PI=n(334);class LI{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=a||Math.random();this.random=PI.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,o;do{r=2*this.random()-1,a=2*this.random()-1,o=r*r+a*a}while(o>=1||0===o);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class zI{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=PI.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const BI=ak({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(uv(e),null!=r&&"bool"===r)throw new Error("Unsupported data type ".concat(r));const o=new LI(t,n,r,!1,a),i=Jk(e,r);for(let s=0;s<i.values.length;s++)i.values[s]=o.nextValue();return i.toTensor()}});const WI=ak({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;uv(e);const o=Jk(e,r),i=new zI(t,n,null,a);for(let s=0;s<o.values.length;s++)o.values[s]=i.nextValue();return o.toTensor()}});function UI(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:e,stop:t,step:n,dtype:r};return Kw.runKernel(Ry,{},a)}const VI=ak({relu_:function(e){const t={x:nk(e,"x","relu")};return Kw.runKernel(Fy,t)}});const jI=ak({reverse_:function(e,t){const n={x:nk(e,"x","reverse")},r={dims:t};return Kw.runKernel(By,n,r)}});const HI=ak({selu_:function(e){const t={x:nk(e,"x","selu")};return Kw.runKernel(qy,t)}});const GI=ak({separableConv2d_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const s=nk(e,"x","separableConv2d"),c=nk(t,"depthwiseFilter","separableConv2d"),l=nk(n,"pointwiseFilter","separableConv2d");let u=s,d=!1;if(3===s.rank&&(d=!0,u=IC(s,[1,s.shape[0],s.shape[1],s.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Lm(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),Lm(4===c.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),Lm(4===l.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),Lm(1===l.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(l.shape[0],"."))),Lm(1===l.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(l.shape[1],".")));const h=c.shape[2],p=c.shape[3];Lm(l.shape[2]===h*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(h*p,", ")+"but got ".concat(l.shape[2],".")));const f=KC(u,c,r,a,i,o),g=BC(f,l,1,"valid",i);return d?IC(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});const qI=ak({sigmoid_:function(e){const t={x:nk(e,"x","sigmoid","float32")};return Kw.runKernel(Qy,t)}});const KI=ak({slice_:function(e,t,n){const r=nk(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},o={begin:t,size:n};return Kw.runKernel(Ky,a,o)}});const XI=ak({slice1d_:function(e,t,n){const r=nk(e,"x","slice1d");return Lm(1===r.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(r.rank," tensor"))),KI(r,[t],[n])}});const $I=ak({slice2d_:function(e,t,n){const r=nk(e,"x","slice2d");return Lm(2===r.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(r.rank," tensor"))),KI(r,t,n)}});const YI=ak({slice3d_:function(e,t,n){const r=nk(e,"x","slice3d");return Lm(3===r.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(r.rank," tensor"))),KI(r,t,n)}});const QI=ak({slice4d_:function(e,t,n){const r=nk(e,"x","slice4d");return Lm(4===r.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(r.rank," tensor"))),KI(r,t,n)}});const ZI=ak({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=nk(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const r={logits:n},a={dim:t};return Kw.runKernel(rx,r,a)}});const JI=ak({softplus_:function(e){const t={x:nk(e,"x","softplus")};return Kw.runKernel(Zy,t)}});const eE=ak({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:nk(e,"x","split")},a={numOrSizeSplits:t,axis:n};return Kw.runKernel(nx,r,a)}});const tE=ak({squeeze_:function(e,t){const n=nk(e,"x","squeeze","string_or_numeric");return IC(n,Xm(n.shape,t).newShape)}});const nE=ak({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=rk(e,"tensors","stack","string_or_numeric");Lm(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Lm(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:t};return Kw.runKernel(wy,r,a)}});const rE=ak({tanh_:function(e){const t={x:nk(e,"x","tanh","float32")};return Kw.runKernel(bx,t)}});function aE(e,t){Bm(e);const n=Jw(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ik(e,null,n,t)}function oE(e,t,n){if(Bm(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Jw(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ik(e,t,r,n)}const iE=ak({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(uv(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new LI(t,n,r,!0,a),i=Jk(e,r);for(let s=0;s<i.values.length;s++)i.values[s]=o.nextValue();return i.toTensor()}});const sE=ak({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=nk(e,"x","unstack","string_or_numeric");Lm(t>=-n.shape.length&&t<n.shape.length,(()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const r={value:n},a={axis:t};return Kw.runKernel(Cx,r,a)}});const cE=ak({where_:function(e,t,n){const r=nk(t,"a","where"),a=nk(n,"b","where"),o=nk(e,"condition","where","bool"),i=NS(NS(o.shape,r.shape),a.shape),s={condition:FC(o,i),t:FC(r,i),e:FC(a,i)};return Kw.runKernel(Gy,s)}});const lE=ak({imag_:function(e){const t={input:nk(e,"input","imag")};return Kw.runKernel(Bb,t)}});const uE=ak({real_:function(e){const t={input:nk(e,"input","real")};return Kw.runKernel(Ay,t)}});const dE=ak({transpose_:function(e,t,n){const r=nk(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Lm(r.rank===t.length,(()=>"Error in transpose: rank of input ".concat(r.rank," ")+"must match length of perm ".concat(t,"."))),t.forEach((e=>{Lm(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(r.rank-1)+" but got ".concat(t)))})),r.rank<=1)return r.clone();const a={x:r},o={perm:t};return"complex64"===r.dtype?dk((()=>{let e=uE(r),t=lE(r);return e=Kw.runKernel(kx,{x:e},o),t=Kw.runKernel(kx,{x:t},o),n&&(t=TI(t)),ok(e,t)})):Kw.runKernel(kx,a,o)}});const hE=ak({dropout_:function(e,t,n,r){const a=nk(e,"x","dropout");if(Lm("float32"===a.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(a.dtype," tensor instead."))),Lm(t>=0&&t<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(t,"."))),0===t)return e instanceof Ew?a.clone():a;const o=function(e,t){if(null==t)return e.shape.slice();if(Um(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),i=1-t,s=oS(tI(rS(WI(o,0,1,"float32",r),i)),i);return iS(a,s)}});const pE=ak({fft_:function(e){Lm("complex64"===e.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Kw.runKernel(Nb,t)}});const fE=ak({rfft_:function(e,t){Lm("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(e.dtype)));let n=e.shape[e.shape.length-1];const r=e.size/n;let a;if(null!=t&&t<n){const r=e.shape.map((e=>0)),o=e.shape.map((e=>e));o[e.shape.length-1]=t,a=KI(e,r,o),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,a=DC([e,OI(r)],e.shape.length-1),n=t}else a=e;const o=lS(a),i=IC(ok(a,o),[r,n]),s=pE(i),c=Math.floor(n/2)+1,l=uE(s),u=lE(s),d=eE(l,[c,n-c],l.shape.length-1),h=eE(u,[c,n-c],u.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=c,IC(ok(d[0],h[0]),p)}});const gE=ak({ifft_:function(e){Lm("complex64"===e.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Kw.runKernel(zb,t)}});const mE=ak({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const a=IC(e,[n,t]);r=gE(a)}else{const a=[n,2*(t-1)],o=IC(uE(e),[n,t]),i=IC(lE(e),[n,t]),s=jI(KI(o,[0,1],[n,t-2]),1),c=iS(jI(KI(i,[0,1],[n,t-2]),1),dS(-1)),l=DC([o,s],1),u=DC([i,c],1),d=IC(ok(l,u),[a[0],a[1]]);r=gE(d)}if(r=uE(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=IC(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const vE=ak({conv2DBackpropFilter_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,s=e;3===e.rank&&(s=IC(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=IC(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Lm(4===s.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(s.shape,"."))),Lm(4===c.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(c.shape,"."))),Lm(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const l="NHWC"===o?s.shape[3]:s.shape[1],u="NHWC"===o?c.shape[3]:c.shape[1];Lm(l===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(l,") must ")+"match input depth in filter (".concat(n[2],"."))),Lm(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),CC("conv2dDerFilter",a,i);const d={x:s,dy:c},h={strides:r,pad:a,dataFormat:o,dimRoundingMode:i,filterShape:n};return Kw.runKernel(Zv,d,h)}});const bE=ak({relu6_:function(e){const t={x:nk(e,"x","relu6")};return Kw.runKernel(zy,t)}});const yE=ak({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:nk(e,"x","step")},r={alpha:t};return Kw.runKernel(Nx,n,r)}});function xE(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return iS(e,yE(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function wE(e,t){let n=t;const r=ES(e.shape,t.shape);return r.length>0&&(n=lI(n,r)),IC(n,e.shape)}function kE(e,t,n,r){if("linear"===t)return e;if("relu"===t)return VI(e);if("elu"===t)return XC(e);if("relu6"===t)return bE(e);if("prelu"===t)return MI(e,n);if("leakyrelu"===t)return oI(e,r);if("sigmoid"===t)return qI(e);throw new Error("Unknown fused activation ".concat(t,"."))}const SE=(e,t)=>!(e>0)||"linear"===t;const CE=ak({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:o="NHWC",dilations:i=[1,1],dimRoundingMode:s,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:d}=e;if(l=l||"linear",!1===SE(Kw.state.gradientDepth,l)){Lm("NHWC"===o,(()=>"Error in fused conv2d: got dataFormat of ".concat(o," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let e=BC(t,n,r,a,o,i,s);return null!=c&&(e=rS(e,c)),kE(e,l,u,d)}const h=nk(t,"x","conv2d","float32"),p=nk(n,"filter","conv2d","float32");let f=h,g=!1;3===h.rank&&(g=!0,f=IC(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Lm(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),Lm(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),CC("fused conv2d",a,s);const m="NHWC"===o?f.shape[3]:f.shape[1];Lm(p.shape[2]===m,(()=>"Error in conv2d: depth of input (".concat(m,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),Lm(wC(r,i),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(i,"'")));const v=pC(f.shape,p.shape,r,i,a,s);let b,y;if(null!=c&&(b=nk(c,"bias","fused conv2d"),[b]=Bw(b,h),"NHWC"===o?NS(v.outShape,b.shape):(Lm(b.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(b.shape.length,"."))),Lm(0===b.shape.length||b.shape[0]===v.outChannels||1===b.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(b.shape,") is not ")+"compatible with the number of output channels "+"(".concat(v.outChannels,")"))))),null!=u){const e=u.shape;if(Lm(e.length<=1||3===e.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,"."))),1===e.length)Lm(1===e[0]||e[0]===v.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(v.outChannels,").")));else if(3===e.length)try{NS(e,v.outShape)}catch(f0){const n="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(v.outShape,").");throw Error(n)}y=nk(u,"prelu weights","fused conv2d")}const x=(e,t)=>{Lm("NHWC"===o,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(o," but only NHWC is currently supported.")));const[n,s,c,u]=t,d=xE(e,c,l);Lm(xC(i),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(i,"'")));const h=[UC(s.shape,d,n,r,a),vE(s,d,n.shape,r,a)];if(null!=u){const e=wE(u,d);h.push(e)}return h},w={x:f,filter:p,bias:b,preluActivationWeights:y},k={strides:r,pad:a,dataFormat:o,dilations:i,dimRoundingMode:s,activation:l,leakyreluAlpha:d};if(null==c){const e=uS(((e,t,n)=>{let r=Kw.runKernel(Ox,w,k);return n([t,e,r]),g&&(r=IC(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p)}{const e=uS(((e,t,n,r)=>{let a=Kw.runKernel(Ox,w,k);return r([t,e,a,n]),g&&(a=IC(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}));return e(f,p,b)}}});const IE=ak({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,s=e;3===e.rank&&(s=IC(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=IC(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:s,dy:c},u={strides:r,pad:a,dimRoundingMode:i,dilations:o,filterShape:n};return Kw.runKernel(db,l,u)}});const EE=ak({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,s=t,c=!1;3===t.rank&&(c=!0,s=IC(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:s,filter:n},u={strides:r,pad:a,dimRoundingMode:i,dilations:o,inputShape:e},d=Kw.runKernel(hb,l,u);return c?IC(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const NE=ak({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:a=!1,bias:o,activation:i="linear",preluActivationWeights:s,leakyreluAlpha:c=.2}=e;if(!1===SE(Kw.state.gradientDepth,i)){let e=wI(t,n,r,a);return null!=o&&(e=rS(e,o)),kE(e,i,s,c)}let l=nk(t,"a","fused matMul"),u=nk(n,"b","fused matMul");[l,u]=Bw(l,u);const d=r?l.shape[l.rank-2]:l.shape[l.rank-1],h=a?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?l.shape[l.rank-1]:l.shape[l.rank-2],f=a?u.shape[u.rank-2]:u.shape[u.rank-1],g=l.shape.slice(0,-2),m=u.shape.slice(0,-2),v=Wm(g),b=Wm(m);Lm(d===h,(()=>"Error in fused matMul: inner shapes (".concat(d,") and (")+"".concat(h,") of Tensors with shapes ").concat(l.shape," and ")+"".concat(u.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const y=NS(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),x=IC(l,r?[v,d,p]:[v,p,d]),w=IC(u,a?[b,f,h]:[b,h,f]);let k,S;null!=o&&(k=nk(o,"bias","fused matMul"),[k]=Bw(k,l),NS(y,k.shape)),null!=s&&(S=nk(s,"prelu weights","fused matMul"));const C=(e,t)=>{const[n,s,c,l]=t,u=xE(IC(e,c.shape),c,i);let d,h;if(r||a?!r&&a?(d=wI(u,s,!1,!1),h=wI(u,n,!0,!1)):r&&!a?(d=wI(s,u,!1,!0),h=wI(n,u,!1,!1)):(d=wI(s,u,!0,!0),h=wI(u,n,!0,!0)):(d=wI(u,s,!1,!0),h=wI(n,u,!0,!1)),null!=o){return[d,h,wE(l,u)]}return[d,h]},I={a:x,b:w,bias:k,preluActivationWeights:S},E={transposeA:r,transposeB:a,activation:i,leakyreluAlpha:c};if(null==o){const e=uS(((e,t,n)=>{const r=Kw.runKernel(Ax,I,E);return n([e,t,r]),{value:IC(r,y),gradFunc:C}}));return e(x,w)}{const e=uS(((e,t,n,r)=>{const a=Kw.runKernel(Ax,I,E);return r([e,t,a,n]),{value:IC(a,y),gradFunc:C}}));return e(x,w,k)}}});const TE=ak({cropAndResize_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=nk(e,"image","cropAndResize"),s=nk(t,"boxes","cropAndResize","float32"),c=nk(n,"boxInd","cropAndResize","int32"),l=s.shape[0];Lm(4===i.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(i.rank,"."))),Lm(2===s.rank&&4===s.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(l,",4] ")+"but had shape ".concat(s.shape,"."))),Lm(1===c.rank&&c.shape[0]===l,(()=>"Error in cropAndResize: boxInd must be have size [".concat(l,"] ")+"but had shape ".concat(s.shape,"."))),Lm(2===r.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(r.length,"."))),Lm(r[0]>=1&&r[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(r))),Lm("bilinear"===a||"nearest"===a,(()=>"method must be bilinear or nearest, but was ".concat(a)));const u={image:i,boxes:s,boxInd:c},d={method:a,extrapolationValue:o,cropSize:r};return Kw.runKernel(sb,u,d)}});const RE=ak({flipLeftRight_:function(e){const t=nk(e,"image","flipLeftRight","float32");Lm(4===t.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,".")));const n={image:t};return Kw.runKernel(Rb,n,{})}});const AE=ak({grayscaleToRGB_:function(e){const t=nk(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Lm(t.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),Lm(1===r,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(r,".")));const a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,JC(t,a)}});const OE=ak({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(((e,t)=>nk(e,"tensors".concat(t),"einsum"))),o={equation:e};return Kw.runKernel(yb,a,o)}});const FE=ak({rgbToGrayscale_:function(e){const t=nk(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Lm(t.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),Lm(3===r,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(r,".")));const a=t.dtype,o=eS(t,"float32"),i=aE([.2989,.587,.114]);let s;switch(t.rank){case 2:s=OE("ij,j->i",o,i);break;case 3:s=OE("ijk,k->ij",o,i);break;case 4:s=OE("ijkl,l->ijk",o,i);break;case 5:s=OE("ijklm,m->ijkl",o,i);break;case 6:s=OE("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return s=ZC(s,-1),eS(s,a)}});const _E=ak({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=nk(e,"image","rotateWithOffset","float32");Lm(4===a.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(a.rank,".")));const o={image:a},i={radians:t,fillValue:n,center:r};return Kw.runKernel(Rx,o,i)}});function DE(e,t,n,r,a,o){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=e.shape[0];return n=Math.min(n,i),Lm(0<=r&&r<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(r,"'"))),Lm(2===e.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'"))),Lm(4===e.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1]))),Lm(1===t.rank,(()=>"scores must be a 1D tensor")),Lm(t.shape[0]===i,(()=>"scores has incompatible shape with boxes. Expected ".concat(i,", ")+"but was ".concat(t.shape[0]))),Lm(0<=o&&o<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(o,"'"))),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:o}}const ME=ak({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=nk(e,"boxes","nonMaxSuppression","float32"),i=nk(t,"scores","nonMaxSuppression","float32"),s=DE(o,i,n,r,a);n=s.maxOutputSize,r=s.iouThreshold,a=s.scoreThreshold;const c={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return Kw.runKernel(my,{boxes:o,scores:i},c)}});function PE(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,o=0,i=!1;for(;r<a;){o=r+(a-r>>>1);const s=n(t,e[o]);s>0?r=o+1:(a=o,i=!s)}return i?r:-r-1}(e,t,n||LE)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function LE(e,t){return e>t?1:e<t?-1:0}function zE(e,t,n,r,a){return UE(e,t,n,r,a,0)}function BE(e,t,n,r,a,o){return UE(e,t,n,r,a,0,!1,o,!0)}function WE(e,t,n,r,a,o){return UE(e,t,n,r,a,o,!0)}function UE(e,t,n,r,a,o){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],s=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=[];for(let m=0;m<t.length;m++)t[m]>a&&l.push({score:t[m],boxIndex:m,suppressBeginIndex:0});l.sort(HE);const u=o>0?-.5/o:0,d=[],h=[];for(;d.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:o,suppressBeginIndex:i}=t;if(n<a)break;let s=!1;for(let c=d.length-1;c>=i;--c){const n=VE(e,o,d[c]);if(n>=r){s=!0;break}if(t.score=t.score*jE(r,u,n),t.score<=a)break}t.suppressBeginIndex=d.length,s||(t.score===n?(d.push(o),h.push(t.score)):t.score>a&&PE(l,t,HE))}const p=d.length,f=n-p;s&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const g={selectedIndices:d};return i&&(g.selectedScores=h),c&&(g.validOutputs=p),g}function VE(e,t,n){const r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),s=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),l=Math.min(a[0],a[2]),u=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),h=Math.max(a[1],a[3]),p=(s-o)*(c-i),f=(d-l)*(h-u);if(p<=0||f<=0)return 0;const g=Math.max(o,l),m=Math.max(i,u),v=Math.min(s,d),b=Math.min(c,h),y=Math.max(v-g,0)*Math.max(b-m,0);return y/(p+f-y)}function jE(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function HE(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const GE=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=nk(e,"boxes","nonMaxSuppressionAsync"),i=nk(t,"scores","nonMaxSuppressionAsync"),s=DE(o,i,n,r,a);n=s.maxOutputSize,r=s.iouThreshold,a=s.scoreThreshold;const c=await Promise.all([o.data(),i.data()]),l=c[0],u=c[1],{selectedIndices:d}=zE(l,u,n,r,a);return o!==e&&o.dispose(),i!==t&&i.dispose(),aE(d,"int32")};const qE=ak({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=nk(e,"boxes","nonMaxSuppression"),s=nk(t,"scores","nonMaxSuppression"),c=DE(i,s,n,r,a,o);n=c.maxOutputSize,r=c.iouThreshold,a=c.scoreThreshold,o=c.softNmsSigma;const l={boxes:i,scores:s},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:o},d=Kw.runKernel(by,l,u);return{selectedIndices:d[0],selectedScores:d[1]}}});const KE=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=nk(e,"boxes","nonMaxSuppressionAsync"),s=nk(t,"scores","nonMaxSuppressionAsync"),c=DE(i,s,n,r,a,o);n=c.maxOutputSize,r=c.iouThreshold,a=c.scoreThreshold,o=c.softNmsSigma;const l=await Promise.all([i.data(),s.data()]),u=l[0],d=l[1],{selectedIndices:h,selectedScores:p}=WE(u,d,n,r,a,o);return i!==e&&i.dispose(),s!==t&&s.dispose(),{selectedIndices:aE(h,"int32"),selectedScores:aE(p)}};const XE=ak({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=nk(e,"boxes","nonMaxSuppression"),s=nk(t,"scores","nonMaxSuppression"),c=DE(i,s,n,r,a,null),l={boxes:i,scores:s},u={maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:o},d=Kw.runKernel(vy,l,u);return{selectedIndices:d[0],validOutputs:d[1]}}});const $E=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=nk(e,"boxes","nonMaxSuppressionAsync"),s=nk(t,"scores","nonMaxSuppressionAsync"),c=DE(i,s,n,r,a,null),l=c.maxOutputSize,u=c.iouThreshold,d=c.scoreThreshold,[h,p]=await Promise.all([i.data(),s.data()]),{selectedIndices:f,validOutputs:g}=BE(h,p,l,u,d,o);return i!==e&&i.dispose(),s!==t&&s.dispose(),{selectedIndices:aE(f,"int32"),validOutputs:dS(g,"int32")}};const YE=ak({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=nk(e,"images","resizeBilinear");Lm(3===a.rank||4===a.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),Lm(2===t.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,"."))),Lm(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let o=a,i=!1;3===a.rank&&(i=!0,o=IC(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,s={images:o},c={alignCorners:n,halfPixelCenters:r,size:t},l=Kw.runKernel(Py,s,c);return i?IC(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const QE=ak({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=nk(e,"images","resizeNearestNeighbor");Lm(3===a.rank||4===a.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),Lm(2===t.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,"."))),Lm("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Lm(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let o=a,i=!1;3===a.rank&&(i=!0,o=IC(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,s={images:o},c={alignCorners:n,halfPixelCenters:r,size:t},l=Kw.runKernel(Dy,s,c);return i?IC(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const ZE=ak({bincount_:function(e,t,n){const r=nk(e,"x","bincount"),a=nk(t,"weights","bincount");Lm("int32"===r.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(r.dtype))),Lm(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Lm(a.size===r.size||0===a.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(r.shape,", weights shape: ")+"".concat(a.shape,".")));const o={x:r,weights:a},i={size:n};return Kw.runKernel(Vv,o,i)}});const JE=ak({lessEqual_:function(e,t){let n=nk(e,"a","lessEqual","string_or_numeric"),r=nk(t,"b","lessEqual","string_or_numeric");[n,r]=Bw(n,r),NS(n.shape,r.shape);const a={a:n,b:r};return Kw.runKernel(Gb,a)}});const eN=ak({round_:function(e){const t={x:nk(e,"x","round")};return Kw.runKernel(Wy,t)}});const tN=ak({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=nk(e,"image","threshold"),o=a.shape[0]*a.shape[1];let i,s,c,l,u=iS(aE([r]),255);if(Lm(3===a.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(a.rank,"."))),Lm(3===a.shape[2]||1===a.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(a.shape[2],"."))),Lm("int32"===a.dtype||"float32"===a.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(a.dtype,"."))),Lm("otsu"===t||"binary"===t,(()=>"Method must be binary or otsu, but was ".concat(t))),3===a.shape[2]){[i,s,c]=eE(a,[1,1,1],-1);const e=iS(i,.2989),t=iS(s,.587),n=iS(c,.114);l=rS(rS(e,t),n)}else l=e;if("otsu"===t){u=function(e,t){let n,r,a,o,i,s,c=aE([-1]),l=aE([0]),u=aE([0]);for(let d=0;d<e.size-1;d++){n=KI(e,0,d+1),r=KI(e,d+1),i=oS(lI(n),t),s=oS(lI(r),t);const h=lI(iS(n,UI(0,n.size)));a=oS(h,lI(n));const p=yS(r.shape,n.size),f=rS(UI(0,r.size),p),g=iS(r,f);o=oS(lI(g),lI(r));const m=kS(a,o),v=kS(a,o),b=iS(i,s);u=iS(iS(b,m),v);const y=rI(u,l);l=cE(y,u,l),c=cE(y,aE([d]),c)}return c}(ZE(eS(eN(l),"int32"),sk([]),256),o)}const d=n?JE(l,u):rI(l,u);return eS(iS(d,255),"int32")}});const nN=ak({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5?arguments[5]:void 0;const i=nk(e,"image","transform","float32"),s=nk(t,"transforms","transform","float32");Lm(4===i.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(i.rank,"."))),Lm(2===s.rank&&(s.shape[0]===i.shape[0]||1===s.shape[0])&&8===s.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Lm(null==o||2===o.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(o,".")));const c={image:i,transforms:s},l={interpolation:n,fillMode:r,fillValue:a,outputShape:o};return Kw.runKernel(wx,c,l)}});const rN=ak({less_:function(e,t){let n=nk(e,"a","less","string_or_numeric"),r=nk(t,"b","less","string_or_numeric");[n,r]=Bw(n,r),NS(n.shape,r.shape);const a={a:n,b:r};return Kw.runKernel(Hb,a)}});const aN=ak({bandPart_:function(e,t,n){const r=nk(e,"a","bandPart");Lm(r.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(r.rank,".")));const a=r.shape,[o,i]=r.shape.slice(-2);let s,c;"number"===typeof t?(Lm(t%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(t,"."))),Lm(t<=o,(()=>"bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(o,")."))),s=nk(t<0?o:t,"numLower","bandPart")):(Lm("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),s=cE(rN(t,0),o,EI(t,o))),"number"===typeof n?(Lm(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."))),Lm(n<=i,(()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(i,")."))),c=nk(n<0?i:n,"numUpper","bandPart")):(Lm("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),c=cE(rN(n,0),i,EI(n,i)));const l=IC(UI(0,o,1,"int32"),[-1,1]),u=UI(0,i,1,"int32"),d=kS(l,u),h=xI(JE(d,s),aI(d,TI(c))),p=OI([o,i],r.dtype);return IC(nE(sE(IC(r,[-1,o,i])).map((e=>cE(h,e,p)))),a)}});function oN(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return CS(e);if(1!==e.rank&&null===n)return oN(IC(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return lI(CS(e),n);if(t===1/0)return cI(CS(e),n);if(t===-1/0)return II(CS(e),n);if("euclidean"===t||2===t)return sS(lI(wS(CS(e),dS(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return cI(lI(CS(e),n[0]),n[1]-1);if(t===1/0)return cI(lI(CS(e),n[1]),n[0]);if(t===-1/0)return II(lI(CS(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return sS(lI(cS(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const iN=ak({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=oN(e=nk(e,"x","norm"),t,n);let o=a.shape;if(r){const t=Km(n,e.shape);o=fI(a.shape,t)}return IC(a,o)}});const sN=ak({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Lm(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Lm(e[t].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")")))}else t=!0,e=eE(e,e.shape[0],0).map((e=>tE(e,[0])));Lm(e.length<=e[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],").")));const n=[],r=e;for(let a=0;a<e.length;++a)n.push(Kw.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){const r=iS(lI(iS(n[t],e)),n[t]);e=kS(e,r)}return oS(e,iN(e,"euclidean"))})));return t?nE(n,0):n}});function cN(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Kw.tidy((()=>{Lm(2===e.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor.")));const n=e.shape[0],r=e.shape[1];let a=eI(n),o=tS(e);const i=oE([[1]],[1,1]);let s=tS(i);const c=n>=r?r:n;for(let e=0;e<c;++e){const t=o,c=s,l=a;[s,o,a]=Kw.tidy((()=>{const t=KI(o,[e,e],[n-e,1]),c=iN(t),l=KI(o,[e,e],[1,1]),u=cE(rI(l,0),oE([[-1]]),oE([[1]])),d=kS(l,iS(u,c)),h=oS(t,d);s=1===h.shape[0]?tS(i):DC([i,KI(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=TI(oS(wI(u,d),c)),f=KI(o,[e,0],[n-e,r]),g=iS(p,s),m=dE(s);if(0===e)o=kS(f,wI(g,wI(m,f)));else{const t=kS(f,wI(g,wI(m,f)));o=DC([KI(o,[0,0],[e,r]),t],0)}const v=dE(g),b=KI(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=kS(b,wI(wI(b,s),v));else{const t=kS(b,wI(wI(b,s),v));a=DC([KI(a,[0,0],[n,e]),t],1)}return[s,o,a]})),hk([t,c,l])}return!t&&n>r&&(a=KI(a,[0,0],[n,r]),o=KI(o,[0,0],[r,r])),[a,o]}))}const lN=ak({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Lm(e.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank))),2===e.rank)return cN(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=sE(IC(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],o=[];r.forEach((e=>{const[n,r]=cN(e,t);a.push(n),o.push(r)}));return[IC(nE(a,0),e.shape),IC(nE(o,0),e.shape)]}}});var uN;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(uN||(uN={}));const dN=ak({squaredDifference_:function(e,t){let n=nk(e,"a","squaredDifference"),r=nk(t,"b","squaredDifference");[n,r]=Bw(n,r),NS(n.shape,r.shape);const a={a:n,b:r};return Kw.runKernel(lx,a,{})}});const hN={flipLeftRight:RE,grayscaleToRGB:AE,resizeNearestNeighbor:QE,resizeBilinear:YE,rgbToGrayscale:FE,rotateWithOffset:_E,cropAndResize:TE,nonMaxSuppression:ME,nonMaxSuppressionAsync:GE,nonMaxSuppressionWithScore:qE,nonMaxSuppressionWithScoreAsync:KE,nonMaxSuppressionPadded:XE,nonMaxSuppressionPaddedAsync:$E,threshold:tN,transform:nN},pN={bandPart:aN,gramSchmidt:sN,qr:lN};const fN=class{static sgd(e){return new AS(e)}static momentum(e,t){return new OS(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new FS(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new SS(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new bS(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new RS(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new xS(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},gN="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function mN(){return new Promise((e=>gN((()=>e()))))}function vN(e,t){const n=e[0].length;e.forEach(((e,t)=>{Lm(e.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),Lm(t>=0&&t<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const r=e[0];e.forEach(((e,a)=>{for(let o=0;o<n;o++)Lm(o===t||e[o]===r[o],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(a,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(r,") ")+"along the non-concatenated axis ".concat(a,".")))}))}function bN(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var yN;function xN(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(r.length));for(let a=1;a<n.length;++a){const o=n[a],i=r[r.length-n.length+a],s=r[i];if(o>=0)if(s>=0){if(s!==o)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(a+e,"] = ").concat(o," but shape[").concat(a+e,"] = ").concat(s))}else r[i]=o}return r}function wN(e){const t={FIRST_DIM_SIZE:yN.FIRST_DIM_SIZE,VALUE_ROWIDS:yN.VALUE_ROWIDS,ROW_LENGTHS:yN.ROW_LENGTHS,ROW_SPLITS:yN.ROW_SPLITS,ROW_LIMITS:yN.ROW_LIMITS,ROW_STARTS:yN.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function kN(e){return 0===e.length?0:e[0]===yN.FIRST_DIM_SIZE?e.length-1:e.length}function SN(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(r,")"));for(let a=0;a<Math.min(n,r-1);++a){const n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(a-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(a-e.length,"] = ").concat(r))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(yN||(yN={}));const CN=30;function IN(e){return e<=CN?e:rv(e,Math.floor(Math.sqrt(e)))}function EN(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function NN(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function TN(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{const r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function RN(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let o=1;o<e.length;++o)o<=t.length?r?a.push(t[o-1]*e[o]):a.push(e[o]/t[o-1]):a.push(e[o]);return a}function AN(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function ON(e,t,n){const r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}function FN(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(r<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(r,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[r-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[r-1]," vs. ").concat(n));if(0===Wm(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const a=t.shape,o=a[a.length-1];let i=1;for(let d=0;d<a.length-1;++d)i*=a[d];const s=e.shape,c=a.slice();c.pop();let l=1;for(let d=o;d<n;++d)l*=s[d],c.push(s[d]);const u=[...av(e.shape).map((e=>e/l)),1].slice(0,o);return[c,i,l,u]}function _N(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,o="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(r,", and batchDim: ").concat(a,".");if(n.rank<a)throw new Error(o+" update.rank < ".concat(a,". "));if(e.length<r+(n.rank-a))throw new Error(o+" Output shape length < ".concat(r+(n.rank-a)));if(n.rank!==a+e.length-r)throw new Error(o+" update.rank != ".concat(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(o+" updates.shape[".concat(i,"] (").concat(n.shape[i],") != indices.shape[").concat(i,"] (").concat(t.shape[i],")."));for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(o+" updates.shape[".concat(i+a,"] (").concat(n.shape[i+a],") != shape[").concat(i+a,"] (").concat(e[i+a],")"))}function DN(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}_N(n,t,e)}function MN(e,t,n){const r=t.shape.length,a=r>1?t.shape[r-1]:1,o=n.length;let i=1;for(let c=a;c<o;++c)i*=n[c];const s=a<1?1:a;return{sliceRank:a,numUpdates:Wm(t.shape)/s,sliceSize:i,strides:[...av(n.slice(0,a)),1],outputSize:Wm(n)}}const PN=1.7580993408473768,LN=1.0507009873554805,zN=.3275911,BN=.254829592,WN=-.284496736,UN=1.421413741,VN=-1.453152027,jN=1.061405429;function HN(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function GN(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function qN(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function KN(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function XN(e,t){return{real:e[2*t],imag:e[2*t+1]}}function $N(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function YN(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){const o=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(o),r[a]=Math.sin(o)}return{real:n,imag:r}}function QN(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const ZN="->",JN=/->/g,eT=",",tT="...";function nT(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(JN,"").length)/ZN.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(ZN,'").'));const[r,a]=e.split(ZN);Lm(-1===r.indexOf(tT),(()=>'The ellipsis notation ("'.concat(tT,'") is not supported yet.')));const o=r.split(eT),i=o.length;if(t!==i)throw new Error("Expected ".concat(i," input tensors, received ").concat(t));if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const s=[];for(let d=0;d<a.length;++d){const e=a[d];if(!o.some((t=>-1!==t.indexOf(e))))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===s.indexOf(e)&&s.push(e)}for(let d=0;d<r.length;++d){const e=r[d];-1===s.indexOf(e)&&e!==eT&&s.push(e)}const c=new Array(o.length);for(let d=0;d<i;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error("Found duplicate axes in input component ".concat(o[d],". ")+"Support for duplicate axes in input is not implemented yet.");c[d]=[];for(let e=0;e<o[d].length;++e)c[d].push(s.indexOf(o[d][e]))}const l=s.length,u=[];for(let d=a.length;d<l;++d)u.push(d);return{allDims:s,summedDims:u,idDims:c}}function rT(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;const r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function aT(e,t,n){const r=new Array(e);for(let a=0;a<n.length;++a){const e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:Lm(r[t[a][n]]===e[n],(()=>"Expected dimension ".concat(r[t[a][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n])))}}function oT(e,t){const n=e,r=[];let a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);const o=[];for(let i=0;i<n.length;++i){const e=sT(t,n[i]);for(const t of e)-1===o.indexOf(t)&&(r[i].push(t),o.push(t))}return{path:n,steps:r}}function iT(e){return e.every(((e,t)=>e===t))}function sT(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function cT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof t)Lm(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Lm(a<=1,(()=>"There should be only one negative value in split array."));const o=t.indexOf(-1);if(-1!==o){const r=t.reduce(((e,t)=>t>0?e+t:e));t[o]=e.shape[n]-r}Lm(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function lT(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function uT(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function dT(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function hT(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function pT(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function fT(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function gT(e,t){const n=Wm(e),r=Wm(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(r,". inputShape=").concat(e," outputShape= ").concat(t)}function mT(e,t){const n=Wm(e),r=Wm(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(r,". inputShape=").concat(e," outputShape=").concat(t)}function vT(){return"segment ids must be >= 0"}function bT(){return"segment ids are not increasing"}function yT(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function xT(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function wT(e,t){let n,r=!1;for(e<=CN?(n=e,r=!0):n=rv(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=rv(e,n+1);return n}function kT(e,t,n){const r=[],a=e.length;for(let o=0;o<a;o++)o!==t?r.push(e[o]):r.push(n);return r}function ST(e,t,n,r){const a=t.shape.length,o=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error("Expect batchDims in the range of [-".concat(a,", ").concat(a,"], but got ").concat(r));if(r<0&&(r+=a),r>o)throw new Error("batchDims (".concat(r,") must be less than rank(x) (\n    ").concat(o,")."));if(n<r)throw new Error("batchDims (".concat(r,") must be less than or equal to axis (").concat(n,")."));for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error("x.shape[".concat(d,"]: ").concat(e.shape[d]," should be equal to indices.shape[").concat(d,"]: ").concat(t.shape[d],"."));const i=e.shape[n],s=[];let c=1,l=1,u=1;for(let d=0;d<r;++d)s.push(e.shape[d]),c*=e.shape[d];for(let d=r;d<n;d++)s.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<a;d++)s.push(t.shape[d]);for(let d=n+1;d<o;d++)s.push(e.shape[d]),u*=e.shape[d];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:i,outputShape:s}}function CT(e){try{return e.map((e=>cw(e)))}catch(g0){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(g0))}}function IT(e){return e.map((e=>sw(e)))}function ET(e,t){const n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);const r=Jk(e,"int32"),a=Jk([n.length,e.length],"int32");for(let o=0;o<n.length;o++){const t=r.indexToLoc(n[o]),i=o*e.length;a.values.set(t,i)}return a.toTensor()}!function(){for(const e of _S)mS(e)}();const NT={kernelName:kv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(e,yE(eS(n,"float32"),-1))}}},TT={kernelName:Sv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=cS(eS(n,"float32")),r=sS(kS(dS(1),t));return TI(oS(e,r))}}}},RT={kernelName:Cv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=sS(kS(cS(eS(n,"float32")),1));return oS(e,t)}}}},AT={kernelName:Iv,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=NS(n.shape,r.shape);return{a:()=>{let t=e;const r=ES(n.shape,a);return r.length>0&&(t=lI(t,r)),IC(t,n.shape)},b:()=>{let t=e;const n=ES(r.shape,a);return n.length>0&&(t=lI(t,n)),IC(t,r.shape)}}}},OT={kernelName:Ev,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},FT={kernelName:Rv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>lS(n)}}},_T={kernelName:Av,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>lS(n)}}},DT={kernelName:Ov,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oS(e,sS(kS(dS(1),cS(eS(n,"float32")))))}}},MT={kernelName:Fv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=sS(rS(dS(1),cS(eS(n,"float32"))));return oS(e,t)}}}},PT={kernelName:Mv,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=NS(n.shape,r.shape);return{a:()=>{const t=rS(cS(n),cS(r));let o=iS(e,oS(r,t));const i=ES(n.shape,a);return i.length>0&&(o=lI(o,i)),IC(o,n.shape)},b:()=>{const t=rS(cS(n),cS(r));let o=TI(iS(e,oS(n,t)));const i=ES(r.shape,a);return i.length>0&&(o=lI(o,i)),IC(o,r.shape)}}}},LT={kernelName:_v,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oS(e,rS(cS(eS(n,"float32")),1))}}},zT={kernelName:Dv,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oS(e,kS(dS(1),cS(eS(n,"float32"))))}}};const BT=ak({avgPool3dGrad_:function(e,t,n,r,a,o){const i=nk(e,"dy","avgPool3dGrad"),s=nk(t,"input","avgPool3dGrad");let c=i,l=s,u=!1;4===s.rank&&(u=!0,c=IC(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=IC(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),Lm(5===c.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(c.rank,"."))),Lm(5===l.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(l.rank,"."))),CC("avgPool3dGrad",a,o);const d={dy:c,input:l},h={filterSize:n,strides:r,pad:a,dimRoundingMode:o},p=Kw.runKernel(Bv,d,h);return u?IC(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),WT={kernelName:zv,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:s}=n;return{x:()=>BT(e,r,a,o,i,s)}}};const UT=ak({avgPoolGrad_:function(e,t,n,r,a){const o=nk(e,"dy","avgPoolGrad"),i=nk(t,"input","avgPoolGrad");Lm(i.rank===o.rank,(()=>"Rank of input (".concat(i.rank,") does not match rank of dy (").concat(o.rank,")")));let s=i,c=o,l=!1;3===i.rank&&(l=!0,s=IC(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=IC(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Lm(4===c.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(c.rank,"."))),Lm(4===s.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(s.rank,".")));const u={dy:c,input:s},d={filterSize:n,strides:r,pad:a},h=Kw.runKernel(Lv,u,d);return l?IC(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),VT={kernelName:Pv,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:o,pad:i}=n;return{x:()=>UT(e,r,a,o,i)}}},jT={kernelName:Wv,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,a]=t,{transposeA:o,transposeB:i}=n;return o||i?!o&&i?{a:()=>wI(e,a,!1,!1),b:()=>wI(e,r,!0,!1)}:o&&!i?{a:()=>wI(a,e,!1,!0),b:()=>wI(r,e,!1,!1)}:{a:()=>wI(a,e,!0,!0),b:()=>wI(e,r,!0,!0)}:{a:()=>wI(e,a,!1,!0),b:()=>wI(r,e,!0,!1)}}};const HT=ak({spaceToBatchND_:function(e,t,n){const r=nk(e,"x","spaceToBatchND");Lm(r.rank>=1+t.length,(()=>"input rank ".concat(r.rank," should be > than [blockShape] ").concat(t.length))),Lm(n.length===t.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length))),Lm(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>"input spatial dimensions ".concat(r.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString())));const a={x:r},o={blockShape:t,paddings:n};return Kw.runKernel(tx,a,o)}}),GT={kernelName:Uv,gradFunc:(e,t,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>HT(e,r,a)}}},qT={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n,a=r.inputShape,o=r.shape,i=Array.from(o);for(let c=a.length-1;c>=0;c--)if(a[c]===o[c])i[c]=1;else if(1!==a[c])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(o,"]."));const s=[];for(let c=0;c<i.length;c++)i[c]>1&&s.push(c);return{x:()=>lI(e,s,!0)}}},KT={kernelName:Gv,gradFunc:e=>({x:()=>e.clone()})},XT={kernelName:qv,gradFunc:e=>({x:()=>lS(e)})},$T={kernelName:Kv,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:a,clipValueMax:o}=n;return{x:()=>cE(xI(aI(r,a),JE(r,o)),e,lS(e))}}},YT={kernelName:$v,inputsToSave:["x"],gradFunc:NT.gradFunc},QT={kernelName:Yv,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:a}=n,o=Km(a,t[0].shape)[0],i=r.map((e=>e[o]));return eE(e,i,o).map((e=>()=>e))}},ZT={kernelName:Qv,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{dilations:o,strides:i,pad:s,dataFormat:c}=n;return Lm(xC(o),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'"))),{x:()=>UC(r.shape,e,a,i,s,c),filter:()=>vE(r,e,a.shape,i,s,c)}}},JT={kernelName:Jv,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{strides:o,pad:i,dataFormat:s,dimRoundingMode:c}=n;return{dy:()=>BC(e,a,o,i,s,1,c),filter:()=>vE(e,r,a.shape,o,i,s,c)}}};const eR=ak({conv3DBackpropFilter_:function(e,t,n,r,a){let o=e;4===e.rank&&(o=IC(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=IC(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Lm(5===o.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(o.shape,"."))),Lm(5===i.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(i.shape,"."))),Lm(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),Lm(o.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(o.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),Lm(i.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(i.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const s={x:o,dy:i},c={strides:r,pad:a,filterShape:n};return Kw.runKernel(tb,s,c)}}),tR={kernelName:eb,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:o}=n;Lm(xC(r),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(r,"'")));const[i,s]=t;return{x:()=>HC(i.shape,e,s,a,o),filter:()=>eR(i,e,s.shape,a,o)}}};const nR=ak({sin_:function(e){const t={x:nk(e,"x","sin","float32")};return Kw.runKernel(Xy,t)}}),rR={kernelName:rb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(TI(nR(eS(n,"float32"))),e)}}};const aR=ak({sinh_:function(e){const t={x:nk(e,"x","sinh")};return Kw.runKernel($y,t)}}),oR={kernelName:ab,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(aR(eS(n,"float32")),e)}}};const iR=ak({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:nk(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:r};return Kw.runKernel(ib,a,o)}}),sR={kernelName:ib,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a,exclusive:o,reverse:i}=n;return{x:()=>{const t=mI([a],r.rank);let n=iR(e,a,o,!i);return null!=t&&(n=dE(n,t)),n}}}},cR={kernelName:ub,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:o,dimRoundingMode:i}=n,s=null==r?[1,1]:r;Lm(xC(s),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(s,"'")));const[c,l]=t;return Lm(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(c.rank,"."))),Lm(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(l.rank,"."))),Lm(c.shape[3]===l.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(c.shape[3],") must match the inChannels dimension ")+"in filter ".concat(l.shape[2],"."))),Lm(wC(a,s),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(a," and dilations ")+"'".concat(s,"'."))),CC("depthwiseConv2d",o,i),{x:()=>EE(c.shape,e,l,a,o,s,i),filter:()=>IE(c,e,l.shape,a,o,s,i)}}},lR={kernelName:fb,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,o={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>Kw.runKernel(gb,o,n),filter:()=>Kw.runKernel(mb,i,n)}}},uR={kernelName:xb,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>Kw.runKernel(wb,r)}}},dR={kernelName:kb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=iS(QC(TI(cS(n))),2/Math.sqrt(Math.PI));return{x:()=>iS(e,r)}}},hR={kernelName:Cb,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(e,n)}}},pR={kernelName:Ib,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>IC(e,n.shape)}}},fR={kernelName:Eb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(e,QC(n))}}},gR={kernelName:Ab,gradFunc:e=>({x:()=>lS(e)})},mR={kernelName:Ob,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=NS(n.shape,r.shape);return{a:()=>{const t=oS(e,eS(r,"float32")),o=ES(n.shape,a);return o.length>0?IC(lI(t,o),n.shape):t},b:()=>{let t=iS(e,eS(n,"float32"));const o=ES(r.shape,a);o.length>0&&(t=IC(lI(t,o),r.shape));const i=cS(r);return TI(oS(t,eS(i,"float32")))}}}};const vR=ak({rsqrt_:function(e){const t={x:nk(e,"x","rsqrt","float32")};return Kw.runKernel(Uy,t)}}),bR={kernelName:Fb,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[a,o,i,s]=t,c=null==s?dS(1):s,l=ES(o.shape,a.shape),u=[];if(1===o.rank){for(let e=0;e<a.shape.length-1;++e)u.push(a.shape[e]);u.push(1)}const d=kS(a,o),h=iS(e,c),p=vR(rS(i,dS(r))),f=iS(iS(iS(p,p),p),dS(-.5));return{x:()=>1===o.rank?IC(iS(iS(e,JC(IC(p,[1,1,1,o.shape[0]]),u)),c),a.shape):IC(iS(iS(e,p),c),a.shape),mean:()=>{let e=iS(iS(p,dS(-1)),h);return 1===o.rank&&(e=lI(e,l)),IC(e,o.shape)},variance:()=>{let e=iS(iS(f,d),h);return 1===o.rank&&(e=lI(e,l)),IC(e,o.shape)},scale:()=>{const t=iS(d,p);let n=iS(e,t);return 1===o.rank&&(n=lI(n,l)),IC(n,o.shape)},offset:()=>{let t=e;return 1===o.rank&&(t=lI(t,l)),IC(t,o.shape)}}}};const yR=ak({unsortedSegmentSum_:function(e,t,n){const r=nk(e,"x","unsortedSegmentSum"),a=nk(t,"segmentIds","unsortedSegmentSum","int32");Lm(Vm(n),(()=>"numSegments must be of dtype int"));const o={x:r,segmentIds:a},i={numSegments:n};return Kw.runKernel(Ix,o,i)}}),xR={kernelName:_b,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,a]=t,{axis:o,batchDims:i}=n,s=Km(o,r.shape)[0],c=(e,t,n)=>()=>{const r=e.shape,a=t.size,i=r.slice(0,s),c=i.length,l=r.slice(o,r.length).slice(1),u=l.length,d=wR(0,c),h=wR(c+1,c+1+u),p=kR([i,[a],l]),f=IC(n,p),g=IC(t,[a]),m=kR([[c],d,h]),v=dE(f,m);let b=yR(v,g,e.shape[s]);const y=vI(m);return b=dE(b,y),b};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>{const t=nE(n.map(((t,n)=>c(t,a.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)},indices:()=>a}}return{x:c(r,a,e),indices:()=>a}}};function wR(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function kR(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const SR={kernelName:Pb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>lS(n),b:()=>lS(r)}}},CR={kernelName:Lb,gradFunc:e=>({x:()=>eS(e,"float32")})},IR={kernelName:Wb,gradFunc:e=>({x:()=>lS(e)})},ER={kernelName:Ub,gradFunc:e=>({x:()=>lS(e)})},NR={kernelName:Vb,gradFunc:e=>({x:()=>lS(e)})},TR={kernelName:jb,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:a}=n,o=rI(r,0);return{x:()=>cE(o,e,iS(e,a))}}},RR={kernelName:Xb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oS(e,rS(n,1))}}},AR={kernelName:Kb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oS(e,eS(n,"float32"))}}},OR={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;return{logits:()=>{const t=QC(r);return kS(e,iS(lI(e,a,!0),t))}}}};const FR=ak({localResponseNormalizationBackprop_:function(e,t,n){const r={x:e,y:t,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Kw.runKernel(Jb,r,a)}}),_R={kernelName:Zb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{depthRadius:o,bias:i,alpha:s,beta:c}=n;return{x:()=>FR(r,a,e,o,i,s,c)}}};function DR(e,t,n,r){return t.rank<n.rank&&(t=IC(t,fI(t.shape,r))),e.rank<n.rank&&(e=IC(e,fI(e.shape,r))),{x:()=>iS(e,eS($C(n,t),e.dtype))}}const MR={kernelName:ey,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:a}=r,o=t[0],i=DR(e,t[1],o,Km(a,o.shape));return{x:()=>i.x()}}},PR={kernelName:ty,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>iS(e,eS(aI(n,r),"float32")),b:()=>iS(e,eS(rN(n,r),"float32"))}}};const LR=ak({maxPool3dGrad_:function(e,t,n,r,a,o,i){const s=nk(e,"dy","maxPool3dGrad"),c=nk(t,"input","maxPool3dGrad"),l=nk(n,"output","maxPool3dGrad");let u=s,d=c,h=l,p=!1;4===c.rank&&(p=!0,u=IC(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),d=IC(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),h=IC(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),Lm(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),Lm(5===d.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(d.rank,"."))),Lm(5===h.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(h.rank,"."))),CC("maxPool3dGrad",o,i);const f={dy:u,input:d,output:h},g={filterSize:r,strides:a,pad:o,dimRoundingMode:i},m=Kw.runKernel(oy,f,g);return p?IC(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),zR={kernelName:ay,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:o,strides:i,pad:s,dimRoundingMode:c}=n;return{x:()=>LR(e,r,a,o,i,s,c)}}};const BR=ak({maxPoolGrad_:function(e,t,n,r,a,o,i){const s=nk(e,"dy","maxPoolGrad"),c=nk(t,"input","maxPoolGrad"),l=nk(n,"output","maxPoolGrad");Lm(c.rank===s.rank,(()=>"Rank of input (".concat(c.rank,") does not match rank of dy ")+"(".concat(s.rank,")"))),Lm(4===s.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(s.rank,"."))),Lm(4===c.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(c.rank,"."))),CC("maxPoolGrad",o,i);const u={dy:s,input:c,output:l},d={filterSize:r,strides:a,pad:o,dimRoundingMode:i};return Kw.runKernel(ry,u,d)}}),WR={kernelName:ny,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:o,strides:i,pad:s}=n;return{x:()=>BR(e,r,a,o,i,s)}}},UR={kernelName:sy,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n,o=Km(a,r.shape),i=Wm(pI(r.shape,o)[1]);return{x:()=>{const t=r.shape.slice();o.forEach((e=>{t[e]=1}));const n=IC(e,t);return oS(iS(n,FI(r.shape,"float32")),i)}}}},VR={kernelName:cy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:a}=r,[o,i]=t,s=DR(e,i,o,Km(a,o.shape));return{x:()=>s.x()}}},jR={kernelName:ly,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>iS(e,eS(JE(n,r),"float32")),b:()=>iS(e,eS(rI(n,r),"float32"))}}},HR={kernelName:uy,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,o=a.map((e=>e[0]));return{x:()=>KI(e,o,r.shape)}}},GR={kernelName:dy,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=NS(n.shape,r.shape);return{a:()=>{const t=ES(n.shape,a);return t.length>0?IC(lI(e,t),n.shape):e},b:()=>{const t=iS(e,TI(tI(oS(n,r)))),o=ES(r.shape,a);return o.length>0?IC(lI(t,o),r.shape):t}}}},qR={kernelName:py,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=NS(n.shape,r.shape);return{a:()=>{const t=iS(e,eS(r,"float32")),o=ES(n.shape,a);return o.length>0?IC(lI(t,o),n.shape):t},b:()=>{const t=iS(e,eS(n,"float32")),o=ES(r.shape,a);return o.length>0?IC(lI(t,o),r.shape):t}}}},KR={kernelName:fy,gradFunc:e=>({x:()=>TI(e)})},XR={kernelName:xy,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>OI(n.shape,"float32")}}},$R={kernelName:yy,gradFunc:e=>({x:()=>lS(e)})},YR={kernelName:wy,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return sE(e,r).map((e=>()=>e))}},QR={kernelName:ky,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,o=a.map((e=>e[0]));return{x:()=>KI(e,o,r.shape)}}},ZR={kernelName:Sy,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,a]=t,o=n,i=r,s=NS(o.shape,i.shape);return{a:()=>{const t=eS(i,"float32");let n=iS(e,iS(t,wS(o,kS(t,dS(1)))));const r=ES(o.shape,s);return r.length>0&&(n=lI(n,r)),IC(n,o.shape)},b:()=>{const t=rI(o,0),n=cE(t,iI(o),lS(o));let r=iS(e,iS(a,n));const c=ES(i.shape,s);return c.length>0&&(r=lI(r,c)),IC(r,i.shape)}}}},JR={kernelName:Cy,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,a=rI(n,0);return{x:()=>cE(a,e,iS(e,r)),alpha:()=>{let t=cE(a,lS(e),iS(e,n));const o=ES(r.shape,e.shape);return o.length>0&&(t=lI(t,o)),IC(t,r.shape)}}}};const eA=ak({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:nk(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:r};return Kw.runKernel(ob,a,o)}});function tA(e,t,n){const r=e.shape.length,a=r-n.length,o=mI(n,r);let i=e;null!=o&&(i=dE(e,o));const s=i.shape.slice(),c=s.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);s.push(c);let l=function(e,t,n){const r=e.shape.slice();r[n]=1;const a=IC(t,r),o=eA(e,n,!0,!1),i=eA(e,n,!0,!0),s=iS(o,i);return iS(a,s)}(i.reshape(s),t,a);if(l=l.reshape(i.shape),null!=o){const e=vI(o);l=dE(l,e)}return l}const nA={kernelName:Iy,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;let o=[];return o=void 0===a||null===a?r.shape.map(((e,t)=>t)):"number"===typeof a?[a]:a,{x:()=>tA(r,e,o)}}},rA={kernelName:bb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=NS(n.shape,r.shape);return{a:()=>{const t=oS(e,eS(r,"float32")),o=ES(n.shape,a);return o.length>0?IC(lI(t,o),n.shape):t},b:()=>{let t=iS(e,eS(n,"float32"));const o=ES(r.shape,a);o.length>0&&(t=IC(lI(t,o),r.shape));const i=cS(r);return TI(oS(t,eS(i,"float32")))}}}},aA={kernelName:Oy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oS(e,TI(cS(n)))}}},oA={kernelName:zy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=iS(JE(n,6),yE(n));return{x:()=>iS(e,eS(r,"float32"))}}},iA={kernelName:Fy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(e,eS(yE(n),"float32"))}}},sA={kernelName:_y,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>IC(e,n.shape)}}},cA={kernelName:Py,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>Kw.runKernel(Ly,a,n)}}},lA={kernelName:Dy,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>Kw.runKernel(My,a,n)}}},uA={kernelName:By,gradFunc:(e,t,n)=>{const{dims:r}=n,a=Km(r,e.shape);return{x:()=>jI(e,a)}}},dA={kernelName:Wy,gradFunc:e=>({x:()=>lS(e)})},hA={kernelName:Uy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>TI(oS(e,iS(wS(n,1.5),2)))}}};const pA=ak({logicalNot_:function(e){const t={x:nk(e,"x","logicalNot","bool")};return Kw.runKernel(Yb,t)}}),fA={kernelName:Gy,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>eS(lS(n),"float32"),t:()=>iS(e,eS(n,e.dtype)),e:()=>iS(e,eS(pA(n),e.dtype))}}},gA={kernelName:qy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=rI(n,dS(0)),r=dS(PN),a=dS(LN),o=iS(e,a),i=iS(iS(e,r),QC(eS(n,"float32")));return cE(t,o,i)}}}},mA={kernelName:Qy,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(e,iS(n,kS(dS(1),n)))}}},vA={kernelName:Yy,gradFunc:e=>({x:()=>lS(e)})};const bA=ak({cos_:function(e){const t={x:nk(e,"x","cos","float32")};return Kw.runKernel(rb,t)}}),yA={kernelName:Xy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(bA(eS(n,"float32")),e)}}};const xA=ak({cosh_:function(e){const t={x:nk(e,"x","cosh","float32")};return Kw.runKernel(ab,t)}}),wA={kernelName:$y,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(xA(eS(n,"float32")),e)}}},kA={kernelName:Ky,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:a,size:o}=n,i=r.shape,[s,c]=aC(r,a,o),l=[];for(let u=0;u<e.rank;u++)l.push([s[u],i[u]-s[u]-c[u]]);return{x:()=>DI(e,l)}}},SA={kernelName:rx,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:a}=n,o=iS(e,r);return{logits:()=>kS(o,iS(lI(o,[a],true),r))}}},CA={kernelName:Zy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(e,qI(n))}}};const IA=ak({batchToSpaceND_:function(e,t,n){const r=nk(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));Lm(r.rank>=1+t.length,(()=>"input rank is ".concat(r.rank," but should be > than blockShape.length ").concat(t.length))),Lm(n.length===t.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length))),Lm(r.shape[0]%a===0,(()=>"input tensor batch is ".concat(r.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(a)));const o={x:r},i={blockShape:t,crops:n};return Kw.runKernel(Uv,o,i)}}),EA={kernelName:tx,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>IA(e,r,a)}}},NA={kernelName:nx,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>DC(e,r)}}},TA={kernelName:Jy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oS(e,iS(sS(eS(n,"float32")),2))}}},RA={kernelName:ux,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(e,iS(eS(n,"float32"),2))}}},AA={kernelName:lx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=dS(2);return{a:()=>iS(e,iS(a,kS(n,r))),b:()=>iS(e,iS(a,kS(r,n)))}}},OA={kernelName:mx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=NS(n.shape,r.shape);return{a:()=>{let t=e;const r=ES(n.shape,a);return r.length>0&&(t=lI(t,r)),IC(t,n.shape)},b:()=>{let t=e;const n=ES(r.shape,a);return n.length>0&&(t=lI(t,n)),IC(TI(t),r.shape)}}}},FA={kernelName:ex,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,a=r.shape.slice(),{axis:o}=n;Km(o,r.shape).forEach((e=>{a[e]=1}));const i=IC(e,a),s=iS(i,FI(r.shape,"float32"));return{x:()=>s}}},_A={kernelName:vx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>oS(e,cS(bA(n)))}}},DA={kernelName:bx,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iS(kS(dS(1),cS(n)),e)}}},MA={kernelName:yx,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:a}=n;return{x:()=>{let t=lS(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=rS(t,KI(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let o=0;o<a[1];++o)t=rS(t,KI(e,[n*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let o=0;o<a[1];++o)for(let i=0;i<a[2];++i)t=rS(t,KI(e,[n*r.shape[0],o*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(r.rank," tensors yet."));for(let n=0;n<a[0];++n)for(let o=0;o<a[1];++o)for(let i=0;i<a[2];++i)for(let s=0;s<a[3];++s)t=rS(t,KI(e,[n*r.shape[0],o*r.shape[1],i*r.shape[2],s*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},PA={kernelName:Ix,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=TS(t,lS(t)),r=nI(e,n);let a=aI(t,dS(0,"int32"));const o=r.rank-a.rank;for(let s=0;s<o;++s)a=ZC(a,s+1);a=xI(a,FI(r.shape,"bool"));const i=lS(r);return cE(a,r,i)}(e,n)}}};const LA=[NT,TT,RT,AT,OT,FT,_T,DT,MT,PT,LT,zT,WT,VT,jT,GT,qT,KT,XT,$T,YT,QT,JT,ZT,tR,rR,oR,sR,cR,lR,rA,uR,dR,hR,pR,fR,mR,gR,bR,xR,SR,CR,IR,ER,NR,TR,RR,AR,OR,_R,MR,MR,PR,zR,WR,UR,VR,jR,HR,GR,qR,KR,XR,$R,YR,QR,QR,ZR,JR,nA,aA,oA,iA,sA,cA,lA,uA,dA,hA,fA,gA,mA,vA,yA,wA,kA,SA,CA,EA,EA,NA,NA,TA,AA,RA,{kernelName:Nx,gradFunc:e=>({x:()=>lS(e)})},OA,FA,_A,DA,MA,{kernelName:kx,gradFunc:(e,t,n)=>{const r=n,{perm:a}=r,o=vI(a);return{x:()=>dE(e,o)}}},{kernelName:Cx,gradFunc:(e,t,n)=>{const r=n,{axis:a}=r;return{value:()=>nE(e,a)}}},PA,{kernelName:Ex,gradFunc:e=>({x:()=>lS(e)})}];for(const n of LA)Ux(n);Nw().prototype.abs=function(){return this.throwIfDisposed(),CS(this)};const zA=ak({acos_:function(e){const t={x:nk(e,"x","acos")};return Kw.runKernel(Sv,t)}});Nw().prototype.acos=function(){return this.throwIfDisposed(),zA(this)};const BA=ak({acosh_:function(e){const t={x:nk(e,"x","acosh")};return Kw.runKernel(Cv,t)}});Nw().prototype.acosh=function(){return this.throwIfDisposed(),BA(this)},Nw().prototype.add=function(e){return this.throwIfDisposed(),rS(this,e)},Nw().prototype.all=function(e,t){return this.throwIfDisposed(),sC(this,e,t)},Nw().prototype.any=function(e,t){return this.throwIfDisposed(),cC(this,e,t)},Nw().prototype.argMax=function(e){return this.throwIfDisposed(),lC(this,e)};const WA=ak({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:nk(e,"x","argMin")},r={axis:t};return Kw.runKernel(Av,n,r)}});Nw().prototype.argMin=function(e){return this.throwIfDisposed(),WA(this,e)},Nw().prototype.asScalar=function(){return this.throwIfDisposed(),Lm(1===this.size,(()=>"The array must have only 1 element.")),IC(this,[])},Nw().prototype.asType=function(e){return this.throwIfDisposed(),eS(this,e)},Nw().prototype.as1D=function(){return this.throwIfDisposed(),IC(this,[this.size])},Nw().prototype.as2D=function(e,t){return this.throwIfDisposed(),IC(this,[e,t])},Nw().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),IC(this,[e,t,n])},Nw().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),IC(this,[e,t,n,r])},Nw().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),IC(this,[e,t,n,r,a])};const UA=ak({asin_:function(e){const t={x:nk(e,"x","asin")};return Kw.runKernel(Ov,t)}});Nw().prototype.asin=function(){return this.throwIfDisposed(),UA(this)};const VA=ak({asinh_:function(e){const t={x:nk(e,"x","asinh")};return Kw.runKernel(Fv,t)}});Nw().prototype.asinh=function(){return this.throwIfDisposed(),VA(this)};const jA=ak({atan_:function(e){const t={x:nk(e,"x","atan")};return Kw.runKernel(_v,t)}});Nw().prototype.atan=function(){return this.throwIfDisposed(),jA(this)};const HA=ak({atan2_:function(e,t){let n=nk(e,"a","atan2"),r=nk(t,"b","atan2");[n,r]=Bw(n,r);const a={a:n,b:r};return Kw.runKernel(Mv,a)}});Nw().prototype.atan2=function(e){return this.throwIfDisposed(),HA(this,e)};const GA=ak({atanh_:function(e){const t={x:nk(e,"x","atanh")};return Kw.runKernel(Dv,t)}});Nw().prototype.atanh=function(){return this.throwIfDisposed(),GA(this)},Nw().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),EC(this,e,t,n,r)},Nw().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),IA(this,e,t)},Nw().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),TC(this,e,t,n,r,a)},Nw().prototype.broadcastTo=function(e){return this.throwIfDisposed(),FC(this,e)},Nw().prototype.cast=function(e){return this.throwIfDisposed(),eS(this,e)};const qA=ak({ceil_:function(e){const t={x:nk(e,"x","ceil","float32")};return Kw.runKernel(qv,t)}});Nw().prototype.ceil=function(){return this.throwIfDisposed(),qA(this)},Nw().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),_C(this,e,t)},Nw().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Ew&&(e=[e]),DC([this,...e],t)},Nw().prototype.conv1d=function(e,t,n,r,a,o){return this.throwIfDisposed(),WC(this,e,t,n,r,a,o)},Nw().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),VC(this,e,t,n,r,a)},Nw().prototype.conv2d=function(e,t,n,r,a,o){return this.throwIfDisposed(),BC(this,e,t,n,r,a,o)},Nw().prototype.cos=function(){return this.throwIfDisposed(),bA(this)},Nw().prototype.cosh=function(){return this.throwIfDisposed(),xA(this)},Nw().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),eA(this,e,t,n)},Nw().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),iR(this,e,t,n)};const KA=ak({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=nk(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],o="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Lm(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t))),Lm(a*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(a," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(r.shape))),Lm(o*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(o," and ").concat(t," for depthToSpace with input shape\n        ").concat(r.shape))),Lm(i%(t*t)===0,(()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(i," for depthToSpace with input shape ").concat(r.shape)));const s={x:r},c={blockSize:t,dataFormat:n};return Kw.runKernel(lb,s,c)}});Nw().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),KA(this,e,t)},Nw().prototype.depthwiseConv2d=function(e,t,n,r,a,o){return this.throwIfDisposed(),KC(this,e,t,n,r,a,o)};const XA=ak({dilation2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const i=nk(e,"x","dilation2d"),s=nk(t,"filter","dilation2d");Lm(3===i.rank||4===i.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(i.rank,"."))),Lm(3===s.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(s.rank,"."))),Lm("NHWC"===o,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(o)));let c=i,l=!1;3===i.rank&&(c=IC(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),Lm(c.shape[3]===s.shape[2],(()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(c.shape[3]," vs ").concat(s.shape[2])));const u={x:c,filter:s},d={strides:n,pad:r,dilations:a},h=Kw.runKernel(fb,u,d);return l?IC(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});Nw().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),XA(this,e,t,n,r,a)};const $A=ak({divNoNan_:function(e,t){let n=nk(e,"a","div"),r=nk(t,"b","div");[n,r]=Bw(n,r);const a=oS(n,r),o=lS(a),i=$C(r,o);return cE(i,o,a)}});Nw().prototype.divNoNan=function(e){return this.throwIfDisposed(),$A(this,e)},Nw().prototype.div=function(e){return this.throwIfDisposed(),oS(this,e)};const YA=ak({dot_:function(e,t){const n=nk(e,"t1","dot"),r=nk(t,"t2","dot");Lm((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(r.rank,".")));const a=1===n.rank?n.size:n.shape[1],o=1===r.rank?r.size:r.shape[0];if(Lm(a===o,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(a," and ").concat(o,"."))),1===n.rank&&1===r.rank){const e=IC(n,[1,-1]),t=IC(r,[-1,1]),a=wI(e,t);return IC(a,[])}if(1===n.rank&&2===r.rank){const e=IC(n,[1,-1]),t=IC(r,[r.shape[0],r.shape[1]]),a=wI(e,t);return IC(a,[a.size])}if(2===n.rank&&1===r.rank){const e=IC(r,[-1,1]),t=wI(n,e);return IC(t,[t.size])}{const e=IC(r,[r.shape[0],r.shape[1]]);return wI(n,e)}}});Nw().prototype.dot=function(e){return this.throwIfDisposed(),YA(this,e)},Nw().prototype.elu=function(){return this.throwIfDisposed(),XC(this)},Nw().prototype.equal=function(e){return this.throwIfDisposed(),$C(this,e)},Nw().prototype.erf=function(){return this.throwIfDisposed(),YC(this)};const QA=ak({euclideanNorm_:function(e){return iN(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});Nw().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),QA(this,e,t)},Nw().prototype.exp=function(){return this.throwIfDisposed(),QC(this)},Nw().prototype.expandDims=function(e){return this.throwIfDisposed(),ZC(this,e)};const ZA=ak({expm1_:function(e){const t={x:nk(e,"x","expm1")};return Kw.runKernel(Eb,t)}});Nw().prototype.expm1=function(){return this.throwIfDisposed(),ZA(this)},Nw().prototype.fft=function(){return this.throwIfDisposed(),pE(this)},Nw().prototype.flatten=function(){return this.throwIfDisposed(),IC(this,[this.size])},Nw().prototype.floor=function(){return this.throwIfDisposed(),tI(this)},Nw().prototype.floorDiv=function(e){return this.throwIfDisposed(),aS(this,e)},Nw().prototype.gather=function(e,t,n){return this.throwIfDisposed(),nI(this,e,t,n)},Nw().prototype.greaterEqual=function(e){return this.throwIfDisposed(),aI(this,e)},Nw().prototype.greater=function(e){return this.throwIfDisposed(),rI(this,e)},Nw().prototype.ifft=function(){return this.throwIfDisposed(),gE(this)},Nw().prototype.irfft=function(){return this.throwIfDisposed(),mE(this)};const JA=ak({isFinite_:function(e){const t={x:nk(e,"x","isFinite")};return Kw.runKernel(Wb,t)}});Nw().prototype.isFinite=function(){return this.throwIfDisposed(),JA(this)};const eO=ak({isInf_:function(e){const t={x:nk(e,"x","isInf")};return Kw.runKernel(Ub,t)}});Nw().prototype.isInf=function(){return this.throwIfDisposed(),eO(this)};const tO=ak({isNaN_:function(e){const t={x:nk(e,"x","isNaN")};return Kw.runKernel(Vb,t)}});Nw().prototype.isNaN=function(){return this.throwIfDisposed(),tO(this)},Nw().prototype.leakyRelu=function(e){return this.throwIfDisposed(),oI(this,e)},Nw().prototype.lessEqual=function(e){return this.throwIfDisposed(),JE(this,e)},Nw().prototype.less=function(e){return this.throwIfDisposed(),rN(this,e)};const nO=ak({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const o=nk(e,"x","localResponseNormalization");Lm(4===o.rank||3===o.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(o.rank,"."))),Lm(Vm(t),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,".")));let i=o,s=!1;3===o.rank&&(s=!0,i=IC(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c={x:i},l={depthRadius:t,bias:n,alpha:r,beta:a},u=Kw.runKernel(Zb,c,l);return s?IC(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});Nw().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),nO(this,e,t,n,r)};const rO=ak({logSigmoid_:function(e){const t=nk(e,"x","logSigmoid"),n=uS((e=>({value:TI(JI(TI(e))),gradFunc:t=>iS(t,qI(TI(e)))})));return n(t)}});Nw().prototype.logSigmoid=function(){return this.throwIfDisposed(),rO(this)},Nw().prototype.logSoftmax=function(e){return this.throwIfDisposed(),uI(this,e)},Nw().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),yI(this,e,t)},Nw().prototype.log=function(){return this.throwIfDisposed(),iI(this)},Nw().prototype.log1p=function(){return this.throwIfDisposed(),sI(this)},Nw().prototype.logicalAnd=function(e){return this.throwIfDisposed(),xI(this,e)},Nw().prototype.logicalNot=function(){return this.throwIfDisposed(),pA(this)};const aO=ak({logicalOr_:function(e,t){const n=nk(e,"a","logicalOr","bool"),r=nk(t,"b","logicalOr","bool");NS(n.shape,r.shape);const a={a:n,b:r};return Kw.runKernel(Qb,a)}});Nw().prototype.logicalOr=function(e){return this.throwIfDisposed(),aO(this,e)};const oO=ak({logicalXor_:function(e,t){const n=nk(e,"a","logicalXor","bool"),r=nk(t,"b","logicalXor","bool");return NS(n.shape,r.shape),xI(aO(e,t),pA(xI(e,t)))}});Nw().prototype.logicalXor=function(e){return this.throwIfDisposed(),oO(this,e)},Nw().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),wI(this,e,t,n)},Nw().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),kI(this,e,t,n,r)},Nw().prototype.max=function(e,t){return this.throwIfDisposed(),cI(this,e,t)},Nw().prototype.maximum=function(e){return this.throwIfDisposed(),TS(this,e)},Nw().prototype.mean=function(e,t){return this.throwIfDisposed(),CI(this,e,t)},Nw().prototype.min=function(e,t){return this.throwIfDisposed(),II(this,e,t)},Nw().prototype.minimum=function(e){return this.throwIfDisposed(),EI(this,e)};const iO=ak({mirrorPad_:function(e,t,n){Lm("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const r=nk(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Lm(t.length===r.rank,(()=>"Padding doesn't match input. Must be ".concat(r.rank,". ")+"Got ".concat(t.length,".")));const a="reflect"===n?1:0;for(let s=0;s<r.rank;s++)Lm(2===t[s].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Lm(t[s][0]>=0&&t[s][0]<=r.shape[s]-a&&t[s][1]>=0&&t[s][1]<=r.shape[s]-a,(()=>"Padding in dimension ".concat(s," cannot be greater than or equal ")+"to ".concat(r.shape[s]-a," or less than 0 for input of ")+"shape ".concat(r.shape)));const o={paddings:t,mode:n},i={x:r};return Kw.runKernel(uy,i,o)}});Nw().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),iO(this,e,t)};const sO=ak({mod_:function(e,t){let n=nk(e,"a","mod"),r=nk(t,"b","mod");[n,r]=Bw(n,r);const a={a:n,b:r};return Kw.runKernel(dy,a)}});Nw().prototype.mod=function(e){return this.throwIfDisposed(),sO(this,e)},Nw().prototype.mul=function(e){return this.throwIfDisposed(),iS(this,e)},Nw().prototype.neg=function(){return this.throwIfDisposed(),TI(this)},Nw().prototype.norm=function(e,t,n){return this.throwIfDisposed(),iN(this,e,t,n)},Nw().prototype.notEqual=function(e){return this.throwIfDisposed(),RI(this,e)},Nw().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),AI(this,e,t,n)},Nw().prototype.onesLike=function(){return this.throwIfDisposed(),_I(this)},Nw().prototype.pad=function(e,t){return this.throwIfDisposed(),DI(this,e,t)};const cO=ak({pool_:function(e,t,n,r,a,o,i){null==a&&(a=[1,1]),null==o&&(o=1),0===r&&(r="valid");const s=nk(e,"x","maxPool");let c=s,l=!1;3===s.rank&&(l=!0,c=IC(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Lm(wC(o,a),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(a,"'")));const u=dC(c.shape,t,o,a,r),d=[u.dilationHeight,u.dilationWidth];let h;h="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),a=r.map((e=>Math.floor(e/2))),o=r.map(((e,t)=>e-a[t]));return r.map(((e,t)=>[a[t],o[t]]))}([u.filterHeight,u.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,g]=function(e,t,n){const r=n.map((e=>e[0])),a=n.map((e=>e[1])),o=e.concat(r,a),i=t.map(((e,t)=>(e-o[t]%e)%e)),s=a.map(((e,t)=>e+i[t])),c=t.map(((e,t)=>[r[t],s[t]])),l=t.map(((e,t)=>[0,i[t]]));return[c,l]}([u.inHeight,u.inWidth],d,h),m=p?r:"valid",v=p?c:HT(c,d,f),b=("avg"===n?()=>EC(v,t,o,m,i):()=>kI(v,t,o,m,i))(),y=p?b:IA(b,d,g);return l?IC(y,[y.shape[1],y.shape[2],y.shape[3]]):y}});Nw().prototype.pool=function(e,t,n,r,a,o){return this.throwIfDisposed(),cO(this,e,t,n,r,a,o)},Nw().prototype.pow=function(e){return this.throwIfDisposed(),wS(this,e)},Nw().prototype.prelu=function(e){return this.throwIfDisposed(),MI(this,e)};const lO=ak({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=nk(e,"x","prod");"bool"===r.dtype&&(r=eS(r,"int32"));const a={x:r},o={axis:t,keepDims:n};return Kw.runKernel(Iy,a,o)}});Nw().prototype.prod=function(e,t){return this.throwIfDisposed(),lO(this,e,t)};const uO=ak({reciprocal_:function(e){const t={x:nk(e,"x","reciprocal")};return Kw.runKernel(Oy,t)}});Nw().prototype.reciprocal=function(){return this.throwIfDisposed(),uO(this)},Nw().prototype.relu=function(){return this.throwIfDisposed(),VI(this)},Nw().prototype.relu6=function(){return this.throwIfDisposed(),bE(this)},Nw().prototype.reshapeAs=function(e){return this.throwIfDisposed(),IC(this,e.shape)},Nw().prototype.reshape=function(e){return this.throwIfDisposed(),IC(this,e)},Nw().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),YE(this,e,t,n)},Nw().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),QE(this,e,t,n)},Nw().prototype.reverse=function(e){return this.throwIfDisposed(),jI(this,e)},Nw().prototype.rfft=function(){return this.throwIfDisposed(),fE(this)},Nw().prototype.round=function(){return this.throwIfDisposed(),eN(this)},Nw().prototype.rsqrt=function(){return this.throwIfDisposed(),vR(this)},Nw().prototype.selu=function(){return this.throwIfDisposed(),HI(this)},Nw().prototype.separableConv2d=function(e,t,n,r,a,o){return this.throwIfDisposed(),GI(this,e,t,n,r,a,o)},Nw().prototype.sigmoid=function(){return this.throwIfDisposed(),qI(this)};const dO=ak({sign_:function(e){const t={x:nk(e,"x","sign")};return Kw.runKernel(Yy,t)}});Nw().prototype.sign=function(){return this.throwIfDisposed(),dO(this)},Nw().prototype.sin=function(){return this.throwIfDisposed(),nR(this)},Nw().prototype.sinh=function(){return this.throwIfDisposed(),aR(this)},Nw().prototype.slice=function(e,t){return this.throwIfDisposed(),KI(this,e,t)},Nw().prototype.softmax=function(e){return this.throwIfDisposed(),ZI(this,e)},Nw().prototype.softplus=function(){return this.throwIfDisposed(),JI(this)},Nw().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),HT(this,e,t)},Nw().prototype.split=function(e,t){return this.throwIfDisposed(),eE(this,e,t)},Nw().prototype.sqrt=function(){return this.throwIfDisposed(),sS(this)},Nw().prototype.square=function(){return this.throwIfDisposed(),cS(this)},Nw().prototype.squaredDifference=function(e){return this.throwIfDisposed(),dN(this,e)},Nw().prototype.squeeze=function(e){return this.throwIfDisposed(),tE(this,e)},Nw().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Ew?[this,e]:[this,...e];return nE(n,t)},Nw().prototype.step=function(e){return this.throwIfDisposed(),yE(this,e)};const hO=ak({stridedSlice_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const l={x:nk(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:r,beginMask:a,endMask:o,ellipsisMask:i,newAxisMask:s,shrinkAxisMask:c};return Kw.runKernel(hx,l,u)}});Nw().prototype.stridedSlice=function(e,t,n,r,a,o,i,s){return this.throwIfDisposed(),hO(this,e,t,n,r,a,o,i,s)},Nw().prototype.sub=function(e){return this.throwIfDisposed(),kS(this,e)},Nw().prototype.sum=function(e,t){return this.throwIfDisposed(),lI(this,e,t)};const pO=ak({tan_:function(e){const t={x:nk(e,"x","tan","float32")};return Kw.runKernel(vx,t)}});Nw().prototype.tan=function(){return this.throwIfDisposed(),pO(this)},Nw().prototype.tanh=function(){return this.throwIfDisposed(),rE(this)},Nw().prototype.tile=function(e){return this.throwIfDisposed(),JC(this,e)},Nw().prototype.toBool=function(){return this.throwIfDisposed(),eS(this,"bool")},Nw().prototype.toFloat=function(){return this.throwIfDisposed(),eS(this,"float32")},Nw().prototype.toInt=function(){return this.throwIfDisposed(),eS(this,"int32")};const fO=ak({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=nk(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>a)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(a,") ")+"but got ".concat(t));const o={x:r},i={k:t,sorted:n},[s,c]=Kw.runKernel(xx,o,i);return{values:s,indices:c}}});Nw().prototype.topk=function(e,t){return this.throwIfDisposed(),fO(this,e,t)},Nw().prototype.transpose=function(e){return this.throwIfDisposed(),dE(this,e)};const gO=ak({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=nk(e,"x","unique","string_or_numeric");Lm(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},a={axis:t},[o,i]=Kw.runKernel(Sx,r,a);return{values:o,indices:i}}});Nw().prototype.unique=function(e){return this.throwIfDisposed(),gO(this,e)},Nw().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),yR(this,e,t)},Nw().prototype.unstack=function(e){return this.throwIfDisposed(),sE(this,e)},Nw().prototype.where=function(e,t){return this.throwIfDisposed(),cE(e,this,t)},Nw().prototype.zerosLike=function(){return this.throwIfDisposed(),lS(this)};class mO extends Error{constructor(e){super(e),Object.setPrototypeOf(this,mO.prototype)}}class vO extends Error{constructor(e){super(e),Object.setPrototypeOf(this,vO.prototype)}}class bO extends Error{constructor(e){super(e),Object.setPrototypeOf(this,bO.prototype)}}class yO extends Error{constructor(e){super(e),Object.setPrototypeOf(this,yO.prototype)}}class xO extends Error{constructor(e){super(e),Object.setPrototypeOf(this,xO.prototype)}}Error;class wO{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e,"."));if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function kO(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function SO(e,t){if(!e)throw new xO(t)}function CO(e,t){let n=0;for(const r of e)r===t&&n++;return n}function IO(e){return 1===e.length?e[0]:e}function EO(e){return Array.isArray(e)?e:[e]}function NO(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function TO(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let RO={};function AO(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function OO(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>OO(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?OO(t):e[n]=t.value)}}}function FO(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const a=e;let o;if(a in n)o=n[a];else if(a in RO)o=RO[a];else if(o=t[a],null==o)throw new bO("Unknown ".concat(r,": ").concat(e,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return o}{const o=e;if(null==o.className||null==o.config)throw new bO("".concat(r,": Improper config format: ")+"".concat(JSON.stringify(o),".\n")+"'className' and 'config' must set.");const i=o.className;let s,c;if(i in n?[s,c]=n[i]:i in RO?[s,c]=RO.className:i in t&&([s,c]=t[i]),null==s)throw new bO("Unknown ".concat(r,": ").concat(i,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=c){const e={};for(const n of Object.keys(RO))e[n]=RO[n];for(const a of Object.keys(n))e[a]=n[a];o.config.customObjects=e;const t=Object.assign({},RO);for(const a of Object.keys(n))RO[a]=n[a];OO(o.config);const r=c(s,o.config,n,a);return RO=Object.assign({},t),r}{const e=Object.assign({},RO);for(const r of Object.keys(n))RO[r]=n[r];const t=new s(o.config);return RO=Object.assign({},e),t}}}function _O(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function DO(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function MO(e){if(null==e)throw new bO("Invalid value in obj: ".concat(JSON.stringify(e)));for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function PO(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new bO("".concat(n," is not a valid ").concat(t,".  Valid values are ").concat(e," or null/undefined."))}function LO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return SO(n>=0),SO(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function zO(e,t){Array.isArray(e)?(Lm(e.length>0,(()=>"".concat(t," is unexpectedly an empty array."))),e.forEach(((e,n)=>zO(e,"element ".concat(n+1," of ").concat(t))))):Lm(Number.isInteger(e)&&e>0,(()=>"Expected ".concat(t," to be a positive integer, but got ")+"".concat(BO(e),".")))}function BO(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>BO(e))).join(",")+"]":"string"===typeof e?'"'.concat(e,'"'):"".concat(e)}function WO(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let UO=0;function VO(){return UO++}const jO={};function HO(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in jO||(jO[e]=0),jO[e]+=1,e+jO[e].toString()}const GO=["channelsFirst","channelsLast"],qO=["nearest","bilinear"],KO=["valid","same","causal"],XO=["max","avg"],$O=["sum","mul","concat","ave"],YO=new Map;function QO(e){PO(GO,"DataFormat",e)}function ZO(e){PO(KO,"PaddingMode",e)}function JO(e){PO(XO,"PoolMode",e)}const eF=[],tF="/";function nF(e,t){eF.push(e);try{const e=t();return eF.pop(),e}catch(f0){throw eF.pop(),f0}}function rF(e){if(!iF(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===eF.length?"":eF.join(tF)+tF)+e}function aF(e){if(!iF(e))throw new Error("Not a valid tensor name: '"+e+"'");YO.has(e)||YO.set(e,0);const t=YO.get(e);if(YO.set(e,YO.get(e)+1),t>0){const n="".concat(e,"_").concat(t);return YO.set(n,1),n}return e}const oF=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function iF(e){return!!e.match(oF)}function sF(e){return e===parseInt(e.toString(),10)}function cF(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function lF(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function uF(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function dF(e,t){if(t<e)throw new bO("end (".concat(t,") < begin (").concat(e,") is forbidden."));const n=[];for(let r=e;r<t;++r)n.push(r);return n}let hF;function pF(){return null==hF&&(hF=gk().epsilon()),hF}function fF(e,t){return eS(e,t)}function gF(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),IC(e,n)}function mF(e,t,n){return dk((()=>{switch(e.rank){case 1:return XI(e,t,n);case 2:return $I(e,[t,0],[n,e.shape[1]]);case 3:return YI(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return QI(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return KI(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return KI(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new bO("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function vF(e,t,n){return dk((()=>{switch(e.rank){case 1:return XI(e,t,n);case 2:return $I(e,[0,t],[e.shape[0],n]);case 3:return YI(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return QI(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new bO("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function bF(e,t,n,r){return dk((()=>{switch(e.rank){case 1:return XI(e,t,n);case 2:switch(r){case 1:return mF(e,t,n);case 2:return vF(e,t,n);default:throw new bO("The axis is not within the rank of the tensor "+"".concat(r))}case 3:switch(r){case 1:return mF(e,t,n);case 2:return YI(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return vF(e,t,n);default:throw new bO("The axis is not within the rank of the tensor "+"".concat(r))}case 4:switch(r){case 1:return mF(e,t,n);case 2:return QI(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return QI(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return vF(e,t,n);default:throw new bO("The axis is not within the rank of the tensor "+"".concat(r))}default:throw new bO("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function yF(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),DC(e,n)}function xF(e,t){switch(e.rank){case 1:return MC([e,t]);case 2:return PC([e,t],0);case 3:return LC([e,t],0);case 4:return zC([e,t],0);default:throw new bO("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(e.rank))}}function wF(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new bO("The length of input n (".concat(t.length,") does not match ")+"the number of dimensions in input x (".concat(e.rank,")"));return JC(e,t)}function kF(e){return BI(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function SF(e,t,n,r){if(e.rank<2||t.rank<2)throw new yO("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(e.shape," and y shape = ").concat(t.shape));if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new yO("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(e.shape," and ")+" y shape = ".concat(t.shape))}if(2===e.rank&&2===t.rank){return NE({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?EF(e.rank,r,"channelsLast"):null,activation:n})}{const a=e.shape.slice(),o=a.pop();e=IC(e,[-1,o]);const i=t.shape.slice(),s=i.pop(),c=i.pop(),l=[...i,s],u=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=IC(dE(t,u),[c,-1]);const d=[...a,...l];return IC(NE({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?EF(e.rank,r,"channelsLast"):null,activation:n}),d)}}function CF(e,t,n){return dk((()=>(t=Array.isArray(t)?aE(t,"int32"):eS(t,"int32"),nI(e,t,n))))}function IF(e){return iS(e,e)}function EF(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new bO("Unexpected bias dimensions: ".concat(t.rank)+"; expected it to be 1 or ".concat(e));if(5===e){if("channelsFirst"===n)return 1===r.length?IC(t,[1,r[0],1,1,1]):IC(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?IC(t,[1,1,1,1,r[0]]):IC(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?IC(t,[1,r[0],1,1]):IC(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?IC(t,[1,1,1,r[0]]):IC(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?IC(t,[1,r[0],1]):IC(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?IC(t,[1,1,r[0]]):IC(t,[1].concat(r))}else if(e<3)return t;throw new bO("Unsupported input rank by biasAdd: ".concat(t.rank))}function NF(e,t,n){return dk((()=>(null==n&&(n="channelsLast"),QO(n),rS(e,EF(e.rank,t,n)))))}function TF(e,t,n,r){return dk((()=>hE(e,t,n,r)))}function RF(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const AF=["fanIn","fanOut","fanAvg"],OF=["normal","uniform","truncatedNormal"];class FF extends fS{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class _F extends FF{apply(e,t){return OI(e,t)}}_F.className="Zeros",mS(_F);class DF extends FF{apply(e,t){return FI(e,t)}}DF.className="Ones",mS(DF);class MF extends FF{constructor(e){if(super(),"object"!==typeof e)throw new bO("Expected argument of type ConstantConfig but got ".concat(e));if(void 0===e.value)throw new bO("config must have value set but got ".concat(e));this.value=e.value}apply(e,t){return dk((()=>iS(dS(this.value),FI(e,t))))}getConfig(){return{value:this.value}}}MF.className="Constant",mS(MF);class PF extends FF{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return WI(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}PF.className="RandomUniform",mS(PF);class LF extends FF{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new yO("randomNormal does not support dType ".concat(t,"."));return kF(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}LF.className="RandomNormal",mS(LF);class zF extends FF{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new yO("truncatedNormal does not support dType ".concat(t,"."));return iE(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}zF.className="TruncatedNormal",mS(zF);class BF extends FF{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return dk((()=>{if(2!==e.length||e[0]!==e[1])throw new bO("Identity matrix initializer can only be used for 2D square matrices.");return iS(this.gain,eI(e[0]))}))}getConfig(){return{gain:this.gain}}}BF.className="Identity",mS(BF);class WF extends FF{constructor(e){if(super(),e.scale<0)throw new bO("scale must be a positive float. Got: ".concat(e.scale));var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,PO(AF,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){PO(OF,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(QO(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){const r=cF(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){const r=cF(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{const r=cF(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],a=n[1];let o=this.scale;if("fanIn"===this.mode?o/=Math.max(1,r):"fanOut"===this.mode?o/=Math.max(1,a):o/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(o);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new yO("".concat(this.getClassName()," does not support dType ").concat(t,"."));return iE(e,0,n,t,this.seed)}{const n=Math.sqrt(3*o);return WI(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}WF.className="VarianceScaling",mS(WF);class UF extends WF{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return WF.className}}UF.className="GlorotUniform",mS(UF);class VF extends WF{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return WF.className}}VF.className="GlorotNormal",mS(VF);class jF extends WF{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return WF.className}}jF.className="HeNormal",mS(jF);class HF extends WF{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return WF.className}}HF.className="HeUniform",mS(HF);class GF extends WF{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return WF.className}}GF.className="LeCunNormal",mS(GF);class qF extends WF{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return WF.className}}qF.className="LeCunUniform",mS(qF);class KF extends FF{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return dk((()=>{if(e.length<2)throw new yO("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError("Unsupported data type ".concat(t,"."));const n=Wm(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(a,") elements: ")+"Slowness may result.");const o=kF([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=pN.qr(o,!1);let s=i[0];const c=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return s=iS(s,c.sign()),n<r&&(s=s.transpose()),iS(dS(this.gain),s.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}KF.className="Orthogonal",mS(KF);const XF={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function $F(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return FO(e,gS.getMap().classNameMap,t,"initializer")}function YF(e){return AO(e)}function QF(e){if("string"===typeof e){const t=e in XF?XF[e]:e;if("GlorotNormal"===t)return new VF;if("GlorotUniform"===t)return new UF;if("HeNormal"===t)return new jF;if("HeUniform"===t)return new HF;if("LeCunNormal"===t)return new GF;if("LeCunUniform"===t)return new qF;{const e={};return e.className=t,e.config={},$F(e)}}return e instanceof FF?e:$F(e)}function ZF(e){return Array.isArray(e)&&Array.isArray(e[0])}function JF(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function e_(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new bO("Expected Tensor length to be 1; got ".concat(e.length));t=e[0]}else t=e;return t}function t_(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new bO("Expected exactly 1 Shape; got ".concat(e.length))}return e}function n_(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const r_="Variable";class a_{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:r_,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=VO(),n=null==n?r_:n,this.originalName=rF(n),this.name=aF(this.originalName),this.trainable_=r,this.constraint=a,this.val=function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Kw.makeVariable(e,t,n,r)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function o_(e){return e.map((e=>e.read()))}function i_(e){e.forEach((e=>{e[0].write(e[1])}))}class s_{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class c_{constructor(e,t,n,r,a,o,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=VO(),null!=o&&(this.originalName=rF(o),this.name=aF(this.originalName)),this.rank=t.length}}let l_=0;class u_{constructor(e,t){this.callArgs=t,this.id=l_++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let d_=0;class h_ extends fS{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=d_++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=NO(e)+"_"+HO(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new vO("The layer has never been called "+"and thus has no defined ".concat(t,"."));if(this.inboundNodes.length<=e)throw new bO("Asked to get ".concat(t," at node ").concat(e,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[e]}getInputAt(e){return IO(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return IO(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new mO("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new mO("Layer ".concat(this.name)+" is not connected, no input to return.");return IO(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new mO("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new mO("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return IO(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=EO(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=EO(this.inputSpec);if(t.length!==n.length)throw new bO("Layer ".concat(this.name," expects ").concat(n.length," inputs, ")+"but it received ".concat(t.length," input tensors. ")+"Input received: ".concat(e));for(let r=0;r<t.length;r++){const e=t[r],a=n[r];if(null==a)continue;const o=e.rank;if(null!=a.ndim&&o!==a.ndim)throw new bO("Input ".concat(r," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(a.ndim,", found ndim=").concat(o));if(null!=a.maxNDim&&o>a.maxNDim)throw new bO("Input ".concat(r," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(a.maxNDim,", found ndim=").concat(o));if(null!=a.minNDim&&o<a.minNDim)throw new bO("Input ".concat(r," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(a.minNDim,", found ndim=").concat(o,"."));if(null!=a.dtype&&e.dtype!==a.dtype)throw new bO("Input ".concat(r," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(a.dtype,", found dtype=").concat(e.dtype,"."));if(a.axes){const t=e.shape;for(const e in a.axes){const n=Number(e),o=a.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=o&&-1===[o,null].indexOf(i))throw new bO("Input ".concat(r," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(n," of input shape to ")+"have value ".concat(o," but got shape ").concat(t,"."))}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){const n=a.shape[t],o=e.shape[t];if(null!=n&&null!=o&&n!==o)throw new bO("Input ".concat(r," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(a.shape,", ")+"found shape=".concat(e.shape,"."))}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=EO(e),r=function(e){let t=!0;for(const n of EO(e))if(!(n instanceof c_)){t=!1;break}return t}(e),a=function(e){let t=!0;for(const n of EO(e))if(n instanceof c_){t=!1;break}return t}(e);if(r===a)throw new bO("Arguments to apply() must be all SymbolicTensors or all Tensors");return nF(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of EO(e))t.push(n.shape);this.build(IO(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const a=EO(r),o=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),o.push(e);if(r=IO(o),null!=this.activityRegularizer)throw new yO("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=EO(e);const t=[];for(const n of e)t.push(n.shape);return IO(t)}(e),r=this.computeOutputShape(n);let a;const o="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new c_(o,n,this,EO(e),t,this.name,r))):new c_(o,r,this,EO(e),t,this.name),this.addInboundNode(e,a,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new yO("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(e),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(e),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new mO("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new mO("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new vO("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return n_(this.weights)}build(e){this.built=!0}getWeights(){return o_(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){dk((()=>{const t=this.weights;if(t.length!==e.length)throw new bO('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(e.length,", ")+"but the layer was expecting ".concat(t.length," weights. ")+"Provided weights: ".concat(e,"..."));if(0===t.length)return;const n=[],r=o_(t);for(let a=0;a<r.length;++a){const o=r[a],i=t[a],s=e[a];if(!Um(o.shape,s.shape))throw new bO("Layer weight shape ".concat(o.shape," ")+"not compatible with provided weight shape ".concat(s.shape));n.push([i,s])}i_(n)}))}addWeight(e,t,n,r,a,o,i,s){if(-1!==this._addedWeightNames.indexOf(e))throw new bO("Duplicate weight name ".concat(e," for layer ").concat(this.name));this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=s?s():QF("zeros"));const c=r.apply(t,n),l=new a_(c,n,e,o,i);return c.dispose(),null!=a&&this.addLoss((()=>a.apply(l.read()))),null==o&&(o=!0),o?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=EO(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");t.forEach((e=>{if(null!=e)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),a=EO(t),o=EO(r);if(a.length!==o.length)throw new Error("".concat(this.name," outputs ").concat(a.length," tensors ")+"but ".concat(a.length," masks for those tensors"));for(let i=0;i<a.length;i++)a[i].kerasMask=o[i]}addInboundNode(e,t,n,r,a,o){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const s=EO(e);t=EO(t),n=EO(n),r=EO(r),a=JF(a),o=JF(o);const c=[],l=[],u=[];for(const d of s)c.push(d.sourceLayer),l.push(d.nodeIndex),u.push(d.tensorIndex);new u_({outboundLayer:this,inboundLayers:c,nodeIndices:l,tensorIndices:u,inputTensors:s,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:o},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function p_(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=p_(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class f_ extends h_{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:HO("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new bO("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new bO("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new bO("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new c_(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new u_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new bO("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}f_.className="InputLayer",mS(f_);class g_{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof g_)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new bO("Duplicate key: name=".concat(e.name,", id=").concat(e.id));return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return eS(t,e.dtype)}catch(g0){throw new bO("The dtype of the feed (".concat(t.dtype,") can not be cast to the dtype ")+"of the key '".concat(e.name,"' (").concat(e.dtype,")."))}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof c_){if(null==this.id2Value[e.id])throw new bO("Nonexistent key: ".concat(e.name));return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new bO("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Value[t]}}getMask(e){if(e instanceof c_){if(null==this.id2Value[e.id])throw new bO("Nonexistent key: ".concat(e.name));return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new bO("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&hk(this.id2Mask)}}const m_=new wO,v_=new wO;function b_(e,t,n,r){const a=null!=n&&n.training,o=Array.isArray(e),i=o?e:[e],s=i.map((e=>e.name)),c=[],l=t.names();for(const f of s)-1!==l.indexOf(f)?c.push(t.getValue(f)):c.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=s.join(",")+"|"+t.names().sort().join(",");let d,h=m_.get(u);if(null==h){const e=function(e,t){Lm(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const a=x_(e[0],t);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const o of e){const{sorted:e,recipientMap:i}=x_(o,t);for(const t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:y_(r)}}(i,t);h=e.sorted,d=e.recipientCounts,m_.put(u,h),v_.put(u,d)}d={},a||Object.assign(d,v_.get(u));const p=new g_(t);for(let f=0;f<h.length;++f){if(null!=r){const e=uk().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=h[f],o=e.sourceLayer;if(o instanceof f_)continue;const i=[],l=[],u=[];let g=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);i.push(e),l.push(r),null!=r&&(g=!0),a||(d[n.name]--,0!==d[n.name]||t.hasKey(n)||-1!==s.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||u.push(e))}g&&((n=n||{}).mask=l[0]);const m=EO(o.apply(i,n));let v=null;o.supportsMasking&&(v=o.computeMask(i,l));const b=w_(e),y=Array.isArray(b)?b:[b];for(let t=0;t<y.length;++t){p.hasKey(y[t])||p.add(y[t],m[t],Array.isArray(v)?v[0]:v);const e=s.indexOf(y[t].name);-1!==e&&(c[e]=m[t])}a||hk(u)}return p.disposeMasks(),o?c:c[0]}function y_(e){const t={};for(const n in e)t[n]=e[n].size;return t}function x_(e,t){const n=new Set,r=[],a={};for(const s of t.names())n.add(s);const o=[],i=[];for(o.push(e);o.length>0;){const e=o[o.length-1];if(n.has(e.name)){o.pop();continue}const t=i[i.length-1]===o.length-1;if(0===e.inputs.length||t)o.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(o.length-1);for(const t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),n.has(t.name)||o.push(t)}}return{sorted:r,recipientMap:a}}function w_(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function k_(e,t){return dk((()=>sS(lI(iS(e,e),t,!0))))}vv().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=m_&&m_.setMaxEntries(e),null!=v_&&v_.setMaxEntries(e)}));class S_ extends fS{getConfig(){return{}}}class C_ extends S_{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return dk((()=>{const t=k_(e,this.axis),n=_C(t,0,this.maxValue);return iS(e,oS(n,rS(pF(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}C_.className="MaxNorm",mS(C_);class I_ extends S_{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return dk((()=>oS(e,rS(pF(),k_(e,this.axis)))))}getConfig(){return{axis:this.axis}}}I_.className="UnitNorm",mS(I_);class E_ extends S_{apply(e){return VI(e)}}E_.className="NonNeg",mS(E_);class N_ extends S_{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return dk((()=>{const t=k_(e,this.axis),n=rS(iS(this.rate,_C(t,this.minValue,this.maxValue)),iS(1-this.rate,t));return iS(e,oS(n,rS(pF(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}N_.className="MinMaxNorm",mS(N_);const T_={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function R_(e){return AO(e)}function A_(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return FO(e,gS.getMap().classNameMap,t,"constraint")}function O_(e){if(null==e)return null;if("string"===typeof e){return A_({className:e in T_?T_[e]:e,config:{}})}return e instanceof S_?e:A_(e)}async function F_(e){if(null==e)return;const t=[],n=[],r=[];for(const a in e){const o=e[a];if("number"!==typeof o){const e=o;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){const a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];hk(r)}}function __(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var D_;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(D_||(D_={}));class M_{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class P_{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class L_ extends M_{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const r in t){const e=t[r];if("number"===typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;const a=dk((()=>rS(this.totals[r],iS(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:dk((()=>{const e=iS(oS(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),pk(t[n])})))}}class z_ extends M_{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const a in this.history){const r=this.history[a];for(let o=0;o<r.length;++o)if("number"!==typeof r[o]){const i=r[o];e.push(i.data()),t.push(a),n.push(o)}}const r=await Promise.all(e);for(let a=0;a<r.length;++a){this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}}}class B_ extends M_{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||mN,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");ev(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():iw();return function(){const o=null!=n?n():iw();return o-a<t||(a=o,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await F_(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await F_(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await F_(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await F_(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await F_(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):ev(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await F_(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await F_(e),await this.trainEnd(e))}}function W_(e,t){if(null==e&&(e={}),e instanceof M_)return[e];if(Array.isArray(e)&&e[0]instanceof M_)return e;return EO(e).map((e=>new B_(e,t)))}class U_{constructor(){}static registerCallbackConstructor(e,t){Lm(e>=0&&Number.isInteger(e),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(e))),U_.checkForDuplicate(t),null==U_.constructors[e]&&(U_.constructors[e]=[]),U_.constructors[e].push(t)}static checkForDuplicate(e){for(const t in U_.constructors){U_.constructors[+t].forEach((t=>{if(t===e)throw new bO("Duplicate callback constructor.")}))}}static clear(){U_.constructors={}}static createCallbacks(e){const t=[];for(const n in U_.constructors){const r=+n;e>=r&&t.push(...U_.constructors[r])}return t.map((e=>new e))}}function V_(e,t,n,r,a,o,i,s,c){const l=new z_,u=[new L_,...U_.createCallbacks(t)];null!=e&&u.push(...e),u.push(l);const d=new P_(u);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:o,batchSize:i,verbose:t,doValidation:s,metrics:c}),{callbackList:d,history:l}}function j_(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return FO(e,gS.getMap().classNameMap,t,"layer",n)}function H_(e,t){return dk((()=>{"float32"!==e.dtype&&(e=eS(e,"float32"));const n=lI(IF(e),t,!0),r=yS(n.shape,pF()),a=sS(TS(n,r));return oS(e,a)}))}function G_(e,t){return dk((()=>CI(IF(kS(t,e)),-1)))}function q_(e,t){return dk((()=>CI(CS(kS(t,e)),-1)))}function K_(e,t){return dk((()=>{const n=kS(e,t),r=_C(CS(e),pF(),Number.MAX_VALUE),a=CS(oS(n,r));return iS(100,CI(a,-1))}))}function X_(e,t){return dk((()=>{const n=_C(t,pF(),Number.MAX_VALUE),r=iI(rS(1,n)),a=_C(e,pF(),Number.MAX_VALUE),o=iI(rS(1,a));return CI(IF(kS(r,o)),-1)}))}function $_(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return dk((()=>{if(n)t=ZI(t);else{const e=lI(t,t.shape.length-1,!0);t=oS(t,e)}return t=_C(t,pF(),1-pF()),TI(lI(iS(eS(e,"float32"),iI(t)),t.shape.length-1))}))}function Y_(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return dk((()=>{const r=eS(tI(function(e){const t=[cF(e.shape)];return IC(e,t)}(e)),"int32"),a=(t=_C(t,pF(),1-pF())).shape;return $_(IC(AI(r,a[a.length-1]),a),t,n)}))}function Q_(e,t){return dk((()=>{let n;return n=_C(t,pF(),1-pF()),n=iI(oS(n,kS(1,n))),CI(function(e,t){if(!Um(e.shape,t.shape))throw new bO("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(e.shape)," and ").concat(JSON.stringify(t.shape)));return dk((()=>{const n=VI(t),r=TI(CS(t));return rS(kS(n,iS(t,e)),sI(QC(r)))}))}(e,n),-1)}))}function Z_(e,t){return dk((()=>{const n=_C(e,pF(),1),r=_C(t,pF(),1);return lI(iS(e,iI(oS(n,r))),-1)}))}function J_(e,t){return dk((()=>{const n=H_(e,-1),r=H_(t,-1),a=iS(n,r);return TI(lI(a,-1))}))}U_.constructors={};const eD={meanSquaredError:G_,meanAbsoluteError:q_,meanAbsolutePercentageError:K_,meanSquaredLogarithmicError:X_,squaredHinge:function(e,t){return dk((()=>{const n=TS(0,kS(1,iS(e,t)));return CI(IF(n),-1)}))},hinge:function(e,t){return dk((()=>{const n=TS(0,kS(1,iS(e,t)));return CI(n,-1)}))},categoricalHinge:function(e,t){return dk((()=>{const n=lI(iS(e,t),-1),r=cI(iS(kS(1,e),t),-1);return TS(0,rS(1,kS(r,n)))}))},logcosh:function(e,t){return dk((()=>{const n=Math.log(2),r=kS(t,e),a=kS(rS(r,JI(iS(-2,r))),n);return CI(a,-1)}))},categoricalCrossentropy:$_,sparseCategoricalCrossentropy:Y_,binaryCrossentropy:Q_,kullbackLeiblerDivergence:Z_,poisson:function(e,t){return dk((()=>{const n=iI(rS(pF(),t));return CI(kS(t,iS(e,n)),-1)}))},cosineProximity:J_};function tD(e){if("string"===typeof e){if(e in eD)return eD[e];let t="Unknown loss ".concat(e);throw e.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss ".concat(e,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new bO(t)}return e}function nD(e,t){return dk((()=>{const n=iS(.5,_I(t)),r=fF(rI(t,n),e.dtype);return CI($C(e,r),-1)}))}function rD(e,t){return dk((()=>fF($C(lC(e,-1),lC(t,-1)),"float32")))}function aD(e,t){return dk((()=>eS(lI(xI($C(e,1),$C(t,1))),"float32")))}function oD(e,t){return Q_(e,t)}function iD(e,t){return e.rank===t.rank&&(e=tE(e,[e.rank-1])),(t=lC(t,-1)).dtype!==e.dtype&&(t=eS(t,e.dtype)),eS($C(e,t),"float32")}const sD=$_,cD=Y_,lD={binaryAccuracy:nD,categoricalAccuracy:rD,precision:function(e,t){return dk((()=>{const n=aD(e,t),r=function(e,t){return dk((()=>eS(lI(xI($C(e,0),$C(t,1))),"float32")))}(e,t),a=rS(n,r);return eS(cE(rI(a,0),oS(n,a),0),"float32")}))},categoricalCrossentropy:sD,sparseCategoricalCrossentropy:cD,mse:G_,MSE:G_,mae:q_,MAE:q_,mape:K_,MAPE:K_,cosine:J_};function uD(e){if("string"===typeof e&&e in lD)return lD[e];if("string"!==typeof e&&null!=e)return e;throw new bO("Unknown metric ".concat(e))}function dD(e){if(SO(null!==e,"Unknown LossOrMetricFn ".concat(e)),"string"===typeof e)return e;{let t;for(const n of Object.keys(eD))if(eD[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(lD))if(lD[n]===e){t=n;break}return void 0!==t?t:e.name}}const hD=1048576;function pD(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!fD(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>hD&&console.warn('User-defined metadata of model "'.concat(t,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(hD,"."))}}function fD(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!fD(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!fD(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function gD(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(e){let t=!0;const n=[],r=[];for(const a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(const a of e.layers){let e=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),o=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!a){o.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),mD(o,n,r),r("=".repeat(t));const s=e.layers;for(let u=0;u<s.length;++u)a?vD(s[u],n,r):bD(s[u],n,i,r),r((u===s.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const c=function(e){let t;t=null!=e.collectedTrainableWeights?n_(e.collectedTrainableWeights):n_(e.trainableWeights);return t}(e),l=n_(e.nonTrainableWeights);r("Total params: ".concat(c+l)),r("Trainable params: ".concat(c)),r("Non-trainable params: ".concat(l)),r("_".repeat(t))}function mD(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function vD(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(g0){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(g0){r="multiple"}const o=e.name,i=e.getClassName();mD(["".concat(o," (").concat(i,")"),a,r,e.countParams().toString()],t,n)}function bD(e,t,n,r){let a,o;try{o=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(g0){o="multiple"}try{a=JSON.stringify(e.outputShape)}catch(g0){a="multiple"}const i=[];for(const u of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let e=0;e<u.inboundLayers.length;++e){const t=u.inboundLayers[e].name,n=u.nodeIndices[e],r=u.tensorIndices[e];i.push("".concat(t,"[").concat(n,"][").concat(r,"]"))}const s=e.name,c=e.getClassName(),l=0===i.length?"":i[0];mD(["".concat(s," (").concat(c,")"),o,a,e.countParams().toString(),l],t,r);for(let u=1;u<i.length;++u)mD(["","","","",i[u]],t,r)}function yD(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function xD(e,t){if(null===e)return null;if("string"===typeof e)return TO(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];yD(t,a,r)?n.push(r):n.push(xD(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"===typeof r)t[n]=r;else{const e=TO(n);t[e]=xD(r,e)}}return t}}function wD(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return NO(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];yD(t,a,r)?n.push(r):n.push(wD(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],a=NO(n);t[a]="name"!==n&&"className"!==n||"string"!==typeof r?wD(r,n):r}return t}}const kD="4.20.0";class SD extends h_{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=HO(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],DO(this.inputs).length!==this.inputs.length)throw new bO("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((e=>e.name))));DO(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((e=>e.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const v of this.outputs){const e=v.sourceLayer,t=v.nodeIndex,n=v.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const v of this.inputs){const e=v.sourceLayer,t=v.nodeIndex,n=v.tensorIndex;SO(0===t,"input layer has >1 nodes"),SO(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let v=0;v<this.inputLayers.length;v++){const t=this.inputLayers[v];if(!(t instanceof f_))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(e.inputs,". ")+"Input ".concat(v," (0-based) originates ")+"from layer type ".concat(t.getClassName(),"."));this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const v of this.outputLayers)this.outputNames.push(v.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},a={},o={},i=[],s=(e,t,n,r,a,c)=>{null!=r&&null!=a&&null!=c||(r=e.sourceLayer,a=e.nodeIndex,c=e.tensorIndex);const l=r.inboundNodes[a];if(-1!==n.indexOf(l))throw new vO("The tensor ".concat(e.name,' at layer "').concat(r.name,'" ')+"is part of a cycle.");if(-1!==t.indexOf(l))return;this.containerNodes.add(SD.nodeKey(r,a)),r.id in o||(o[r.id]=Object.keys(o).length),-1===n.indexOf(l)&&n.push(l);const u=l.inboundLayers.length;for(let o=0;o<u;o++){const e=l.inputTensors[o],r=l.inboundLayers[o],a=l.nodeIndices[o],i=l.tensorIndices[o];s(e,t,n,r,a,i)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);i.push(l)},c=[],l=[];for(const v of this.outputs)s(v,c,l);const u=i.slice().reverse();for(const v of u){n[v.id]=v,v.id in t||(t[v.id]=0);let e=t[v.id];const o=null==r[v.outboundLayer.id]?0:r[v.outboundLayer.id];e=Math.max(e,o),r[v.outboundLayer.id]=e,a[v.outboundLayer.id]=v.outboundLayer,t[v.id]=e;for(let r=0;r<v.inboundLayers.length;r++){const a=v.inboundLayers[r],o=v.nodeIndices[r],i=a.inboundNodes[o],s=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,s),n[i.id]=i}}const d={};for(const v in t){const e=t[v];e in d||(d[e]=[]),d[e].push(n[v])}const h={};for(const v in r){const e=r[v];e in h||(h[e]=[]),h[e].push(a[v])}let p=Object.keys(h).map((e=>parseInt(e,10))).sort(_O);this.layers=[];for(const v of p){const e=h[v];e.sort(((e,t)=>{const n=o[e.id],r=o[t.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof SD&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=h,p=Object.keys(d).map((e=>parseInt(e,10))).sort(_O);const f=this.inputs.slice(),g=[];for(const v of p)for(const e of d[v]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new vO("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(t.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(g));for(const t of e.outputTensors)f.push(t);g.push(t.name)}}this.nodesByDepth=d;const m=this.layers.map((e=>e.name));for(const v of m){const e=m.filter((e=>e===v)).length;if(1!==e)throw new vO('The name "'.concat(v,'" is used ').concat(e," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new u_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new bO("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const a=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);a&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const o=a?"".concat(t.name.split("/").slice(0,-1).join("/")+"/").concat(e):t.originalName;if(null!=n[o])throw new bO("Duplicate weight name: ".concat(o));n[o]=t,r++}const o=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])o.push([n[r],e[i]]);else if(t)throw new bO("Provided weight data has no target variable: ".concat(i));delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new bO("".concat(e.length," of ").concat(r," weights are not set: ")+"".concat(e))}i_(o)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers ".concat(kD),t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=wD(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return dk((()=>{e=EO(e);const n=new g_;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return b_(this.outputs,n,t)}))}computeMask(e,t){return dk((()=>{let n;return e=EO(e),n=null==t?kO(null,e.length):EO(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=JF(e);if(t.length!==this.inputLayers.length)throw new bO("Invalid inputShape argument ".concat(e,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(_O);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const r=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],a=t.nodeIndices[i],o=t.tensorIndices[i],s=n["".concat(e.name,"_").concat(a,"_").concat(o)];r.push(s)}const a=JF(e.computeOutputShape(IO(r))),o=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++){n["".concat(e.name,"_").concat(o,"_").concat(t)]=a[t]}}}const a=[],o=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r="".concat(e.name,"_").concat(t,"_").concat(n);o.push(r)}for(let i=0;i<o.length;i++){const e=o[i];SO(e in n),a.push(n[e])}return IO(a)}runInternalGraph(e,t){null==t&&(t=kO(null,e.length));const n={};for(let s=0;s<this.inputs.length;++s){const r=this.inputs[s],a=e[s],o=t[s];n[r.id]=[a,o]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(_O);for(const s of r){const e=this.nodesByDepth[s];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,o=new Array;for(const t of r)t.id in n&&o.push(n[t.id]);if(o.length===r.length){let r,i,s,c,l={};if(null!=t.callArgs&&(l=t.callArgs),1===o.length){const[t,n]=o[0];null==l.mask&&(l.mask=n),s=EO(e.call(t,l)),c=EO(e.computeMask(t,n)),r=[t],i=[n]}else r=o.map((e=>e[0])),i=o.map((e=>e[1])),null==l.mask&&(l.mask=i),s=EO(e.call(r,l)),c=EO(e.computeMask(r,i));if(e.activityRegularizer)throw new yO("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){const t=a[e],r=s[e],o=c[e];n[t.id]=[r,o]}}}}const a=[],o=[],i=[];for(const s of this.outputs){SO(s.id in n,"Could not compute output ".concat(s.name," : ").concat(s.id));const[e,t]=n[s.id];i.push(e.shape),a.push(e),o.push(t)}return[a,o,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof SD?1:0;for(let e=0;e<r.inboundNodes.length;e++){const a=SD.nodeKey(r,e);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new bO("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new bO("No such layer: ".concat(e))}findLayer(e){if(this.layers.length<=e)throw new bO("Was asked to retrieve layer at index ".concat(e,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[e]}calculateLosses(){return dk((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=SD.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const o of this.layers){const e=o.getClassName(),r=o.getConfig(),a=[];for(let n=0;n<o.inboundNodes.length;n++){const e=o.inboundNodes[n],r=SD.nodeKey(o,n);let i={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(g0){console.warn("Layer ".concat(o.name," was passed ")+"non-serializable keyword arguments: "+"".concat(e.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),i={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const a=e.inboundLayers[r],o=e.nodeIndices[r],s=e.tensorIndices[r];let c=t[SD.nodeKey(a,o)];null==c&&(c=0),n.push([a.name,c,s,i])}a.push(n)}}}const i={};i.name=o.name,i.className=e,i.config=r,i.inboundNodes=a,n.push(i)}e.layers=n;const r=[];for(let o=0;o<this.inputLayers.length;o++){const e=this.inputLayers[o],n=this.inputLayersNodeIndices[o],a=SD.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let i=t[a];null!==i&&void 0!==i||(i=0);const s=this.inputLayersTensorIndices[o];r.push([e.name,i,s])}e.inputLayers=r;const a=[];for(let o=0;o<this.outputLayers.length;o++){const e=this.outputLayers[o],n=this.outputLayersNodeIndices[o],r=SD.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let i=t[r];null!==i&&void 0!==i||(i=0);const s=this.outputLayersTensorIndices[o];a.push([e.name,i,s])}return e.outputLayers=a,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function o(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function i(e,t){const n=[];let a;for(const i of t){const s=i[0],c=i[1],l=i[2];if(a=null==i[3]?{}:i[3],!(s in r))return void o(e,t);const u=r[s];if(u.inboundNodes.length<=c)return void o(e,t);const d=u.inboundNodes[c];n.push(d.outputTensors[l])}n.length>0&&e.apply(IO(n),a)}function s(e){const a=e.name,i=j_(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[a]=i;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new bO("Corrupted configuration, expected array for nodeData: ".concat(e));o(i,e)}))}const c=t.name,l=t.layers;for(const f of l)s(f);for(;!MO(a);)for(const e of l){const t=r[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)i(t,n)}}const u=[],d=[],h=t.inputLayers;for(const f of h){const e=f[0],t=f[1],n=f[2];SO(e in r);const a=r[e].inboundNodes[t].outputTensors;u.push(a[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];SO(e in r);const a=r[e].inboundNodes[t].outputTensors;d.push(a[n])}return new e({inputs:u,outputs:d,name:c})}get stateful(){if(this._stateful)throw new bO("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){dk((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function CD(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error("Provided ".concat(n," is an array of ").concat(e.length," ")+"element(s), but the model has ".concat(r," outputs. ")+"Make sure a set of weights is provided for each model output.");return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error("The model has multiple (".concat(r,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(r," elements or an object with ").concat(t," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(e)))}function ID(e,t){return CD(e,t,"classWeight")}async function ED(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=dk((()=>{if(1===e.shape.length)return tS(e);if(2===e.shape.length){if(e.shape[1]>1){return lC(e,1)}if(1===e.shape[1])return IC(e,[e.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),r=Array.from(await t.data());hk(t);const a=[];return r.forEach((e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(e," exists in the data but not in ")+"classWeight");a.push(n[e])})),aE(a,"float32")}return null}function ND(e,t){return iS(e,t)}function TD(e,t){let n,r;const a=t;n=a.xs,r=a.ys,Lm(null!=n&&null!=r,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(t)));const o=RD("input",e.inputNames,n),i=RD("output",e.outputNames,r),s=o[0].shape[0];Lm(o.length===e.inputs.length,(()=>"LayersModel has ".concat(e.inputs.length," inputs, but the dataset ")+"provides ".concat(o.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(e.inputNames),")"))),Lm(i.length===e.outputs.length,(()=>"LayersModel has ".concat(e.outputs.length," outputs, but the dataset ")+"provides ".concat(i.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(e.outputNames),")")));for(let c=0;c<o.length;c++)Lm(o[c].shape[0]===s,(()=>"Batch size mismatch: input "+"".concat(e.inputNames[c]," has ").concat(o[c].shape[0],"; ")+"expected  ".concat(s," based on input ").concat(e.inputNames[0],".")));for(let c=0;c<i.length;c++)Lm(i[c].shape[0]===s,(()=>"Batch size mismatch: output "+"".concat(e.outputNames[c]," has ").concat(i[c].shape[0],"; ")+"expected  ".concat(s," based on input ").concat(e.inputNames[0],".")));return{xs:o,ys:i}}function RD(e,t,n){if(n instanceof Ew)return[n];if(Array.isArray(n))return Lm(n.length===t.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(t.length," to match the ").concat(e," keys ").concat(t,"."))),n;{const r=[];for(const a of t){if(null==n[a])throw new bO("The feature data generated by the dataset lacks the required "+"".concat(e," key '").concat(a,"'."));r.push(n[a])}return r}}async function AD(e,t,n){const r=null!=n.batchesPerEpoch;if(Lm(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Lm(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Lm(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),Lm(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),Lm(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const a=null!=n.validationData;let o,i;if(a)if(OD(n.validationData))Lm(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const e=function(e){if(3===e.length)throw new yO("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);o=e.xs,i=e.ys}const s=e.makeTrainFunction(),c=e.getDedupedMetricsNames();let l;l=a?c.slice().concat(c.map((e=>"val_"+e))):c.slice();const u=W_(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=V_(u,d,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,a,l);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,g=await t.iterator();for(;f<n.epochs;){const l={};await h.onEpochBegin(f);let u=0,d=0;for(r||(g=await t.iterator());!r||u<n.batchesPerEpoch;){const t=await g.next();if(r&&t.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:a}=TD(e,t.value),o={};o.batch=d,o.size=r[0].shape[0],await h.onBatchBegin(d,o);const i=[];if(null!=n.classWeight){const t=ID(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await ED(a[e],null,t[e]))}const l=r.concat(a).concat(i),p=s(l);hk(l);for(let e=0;e<c.length;++e){const t=c[e],n=p[e];o[t]=n,pk(n)}await h.onBatchEnd(d,o),__(o),d++,u++}if(r?u>=n.batchesPerEpoch:t.done){if(a){let t;t=OD(n.validationData)?EO(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):EO(e.evaluate(o,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l["val_".concat(e.metricsNames[n])]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,l),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function OD(e){return"function"===typeof e.iterator}function FD(e){Lm(e>0&&Number.isInteger(e),(()=>"batchSize is required to be a positive integer, but got ".concat(e)))}function _D(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>mF(e,t,n-t))):mF(e,t,n-t)}function DD(e,t){return dk((()=>null==e?null:Array.isArray(e)?e.map((e=>DD(e,t))):CF(e,"int32"===t.dtype?t:eS(t,"int32"))))}function MD(e,t){const n=[];let r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function PD(e){const t=[];e instanceof Ew&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(gF(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function LD(e,t){if(null==e)return;const n=[];if(t instanceof Ew)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const a in t){const e=t[a];n.push(e.id)}const r=[];if(e instanceof Ew)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const a in e){const t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function zD(e){return Array.isArray(e)}function BD(e){return!function(e){return e instanceof Ew}(e)&&!zD(e)}function WD(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(zD(e)&&e.length>0)t=!0;else if(BD(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new bO("Error when checking model ".concat(o," expected no data, ")+"but got ".concat(e))}return[]}if(null==e)return t.map((e=>null));if(BD(e)){r=[];for(const n of t){if(null==e[n])throw new bO('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(t));r.push(e[n])}}else if(zD(e)){if(e.length!==t.length)throw new bO("Error when checking model ".concat(o,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(t.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(e));r=e}else{if(t.length>1)throw new bO("The model ".concat(o," expects ").concat(t.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(e.shape));r=[e]}if(r=PD(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new bO("Error when checking ".concat(o,": expected ").concat(t[i]," ")+"to have ".concat(n[i].length," dimension(s). but got array with ")+"shape ".concat(e.shape));for(let t=0;t<n[i].length;++t){if(0===t&&!a)continue;const r=e.shape[t],s=n[i][t];if(null!=s&&s>=0&&r!==s)throw new bO("".concat(o," expected a batch of elements where each ")+"example has shape [".concat(n[i].slice(1,n[i].length),"] ")+"(i.e.,tensor shape [*,".concat(n[i].slice(1,n[i].length),"])")+" but the ".concat(o," received an input with ").concat(e.shape[0])+" examples, each with shape [".concat(e.shape.slice(1,e.shape.length),"]")+" (tensor shape [".concat(e.shape,"])"))}}return r}function UD(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new bO("Error when checking model ".concat(o,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(t.length," Tensor(s),")+" but instead got ".concat(e.length," Tensors(s)."));r=e}else{if(t.length>1)throw new bO("The model expects ".concat(t.length," ").concat(o," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(e.shape),"."));r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new bO("Error when checking ".concat(o,": expected ").concat(t[i]," ")+"to have ".concat(n[i].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(e.shape)));for(let r=0;r<n[i].length;++r){if(0===r&&!a)continue;const s=e.shape[r],c=n[i][r];if(null!=c&&c!==s)throw new bO("Error when checking ".concat(o,": expected ")+"".concat(t[i]," to have shape ").concat(JSON.stringify(n[i])," but ")+"got array with shape ".concat(JSON.stringify(e.shape),"."))}}}class VD extends SD{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new bO("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");gD(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>fN.adagrad(.01),Adadelta:()=>fN.adadelta(1,.95,pF()),Adam:()=>fN.adam(.001,.9,.999,pF()),Adamax:()=>fN.adamax(.002,.9,.999,pF(),0),RMSProp:()=>fN.rmsprop(.001,.9,0,pF()),SGD:()=>fN.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new bO("Unknown Optimizer ".concat(e))}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof vS))throw new bO("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new bO("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(e.loss,"."));const n=e.loss;t=n.map((e=>tD(e)))}else{const n=tD(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new bO('Unknown entry in loss dictionary: "'.concat(t,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==e.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),t.push(tD(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const e=this.internalOutputShapes[o],t=this.outputNames[o];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[o])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nF("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(e));n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};nF("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,o;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let a;1===t[t.length-1]||this.lossFunctions[e]===Q_?-1!==["accuracy","acc"].indexOf(i)?r=nD:-1!==["crossentropy","ce"].indexOf(i)&&(r=oD):this.lossFunctions[e]===Y_?-1!==["accuracy","acc"].indexOf(i)?r=iD:-1!==["crossentropy","ce"].indexOf(i)&&(r=cD):-1!==["accuracy","acc"].indexOf(i)?r=rD:-1!==["crossentropy","ce"].indexOf(i)&&(r=sD),-1!==["accuracy","acc"].indexOf(i)?a="acc":-1!==["crossentropy","ce"].indexOf(i)&&(a="ce"),o=r,n=""+a}else{const e=uD(i);o=e,n=""+dD(i)}let t;nF(n,(()=>{t=o})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;FD(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const e=a[0].concat(a[1]);this.makeTestFunction();const t=this.testFunction;return IO(this.testLoop(t,e,r,n.verbose,n.steps))}finally{LD(a[0],e),LD(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,a=e.testFunction;let o=[];if(n.verbose>0)throw new yO("Verbose mode is not implemented yet.");Lm(!r||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const i="function"===typeof t.next?t:await t.iterator();let s=0,c=0;for(;!r||c<n.batches;){const t=await i.next();if(o=dk((()=>{if(t.value){const{xs:n,ys:r}=TD(e,t.value),i=n.concat(r),l=dk((()=>a(i)));if(hk(i),0===c)for(let e=0;e<l.length;++e)o.push(dS(0));const u=i[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=o[e];o[e]=dk((()=>rS(o[e],iS(u,t)))),c>0&&hk(n)}hk(l),s+=u,++c}return o})),t.done){r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let l=0;l<o.length;++l){const e=o[l];o[l]=oS(o[l],s),hk(e)}return IO(o)}(this,e,t)}checkNumSamples(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new bO("If ".concat(a," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(t))}else{if(null==e)throw new bO("Either the input data should have a defined shape, or "+"".concat(a," shoud be specified."));r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new bO("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),o=new g_;if(e instanceof Ew&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new bO("The number of inputs provided (".concat(e.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let t=0;t<this.inputs.length;++t)o.add(this.inputs[t],e[t])}else for(const s of this.inputs){const t=e[s.name];if(null==t)throw new bO("No value is provided for the model's input ".concat(s.name));o.add(s,t)}const i=b_(a,o);return n?i:i[0]}retrieveSymbolicTensors(e){const t=kO(null,e.length);let n=e.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],o=a.map((e=>e.name));for(let r=0;r<e.length;++r){const i=o.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new bO("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return dk((()=>{const r=this.checkNumSamples(e);if(n)throw new yO("Verbose predictLoop() is not implemented yet.");const a=MD(r,t),o=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t){dk((()=>{const n=a[t][0],r=a[t][1],o=_D(e,n,r),i=[];if(Array.isArray(o))for(let e=0;e<o.length;++e)i.push({key:this.inputs[e],value:o[e]});else i.push({key:this.inputs[0],value:o});const s=new g_(i);return b_(this.outputs,s)})).forEach(((e,t)=>o[t].push(e)))}return IO(o.map((e=>DC(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=PD(e);UD(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return FD(e),this.predictLoop(n,e)}finally{LD(n,e)}}predictOnBatch(e){UD(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new vO("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const e=this.feedOutputShapes[a];this.feedLossFns[a]===Y_?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t,n){const r=DO(e.map((e=>e.shape[0])));r.sort();const a=DO(t.map((e=>e.shape[0])));if(a.sort(),r.length>1)throw new bO("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((e=>e.shape)))));if(a.length>1)throw new bO("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((e=>e.shape)))));if(r.length>0&&a.length>0&&!Um(r,a))throw new bO("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(r[0]," input sample(s) and ").concat(a[0]," target ")+"sample(s).")}(e=WD(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=WD(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){const r=[G_,Q_,$_];for(let a=0;a<e.length;++a){const o=e[a],i=t[a],s=n[a];if(null!=i){if(i===$_&&1===o.shape[o.shape.length-1])throw new bO("You are passing a target array of shape ".concat(o.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(i)){const e=o.shape.slice(1),t=s.slice(1);for(let n=0;n<e.length;++n){const r=e[n],a=t[n];if(null!=a&&r!==a)throw new bO("A target Tensor with shape ".concat(o.shape," was passed for an ")+"output of shape ".concat(s,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new bO("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(e[0].shape[0]," sample(s)."));return[e,t]}async standardizeUserData(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],o=arguments.length>5?arguments[5]:void 0;const[i,s]=this.standardizeUserDataXY(e,t,a,o);if(null!=n)throw new Error("sample weight is not supported yet.");let c=null;if(null!=r){const e=ID(r,this.outputNames);c=[];for(let t=0;t<e.length;++t)c.push(await ED(s[t],null,e[t]))}return[i,s,c]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return dk((()=>{const o=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new yO("Verbose mode is not implemented yet.");if(null!=a)throw new yO("steps mode in testLoop() is not implemented yet");{const r=MD(o,n),a=aE(dF(0,o));for(let n=0;n<r.length;++n){const o=r[n][0],s=r[n][1],c=mF(a,o,s-o),l=DD(t,c),u=e(l);if(0===n)for(let e=0;e<u.length;++e)i.push(dS(0));for(let e=0;e<u.length;++e){const t=u[e];i[e]=rS(i[e],iS(s-o,t))}}for(let e=0;e<i.length;++e)i[e]=oS(i[e],o)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let a=r;if(CO(e,r)>1){const t=CO(e.slice(0,n),r);a+="_".concat(t)}t.push(a)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),o=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new g_(e),s=b_(this.outputs,i,{training:!0});let c;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],s[n]);null!=a[n]&&(e=ND(e,a[n]));const o=CI(e);t.push(o),c=0===n?e:rS(c,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=CI(t(r[a],s[a]))}pk(e),o.push(e)}return c=CI(c),this.calculateLosses().forEach((e=>{c=rS(c,e)})),c}),!0,i)].concat(o)}}makeTestFunction(){this.testFunction=e=>dk((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let e=0;e<this.inputs.length;++e)o.push({key:this.inputs[e],value:r[e]});const i=new g_(o),s=b_(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],o=CI(r(a[e],s[e]));n=0===e?o:rS(n,o),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],o=CI(n(a[r],s[r]));t.push(o)}return t}))}async fit(e,t){let n,r,a,o,i,s,c,l,u,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const h=null==d.batchSize?32:d.batchSize;FD(h);const p=!1,f=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,p,h);n=f[0],r=f[1],u=f[2];let g,m=!1;if(null!=d.validationData&&d.validationData.length>0){if(m=!0,2!==d.validationData.length)throw 3===d.validationData.length?new yO("validationData including sample weights is not supported yet."):new bO("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(d.validationData," is invalid."));i=d.validationData[0],s=d.validationData[1];const e=!0,t=await this.standardizeUserData(i,s,null,null,e,h);c=t[0],l=t[1],g=c.concat(l)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){m=!0;const e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];c=_D(n,e,t),a=n,n=_D(n,0,e),l=_D(r,e,t),o=r,r=_D(r,0,e),g=c.concat(l)}else null!=d.validationSteps&&(m=!0);const v=n.concat(r).concat(u);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),y=this.getDedupedMetricsNames();let x,w;m?(this.makeTestFunction(),x=this.testFunction,w=y.slice().concat(y.map((e=>"val_"+e)))):(x=null,g=[],w=y.slice());const k=W_(d.callbacks,d.yieldEvery);return await this.fitLoop(b,v,y,h,d.epochs,d.verbose,k,x,g,d.shuffle,w,d.initialEpoch,null,null)}finally{this.isTraining=!1,LD(n,e),LD(r,t),LD(a,e),LD(o,t),LD(c,i),LD(l,s),null!=u&&hk(u)}}async fitLoop(e,t,n,r,a,o,i,s,c,l,u,d,h,p){null==r&&(r=32),null==a&&(a=1),null==l&&(l=!0),null==d&&(d=0);let f=!1;if(null!=s&&null!=c&&(f=!0),null!=p&&(f=!0,null==h))throw new bO("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,r,h,"steps_per_epoch");let m;null!=g&&(m=dF(0,g)),null==o&&(o=1);const{callbackList:v,history:b}=V_(i,o,a,d,g,h,r,f,u);v.setModel(this),this.history=b,await v.onTrainBegin(),this.stopTraining_=!1;for(let y=d;y<a;++y){await v.onEpochBegin(y);const a={};if(null!=h)throw new yO("stepsPerEpoch mode is not implemented yet.");{if("batch"===l)throw new yO("batch shuffling is not implemneted yet");l&&_m(m);const o=aE(m),i=MD(g,r);for(let l=0;l<i.length;++l){const u={};if(await v.onBatchBegin(l,u),dk((()=>{const d=i[l][0],h=i[l][1],p=mF(o,d,h-d);u.batch=l,u.size=h-d;const g=DD(t,p),m=e(g);for(let e=0;e<n.length;++e){const t=n[e],r=m[e];u[t]=r,pk(r)}if(l===i.length-1&&f){const e=this.testLoop(s,c,r);for(let t=0;t<n.length;++t){const r=n[t],o=e[t];pk(o),a["val_"+r]=o}}})),await v.onBatchEnd(l,u),__(u),this.stopTraining_)break}o.dispose()}if(await v.onEpochEnd(y,a),this.stopTraining_)break}return await v.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return AD(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],a=n[1],o=this.makeTrainFunction()(r.concat(a)),i=[];for(const s of o){const e=await s.data();i.push(e[0])}return hk(o),LD(n[0],e),LD(n[1],t),IO(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let o=0;o<r.length;++o)n&&!r[o].trainable||t.push({name:r[o].originalName,tensor:a[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=uk().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-uk().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=NO(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>NO(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=NO(n[r])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[NO(dD(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>NO(dD(e))));{const e={};for(const t in this.metrics)e[t]=NO(dD(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=j_(xD(e.optimizer_config));let n,r;if("string"===typeof e.loss)n=TO(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>TO(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=TO(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>TO(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=TO(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"===typeof e){const t=(n=e,Ik.getSaveHandlers(n));if(0===t.length)throw new bO("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new bO("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}var n;if(null==e.save)throw new bO("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await vk(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(kD),convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:n}=await vk(await this.optimizer.getWeights(),e);r.specs.push(...n),r.data=(o=[r.data,t],ck.join(o))}var o;if(null!=this.userDefinedMetadata){const e=!0;pD(this.userDefinedMetadata,this.name,e),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=r.data,a.weightSpecs=r.specs,e.save(a)}setUserDefinedMetadata(e){pD(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}VD.className="Model",mS(VD);class jD extends VD{}jD.className="Functional",mS(jD);class HD extends VD{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:HO("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new bO("Negative dimension size caused by adding layer "+"".concat(e.name," with input shape [")+"".concat(e.inboundNodes[0].inputTensors[0].shape,"]"))}add(e){const t=e instanceof HD||e instanceof VD;let n;if(t){if(n=e,1!==n.outputs.length)throw new bO("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new bO("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new bO("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new bO("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new f_({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new bO("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(e.name," ")+"which has ".concat(e.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new bO("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=p_(this.outputs[0])}this.inboundNodes=[],new u_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:kO(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(t_(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new VD({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new vO("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new vO("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new vO("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new vO("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new bO("Legacy serialization format not supported yet.");n=t}else Lm(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,a=t;const o=new e(a);if(!(o instanceof HD))throw new yO("Sequential.fromConfig called on non-Sequential input: ".concat(o));for(const i of n){const e=j_(i,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),o.add(e)}return o}set stopTraining(e){if(null==this.model)throw new bO("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new bO("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}HD.className="Sequential",mS(HD);class GD extends fS{getConfig(){return{}}}class qD extends GD{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new yO("Support for alpha values other than 1 (".concat(t,") is not implemented ")+"yet.");return XC(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}qD.className="elu",mS(qD);class KD extends GD{apply(e){return HI(e)}}KD.className="selu",mS(KD);class XD extends GD{apply(e){return VI(e)}}XD.className="relu",mS(XD);class $D extends GD{apply(e){return dk((()=>EI(6,VI(e))))}}$D.className="relu6",mS($D);class YD extends GD{apply(e){return e}}YD.className="linear",mS(YD);class QD extends GD{apply(e){return qI(e)}}QD.className="sigmoid",mS(QD);class ZD extends GD{apply(e){return function(e){return dk((()=>{const t=rS(.5,iS(.2,e));return _C(t,0,1)}))}(e)}}ZD.className="hardSigmoid",mS(ZD);class JD extends GD{apply(e){return JI(e)}}JD.className="softplus",mS(JD);class eM extends GD{apply(e){return function(e){return dk((()=>oS(e,rS(CS(e),1))))}(e)}}eM.className="softsign",mS(eM);class tM extends GD{apply(e){return rE(e)}}tM.className="tanh",mS(tM);class nM extends GD{apply(e){return ZI(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}nM.className="softmax",mS(nM);class rM extends GD{apply(e){return uI(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}rM.className="logSoftmax",mS(rM);class aM extends GD{apply(e){return dk((()=>dk((()=>{const t=Math.sqrt(2),n=iS(.5,rS(1,YC(oS(e,t))));return iS(e,n)}))))}}aM.className="gelu",mS(aM);class oM extends GD{apply(e){return dk((()=>iS(.5,iS(e,rS(1,rE(iS(sS(oS(2,Math.PI)),rS(e,iS(.044715,wS(e,3))))))))))}}oM.className="gelu_new",mS(oM);class iM extends GD{apply(e){return dk((()=>iS(e,rE(JI(e)))))}}iM.className="mish",mS(iM);class sM extends GD{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return dk((()=>iS(qI(iS(e,t)),e)))}}function cM(e){return e.getClassName()}function lM(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return FO(e,gS.getMap().classNameMap,t,"activation")}function uM(e){if(null==e){const e={className:"linear",config:{}};return lM(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},lM(t)}return e instanceof GD?e:lM(e)}function dM(e){if(null!=e&&"object"!==typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(e))}sM.className="swish",mS(sM);class hM extends fS{}class pM extends hM{constructor(e){super(),dM(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return dk((()=>{let t=OI([1]);return this.hasL1&&(t=rS(t,lI(iS(this.l1,CS(e))))),this.hasL2&&(t=rS(t,lI(iS(this.l2,IF(e))))),IC(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}pM.className="L1L2",mS(pM);const fM={l1l2:"L1L2"};function gM(e){return AO(e)}function mM(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return FO(e,gS.getMap().classNameMap,t,"regularizer")}function vM(e){if(null==e)return null;if("string"===typeof e){return mM({className:e in fM?fM[e]:e,config:{}})}return e instanceof hM?e:mM(e)}class bM extends h_{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=e_(e);let n=VI(e);return null!=this.maxValue&&(n=_C(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}bM.className="ReLU",mS(bM);class yM extends h_{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=e_(e);return oI(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}yM.className="LeakyReLU",mS(yM);class xM extends h_{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=QF(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=vM(e.alphaRegularizer),this.alphaConstraint=O_(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new bO("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(e.sharedAxes));this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=t_(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new s_({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=e_(e),MI(e,this.alpha.read())}getConfig(){const e={alphaInitializer:YF(this.alphaInitializer),alphaRegularizer:gM(this.alphaRegularizer),alphaConstraint:R_(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}xM.className="PReLU",mS(xM);class wM extends h_{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new yO("Non-default alpha value (".concat(e.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=e_(e);return XC(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}wM.className="ELU",mS(wM);class kM extends h_{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=e_(e);return iS(n,eS(rI(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}kM.className="ThresholdedReLU",mS(kM);class SM extends h_{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new nM).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return dk((()=>{let n=e_(e);const r=t.mask;if(null!=r){const e=iS(kS(FI(n.shape),eS(r,n.dtype)),dS(-1e9));n=rS(n,e)}return this.axis instanceof Array?this.axis.length>1?QC(kS(n,yI(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function CM(e,t,n){if("number"===typeof e)return kO(e,t);if(e.length!==t)throw new bO("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers.")+" Received: ".concat(e.length," elements."));for(let r=0;r<t;++r){const a=e[r];if(!sF(a))throw new bO("The ".concat(n," argument must be an integer or tuple of ").concat(t)+" integers. Received: ".concat(JSON.stringify(e)," including a")+" non-integer number ".concat(a))}return e}function IM(e,t,n,r){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function EM(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+uF([n-t,0]);else{if("same"!==r)throw new bO("Unsupport padding mode: ".concat(r,"."));e*=t}return e}function NM(e,t){return dk((()=>(QO(t),"channelsFirst"===t?dE(e,[0,2,3,1]):e)))}function TM(e,t){return dk((()=>(QO(t),"channelsFirst"===t?dE(e,[0,2,3,4,1]):e)))}function RM(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return dk((()=>{if(null==o&&(o="channelsLast"),QO(o),3!==e.shape.length)throw new bO("The input of a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead."));if(3!==t.shape.length)throw new bO("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new bO("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(n.shape.length," instead"));if("channelsFirst"===o&&(e=dE(e,[0,2,1])),"causal"===a)throw new yO("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let s=WC(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(s=NF(s,n)),s}))}function AM(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return dk((()=>{if(null==o&&(o="channelsLast"),QO(o),3!==e.rank&&4!==e.rank)throw new bO("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));if(3!==t.rank&&4!==t.rank)throw new bO("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));let c=NM(e,o);if("causal"===a)throw new yO("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=CE({x:c,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:s}),"channelsFirst"===o&&(c=dE(c,[0,3,1,2])),c}))}function OM(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return dk((()=>{if(null==o&&(o="channelsLast"),QO(o),4!==e.rank&&5!==e.rank)throw new bO("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(e.rank,"."));if(4!==t.rank&&5!==t.rank)throw new bO("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(e.rank,"."));let s=TM(e,o);if("causal"===a)throw new yO("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return s=jC(s,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(s=NF(s,n)),"channelsFirst"===o&&(s=dE(s,[0,4,1,2,3])),s}))}SM.className="Softmax",mS(SM);class FM extends h_{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",FM.verifyArgs(t),this.rank=e,zO(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new yO("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=CM(t.kernelSize,e,"kernelSize"),this.strides=CM(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,ZO(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,QO(this.dataFormat),this.activation=uM(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=QF(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=O_(t.biasConstraint),this.biasRegularizer=vM(t.biasRegularizer),this.activityRegularizer=vM(t.activityRegularizer),this.dilationRate=CM(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new bO("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new bO("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new bO("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(e){if(SO("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!LO(e.kernelSize,"number",1,3))throw new bO("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize),"."))}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:cM(this.activation),useBias:this.useBias,biasInitializer:YF(this.biasInitializer),biasRegularizer:gM(this.biasRegularizer),activityRegularizer:gM(this.activityRegularizer),biasConstraint:R_(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class _M extends FM{constructor(e,t){super(e,t),this.kernel=null,_M.verifyArgs(t),this.filters=t.filters,zO(this.filters,"filters"),this.kernelInitializer=QF(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=O_(t.kernelConstraint),this.kernelRegularizer=vM(t.kernelRegularizer)}build(e){e=t_(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new bO("The channel dimension of the input should be defined. "+"Found ".concat(e[t]));const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return dk((()=>{let t;e=e_(e);const n=null==this.bias?null:this.bias.read(),r=WO(this.activation.getClassName());if(null!=r&&2===this.rank)t=AM(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=RM(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=AM(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new yO("convolutions greater than 3D are not implemented yet.");t=OM(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=t_(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){const e=IM(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:YF(this.kernelInitializer),kernelRegularizer:gM(this.kernelRegularizer),kernelConstraint:R_(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new bO("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(e.filters)))}}class DM extends _M{constructor(e){super(2,e),DM.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!LO(e.kernelSize,"number",1,2))throw new bO("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize),"."))}}DM.className="Conv2D",mS(DM);class MM extends _M{constructor(e){super(3,e),MM.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new bO("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(e.kernelSize),"."))}}MM.className="Conv3D",mS(MM);class PM extends DM{constructor(e){if(super(e),this.inputSpec=[new s_({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new bO("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(4!==(e=t_(e)).length)throw new bO("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new bO("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new s_({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return dk((()=>{let t=e_(e);if(4!==t.shape.length)throw new bO("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,r=n[0];let a,o;"channelsFirst"===this.dataFormat?(a=2,o=3):(a=1,o=2);const i=n[a],s=n[o],c=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],d=this.strides[1],h=[r,EM(i,u,c,this.padding),EM(s,d,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=dE(t,[0,2,3,1]));let p=VC(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=dE(p,[0,3,1,2])),null!=this.bias&&(p=NF(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=t_(e)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const o=this.kernelSize[0],i=this.kernelSize[1],s=this.strides[0],c=this.strides[1];return t[n]=this.filters,t[r]=EM(t[r],s,o,this.padding),t[a]=EM(t[a],c,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}PM.className="Conv2DTranspose",mS(PM);class LM extends MM{constructor(e){if(super(e),this.inputSpec=[new s_({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new bO("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(5!==(e=t_(e)).length)throw new bO("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new bO("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new s_({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return dk((()=>{let t=e_(e);if(5!==t.shape.length)throw new bO("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,r=n[0];let a,o,i;"channelsFirst"===this.dataFormat?(i=2,a=3,o=4):(i=1,a=2,o=3);const s=n[i],c=n[a],l=n[o],u=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],g=this.strides[2],m=[r,EM(s,p,u,this.padding),EM(c,f,d,this.padding),EM(l,g,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=dE(t,[0,2,3,4,1]));let v=GC(t,this.kernel.read(),m,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(v=dE(v,[0,4,1,2,3])),null!==this.bias&&(v=NF(v,this.bias.read(),this.dataFormat)),null!==this.activation&&(v=this.activation.apply(v)),v}))}computeOutputShape(e){const t=(e=t_(e)).slice();let n,r,a,o;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,o=4):(n=4,r=1,a=2,o=3);const i=this.kernelSize[0],s=this.kernelSize[1],c=this.kernelSize[2],l=this.strides[0],u=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=EM(t[r],l,i,this.padding),t[a]=EM(t[a],u,s,this.padding),t[o]=EM(t[o],d,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}LM.className="Conv3DTranspose",mS(LM);class zM extends _M{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new bO("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new bO("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new bO("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(t.padding)));this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=QF(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=vM(t.depthwiseRegularizer),this.depthwiseConstraint=O_(t.depthwiseConstraint),this.pointwiseInitializer=QF(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=vM(t.pointwiseRegularizer),this.pointwiseConstraint=O_(t.pointwiseConstraint)}build(e){if((e=t_(e)).length<this.rank+2)throw new bO("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(e)));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new bO("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(e[t])));const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new s_({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return dk((()=>{let t;if(e=e_(e),1===this.rank)throw new yO("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=dE(e,[0,2,3,1])),t=GI(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=NF(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=dE(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=YF(this.depthwiseInitializer),e.pointwiseInitializer=YF(this.pointwiseInitializer),e.depthwiseRegularizer=gM(this.depthwiseRegularizer),e.pointwiseRegularizer=gM(this.pointwiseRegularizer),e.depthwiseConstraint=R_(this.depthwiseConstraint),e.pointwiseConstraint=R_(this.pointwiseConstraint),e}}zM.className="SeparableConv";class BM extends zM{constructor(e){super(2,e)}}BM.className="SeparableConv2D",mS(BM);class WM extends _M{constructor(e){super(1,e),WM.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!LO(e.kernelSize,"number",1,1))throw new bO("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(e.kernelSize),"."))}}WM.className="Conv1D",mS(WM);class UM extends h_{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return dk((()=>{if(e=e_(e),"channelsLast"===this.dataFormat){const t=bF(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return bF(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=bF(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return bF(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}UM.className="Cropping2D",mS(UM);class VM extends h_{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,QO(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,PO(qO,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return dk((()=>{let t=e_(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=dE(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?hN.resizeNearestNeighbor(t,[e,r]):hN.resizeBilinear(t,[e,r]);return dE(a,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?hN.resizeNearestNeighbor(t,[e,r]):hN.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}VM.className="UpSampling2D",mS(VM);class jM extends FM{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=QF(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=O_(e.depthwiseConstraint),this.depthwiseRegularizer=vM(e.depthwiseRegularizer)}build(e){if((e=t_(e)).length<4)throw new bO("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(e),"."));const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new bO("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(e[t],")."));const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return dk((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0;return dk((()=>{null==a&&(a="channelsLast"),QO(a);let i=NM(e,a);if(4!==e.rank)throw new bO("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));if(4!==t.rank)throw new bO("depthwiseKernel is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));return i=KC(i,t,n,"same"===r?"same":"valid","NHWC",o),"channelsFirst"===a&&(i=dE(i,[0,3,1,2])),i}))}(e=e_(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=NF(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=t_(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=IM(t,this.kernelSize[0],this.padding,this.strides[0]),o=IM(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,o]:[e[0],a,o,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=YF(this.depthwiseInitializer),e.depthwiseRegularizer=gM(this.depthwiseRegularizer),e.depthwiseConstraint=R_(this.depthwiseRegularizer),e}}function HM(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new bO("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function GM(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return dk((()=>{const c=t.shape.length;if(c<3)throw new bO("Input should be at least 3D, but is ".concat(c,"D."));const l=[1,0].concat(dF(2,c));if(t=dE(t,l),null!=o)throw new yO("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=eS(eS(a,"bool"),"float32"),a.rank===c-1&&(a=ZC(a,-1)),a=dE(a,l)),r&&(t=jI(t,0),null!=a&&(a=jI(a,0)));const u=[];let d,h=n;const p=t.shape[0],f=sE(t);let g,m;null!=a&&(g=sE(a));for(let t=0;t<p;++t){const n=f[t],r=dk((()=>e(n,h)));if(null==a)d=r[0],h=r[1];else{const e=dk((()=>{const e=g[t],n=kS(_I(e),e);return{output:rS(iS(r[0],e),iS(h[0],n)),newStates:h.map(((t,a)=>rS(iS(r[1][a],e),iS(t,n))))}}));d=e.output,h=e.newStates}s&&u.push(d)}if(s){m=nE(u,1)}return[d,m,h]}))}jM.className="DepthwiseConv2D",mS(jM);class qM extends h_{constructor(e){let t;if(super(e),null==e.cell)throw new bO("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new eP({cells:e.cell}):e.cell,null==t.stateSize)throw new bO("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new s_({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return dF(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){ZF(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return dk((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new yO("Constants support is not implemented in RNN yet.");ZF(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new s_({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Um(this.stateSpec.map((e=>e.shape[e.shape.length-1])),a))throw new bO("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=a.map((e=>new s_({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];dk((()=>{if(!this.stateful)throw new mO("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new bO("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>OI([n,e]))):this.states_=[OI([n,this.cell.stateSize])];else if(null==e)hk(this.states_),null!=this.keptStates&&(hk(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>OI([n,e]))):this.states_[0]=OI([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new bO("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));!0===t?this.keptStates.push(this.states_.slice()):hk(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,o=[n,a];if(!Um(r.shape,o))throw new bO("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(o,", received shape=").concat(r.shape));this.states_[t]=r}}this.states_=this.states_.map((e=>pk(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=HM(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let o=[],i=[];if(null!=n){t.initialState=n,o=o.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new s_({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,o=o.concat(r),this.numConstants=r.length);if(o[0]instanceof c_){const n=[e].concat(o),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const s=super.apply(n,t);return this.inputSpec=a,s}return super.apply(e,t)}call(e,t){return dk((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let a=null==t?null:t.initialState;e=e_(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==o)throw new bO("RNN Layer has ".concat(o," state(s) but was passed ")+"".concat(a.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},s=GM(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),c=s[0],l=s[1],u=s[2];this.stateful&&this.resetStates(u,r);const d=this.returnSequences?l:c;return this.returnState?[d].concat(u):d}))}getInitialState(e){return dk((()=>{let t=OI(e.shape);return t=lI(t,[1,2]),t=gF(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?wF(t,[1,e]):t)):this.cell.stateSize>1?[wF(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===qM.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=j_(t.cell,n);return new e(Object.assign(t,{cell:r}))}}qM.className="RNN",mS(qM);class KM extends h_{}class XM extends KM{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,zO(this.units,"units"),this.activation=uM(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=QF(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=QF(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=QF(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vM(e.kernelRegularizer),this.recurrentRegularizer=vM(e.recurrentRegularizer),this.biasRegularizer=vM(e.biasRegularizer),this.kernelConstraint=O_(e.kernelConstraint),this.recurrentConstraint=O_(e.recurrentConstraint),this.biasConstraint=O_(e.biasConstraint),this.dropout=lF([1,uF([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=lF([1,uF([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=t_(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return dk((()=>{if(2!==e.length)throw new bO("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length,"."));let n=e[1];e=e[0];const r=null!=t.training&&t.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=tP({ones:()=>_I(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=tP({ones:()=>_I(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=this.recurrentDropoutMask;a=SF(null!=o?iS(e,o):e,this.kernel.read()),null!=this.bias&&(a=NF(a,this.bias.read())),null!=i&&(n=iS(n,i));let s=rS(a,SF(n,this.recurrentKernel.read()));return null!=this.activation&&(s=this.activation.apply(s)),[s,s]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:cM(this.activation),useBias:this.useBias,kernelInitializer:YF(this.kernelInitializer),recurrentInitializer:YF(this.recurrentInitializer),biasInitializer:YF(this.biasInitializer),kernelRegularizer:gM(this.kernelRegularizer),recurrentRegularizer:gM(this.recurrentRegularizer),biasRegularizer:gM(this.biasRegularizer),activityRegularizer:gM(this.activityRegularizer),kernelConstraint:R_(this.kernelConstraint),recurrentConstraint:R_(this.recurrentConstraint),biasConstraint:R_(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}XM.className="SimpleRNNCell",mS(XM);class $M extends qM{constructor(e){e.cell=new XM(e),super(e)}call(e,t){return dk((()=>{null!=this.cell.dropoutMask&&(hk(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hk(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}}$M.className="SimpleRNN",mS($M);class YM extends KM{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new bO("GRUCell does not support reset_after parameter set to true.");this.units=e.units,zO(this.units,"units"),this.activation=uM(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=uM(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=QF(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=QF(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=QF(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vM(e.kernelRegularizer),this.recurrentRegularizer=vM(e.recurrentRegularizer),this.biasRegularizer=vM(e.biasRegularizer),this.kernelConstraint=O_(e.kernelConstraint),this.recurrentConstraint=O_(e.recurrentConstraint),this.biasConstraint=O_(e.biasConstraint),this.dropout=lF([1,uF([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=lF([1,uF([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=t_(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return dk((()=>{if(2!==e.length)throw new bO("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=tP({ones:()=>_I(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=tP({ones:()=>_I(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let i,s,c;0<this.dropout&&this.dropout<1&&(e=iS(e,a[0]));let l=SF(e,this.kernel.read());this.useBias&&(l=NF(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=iS(r,o[0]));const u=this.recurrentKernel.read(),[d,h]=eE(u,[2*this.units,this.units],u.rank-1),p=SF(r,d),[f,g,m]=eE(l,3,l.rank-1),[v,b]=eE(p,2,p.rank-1);i=this.recurrentActivation.apply(rS(f,v)),s=this.recurrentActivation.apply(rS(g,b));const y=SF(iS(s,r),h);c=this.activation.apply(rS(m,y));const x=rS(iS(i,r),iS(rS(1,TI(i)),c));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:cM(this.activation),recurrentActivation:cM(this.recurrentActivation),useBias:this.useBias,kernelInitializer:YF(this.kernelInitializer),recurrentInitializer:YF(this.recurrentInitializer),biasInitializer:YF(this.biasInitializer),kernelRegularizer:gM(this.kernelRegularizer),recurrentRegularizer:gM(this.recurrentRegularizer),biasRegularizer:gM(this.biasRegularizer),activityRegularizer:gM(this.activityRegularizer),kernelConstraint:R_(this.kernelConstraint),recurrentConstraint:R_(this.recurrentConstraint),biasConstraint:R_(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}YM.className="GRUCell",mS(YM);class QM extends qM{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new YM(e),super(e)}call(e,t){return dk((()=>{null!=this.cell.dropoutMask&&(hk(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hk(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}QM.className="GRU",mS(QM);class ZM extends KM{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,zO(this.units,"units"),this.activation=uM(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=uM(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=QF(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=QF(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=QF(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=vM(e.kernelRegularizer),this.recurrentRegularizer=vM(e.recurrentRegularizer),this.biasRegularizer=vM(e.biasRegularizer),this.kernelConstraint=O_(e.kernelConstraint),this.recurrentConstraint=O_(e.recurrentConstraint),this.biasConstraint=O_(e.biasConstraint),this.dropout=lF([1,uF([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=lF([1,uF([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=t_(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends FF{apply(t,r){const a=e.apply([n]),o=(new DF).apply([n]),i=e.apply([2*n]);return xF(xF(a,o),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return dk((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new bO("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));let r=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=tP({ones:()=>_I(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=tP({ones:()=>_I(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=this.recurrentDropoutMask;let s,c,l,u;0<this.dropout&&this.dropout<1&&(e=iS(e,o[0]));let d=SF(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=iS(r,i[0])),d=rS(d,SF(r,this.recurrentKernel.read())),this.useBias&&(d=NF(d,this.bias.read()));const[h,p,f,g]=eE(d,4,d.rank-1);s=this.recurrentActivation.apply(h),c=this.recurrentActivation.apply(p),l=rS(iS(c,a),iS(s,this.activation.apply(f))),u=this.recurrentActivation.apply(g);const m=iS(u,this.activation.apply(l));return[m,m,l]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:cM(this.activation),recurrentActivation:cM(this.recurrentActivation),useBias:this.useBias,kernelInitializer:YF(this.kernelInitializer),recurrentInitializer:YF(this.recurrentInitializer),biasInitializer:YF(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:gM(this.kernelRegularizer),recurrentRegularizer:gM(this.recurrentRegularizer),biasRegularizer:gM(this.biasRegularizer),activityRegularizer:gM(this.activityRegularizer),kernelConstraint:R_(this.kernelConstraint),recurrentConstraint:R_(this.recurrentConstraint),biasConstraint:R_(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}ZM.className="LSTMCell",mS(ZM);class JM extends qM{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ZM(e),super(e)}call(e,t){return dk((()=>{null!=this.cell.dropoutMask&&(hk(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hk(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}JM.className="LSTM",mS(JM);class eP extends KM{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return dk((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let o;for(let i=0;i<this.cells.length;++i){const s=this.cells[i];n=r[i],o=0===i?[e[0]].concat(n):[o[0]].concat(n),o=s.call(o,t),a.push(o.slice(1))}n=[];for(const e of a.slice().reverse())n.push(...e);return[o[0]].concat(n)}))}build(e){let t;ZF(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{nF("RNNCell_".concat(r),(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of t.cells)r.push(j_(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return o_(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}i_(t)}}function tP(e){const{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:o}=e,i=()=>null!=o?o(t(),n):TF(t(),n),s=()=>RF(i,t,r);if(!a||a<=1)return pk(s().clone());return Array(a).fill(void 0).map(s).map((e=>pk(e.clone())))}eP.className="StackedRNNCells",mS(eP);var nP=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};class rP extends qM{constructor(e){if(e.unroll)throw new yO("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new yO("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new s_({ndim:5})]}call(e,t){return dk((()=>{if(null!=this.cell.dropoutMask&&(hk(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hk(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new bO("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return dk((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=OI([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];dk((()=>{if(!this.stateful)throw new mO("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new bO("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>OI(a))):this.states_=[OI(a)];else if(null==e)hk(this.states_),null!=this.keptStates&&(hk(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>OI(a))):this.states_[0]=OI(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new bO("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));t?this.keptStates.push(this.states_.slice()):hk(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=a;if(!Um(n.shape,r))throw new bO("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(r,", received shape=").concat(n.shape));this.states_[t]=n}}this.states_=this.states_.map((e=>pk(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:o,dilationRate:i}=this.cell,s="channelsFirst"===t,c=e[s?3:2],l=e[s?4:3],u=IM(c,r[0],a,o[0],i[0]),d=IM(l,r[1],a,o[1],i[1]);return[...e.slice(0,2),...s?[n,u,d]:[u,d,n]]}}rP.className="ConvRNN2D";class aP extends ZM{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:o,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,zO(this.filters,"filters"),this.kernelSize=CM(n,2,"kernelSize"),this.kernelSize.forEach((e=>zO(e,"kernelSize"))),this.strides=CM(r||1,2,"strides"),this.strides.forEach((e=>zO(e,"strides"))),this.padding=a||"valid",ZO(this.padding),this.dataFormat=o||"channelsLast",QO(this.dataFormat),this.dilationRate=CM(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>zO(e,"dilationRate")))}build(e){var t;e=t_(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new bO("The channel dimension of the input should be defined. "+"Found ".concat(e[n]));const r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends FF{apply(e,t){return yF([n.apply([r]),FI([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return dk((()=>{if(3!==e.length)throw new bO("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=t.training||!1,r=e[0],a=e[1],o=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=tP({ones:()=>_I(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,s=(e,t,n)=>t&&t[n]?iS(t[n],e):e;let c=s(r,i,0),l=s(r,i,1),u=s(r,i,2),d=s(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=tP({ones:()=>_I(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let p=s(a,h,0),f=s(a,h,1),g=s(a,h,2),m=s(a,h,3);const[v,b,y,x]=eE(this.kernel.read(),4,3),[w,k,S,C]=this.useBias?eE(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,v,w,this.padding),l=this.inputConv(l,b,k,this.padding),u=this.inputConv(u,y,S,this.padding),d=this.inputConv(d,x,C,this.padding);const[I,E,N,T]=eE(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,I),f=this.recurrentConv(f,E),g=this.recurrentConv(g,N),m=this.recurrentConv(m,T);const R=this.recurrentActivation.apply(rS(c,p)),A=this.recurrentActivation.apply(rS(l,f)),O=rS(iS(A,o),iS(R,this.activation.apply(rS(u,g)))),F=iS(this.recurrentActivation.apply(rS(d,m)),this.activation.apply(O));return[F,F,O]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=nP(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const a=BC(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?NF(a,n,this.dataFormat):a}recurrentConv(e,t){return BC(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}aP.className="ConvLSTM2DCell",mS(aP);class oP extends rP{constructor(e){const t=new aP(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}oP.className="ConvLSTM2D",mS(oP);class iP extends h_{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return dk((()=>{this.invokeCallHook(e,t);const n=e_(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return RF((()=>TF(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}iP.className="Dropout",mS(iP);class sP extends iP{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}sP.className="SpatialDropout1D",mS(sP);class cP extends h_{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,zO(this.units,"units"),this.activation=uM(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=QF(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=QF(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=O_(e.kernelConstraint),this.biasConstraint=O_(e.biasConstraint),this.kernelRegularizer=vM(e.kernelRegularizer),this.biasRegularizer=vM(e.biasRegularizer),this.activityRegularizer=vM(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=t_(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=t_(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return dk((()=>{this.invokeCallHook(e,t);const n=e_(e),r=WO(this.activation.getClassName());let a;return null!=r?a=SF(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=SF(n,this.kernel.read()),null!=this.bias&&(a=NF(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const e={units:this.units,activation:cM(this.activation),useBias:this.useBias,kernelInitializer:YF(this.kernelInitializer),biasInitializer:YF(this.biasInitializer),kernelRegularizer:gM(this.kernelRegularizer),biasRegularizer:gM(this.biasRegularizer),activityRegularizer:gM(this.activityRegularizer),kernelConstraint:R_(this.kernelConstraint),biasConstraint:R_(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}cP.className="Dense",mS(cP);class lP extends h_{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=t_(e);for(const t of e.slice(1))if(null==t)throw new bO('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(e.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[e[0],cF(e,1)]}call(e,t){return dk((()=>{this.invokeCallHook(e,t);let n=e_(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=dE(n,e)}return function(e){if(e.rank<=1)throw new bO("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank,"."));const t=[e.shape[0],cF(e.shape,1)];return IC(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}lP.className="Flatten",mS(lP);class uP extends h_{constructor(e){super(e),this.supportsMasking=!0,this.activation=uM(e.activation)}call(e,t){return dk((()=>{this.invokeCallHook(e,t);const n=e_(e);return this.activation.apply(n)}))}getConfig(){const e={activation:cM(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}uP.className="Activation",mS(uP);class dP extends h_{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return dk((()=>function(e,t){return dk((()=>{if(2!==e.shape.length)throw new bO("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(e.shape.length," tensor."));return wF(gF(e,1),[1,t,1])}))}(e=e_(e),this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}dP.className="RepeatVector",mS(dP);class hP extends h_{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let a=1,o=null;for(let s=0;s<r.length;++s){const e=r[s];if(this.isUnknown(e)){if(null!==o)throw new bO("Can only specifiy one unknown dimension.");o=s}else a*=e}const i=cF(e);if(null!==o){if(0===a||i%a!==0)throw new bO(n);r[o]=i/a}else if(i!==a)throw new bO(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return dk((()=>{this.invokeCallHook(e,t);const n=e_(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return IC(n,a)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}hP.className="Reshape",mS(hP);class pP extends h_{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(e.dims," instead."));const t=dF(1,e.dims.length+1);if(!Um(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new s_({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=t_(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return dE(e_(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}pP.className="Permute",mS(pP);class fP extends h_{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=e_(e);return cC(RI(n,this.maskValue),-1)}call(e,t){return dk((()=>{this.invokeCallHook(e,t);const n=e_(e),r=cC(RI(n,this.maskValue),-1,!0);return iS(n,eS(r,n.dtype))}))}}fP.className="Masking",mS(fP);class gP extends h_{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(EO(e.inputLength))}this.inputDim=e.inputDim,zO(this.inputDim,"inputDim"),this.outputDim=e.outputDim,zO(this.outputDim,"outputDim"),this.embeddingsInitializer=QF(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=vM(e.embeddingsRegularizer),this.activityRegularizer=vM(e.activityRegularizer),this.embeddingsConstraint=O_(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return dk((()=>this.maskZero?(e=e_(e),RI(e,lS(e))):null))}computeOutputShape(e){if(e=t_(e),null==this.inputLength)return[...e,this.outputDim];const t=EO(this.inputLength);if(t.length!==e.length-1)throw new bO('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));{let n=0;for(let r=0;r<t.length;++r){const a=t[r],o=e[r+1];if(null!=a&&null!=o&&a!==o)throw new bO('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));null==a&&(t[n]=o),n++}}return[e[0],...t,this.outputDim]}call(e,t){return dk((()=>{this.invokeCallHook(e,t);let n=e_(e);"int32"!==n.dtype&&(n=fF(n,"int32"));const r=CF(this.embeddings.read(),IC(n,[n.size]));return IC(r,t_(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:YF(this.embeddingsInitializer),embeddingsRegularizer:gM(this.embeddingsRegularizer),activityRegularizer:gM(this.activityRegularizer),embeddingsConstraint:R_(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}gP.className="Embedding",mS(gP);class mP extends h_{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new yO}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const a=e[e.length-t.length+r],o=t[r];if(null==a||null==o||a<0||o<0)n.push(null);else if(1===a)n.push(o);else if(1===o)n.push(a);else{if(a!==o)throw new bO("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[t_(e)]),e.length<2)throw new bO("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(e.length," input(s)."));let t=[];for(const a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=DO(t),t.length>1)throw new bO("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(e),"."));let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===DO(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return dk((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=uF(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=gF(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const o of e){const e=o.rank;if(null==e){const e=o.shape,r=e[0],a=e.slice(1).concat([r]);let i=IC(o,[r].concat(cF(e.slice(1))));i=dE(i,[1,0]),i=IC(i,a),t.push(i),n=!0}else if(e>1){const r=dF(1,e).concat([0]);t.push(dE(o,r)),n=!0}else t.push(o)}let r=this.mergeFunction(t);const a=r.rank;if(n)if(null==a){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=IC(dE(IC(r,[-1,t]),[1,0]),n)}else if(a>1){const e=[a-1].concat(dF(0,a-1));r=dE(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=DO(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return dk((()=>{if(null==t)return null;if(!Array.isArray(t))throw new bO("`mask` should be an Array");if(!Array.isArray(e))throw new bO("`inputs` should be an Array");if(t.length!==e.length)throw new bO("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(e.length," vs ").concat(t.length,")"));if(t.every((e=>null==e)))return null;t=t.map((e=>null==e?e:ZC(e,0)));let n=t[0];for(let e=1;e<t.length-1;++e)n=xI(n,t[e]);return n}))}}class vP extends mP{constructor(e){super(e)}mergeFunction(e){return dk((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=rS(t,e[n]);return t}))}}vP.className="Add",mS(vP);class bP extends mP{constructor(e){super(e)}mergeFunction(e){return dk((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=iS(t,e[n]);return t}))}}bP.className="Multiply",mS(bP);class yP extends mP{constructor(e){super(e)}mergeFunction(e){return dk((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=rS(t,e[n]);return iS(1/e.length,t)}))}}yP.className="Average",mS(yP);class xP extends mP{constructor(e){super(e)}mergeFunction(e){return dk((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=TS(t,e[n]);return t}))}}xP.className="Maximum",mS(xP);class wP extends mP{constructor(e){super(e)}mergeFunction(e){return dk((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=EI(t,e[n]);return t}))}}wP.className="Minimum",mS(wP);class kP extends mP{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new bO("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let a=!1;for(const e of n)if(Um(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new bO("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return dk((()=>yF(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new bO("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new bO("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new bO("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new bO("Mismatch in the length of mask (".concat(t.length,") ")+"and the legnth of inputs (".concat(e.length,")"));return dk((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let o=0;o<e.length;++o)null==t[o]?r.push(eS(_I(e[o]),"bool")):t[o].rank<e[o].rank?r.push(ZC(t[o],-1)):r.push(t[o]);const a=DC(r,this.axis);return sC(a,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function SP(e,t){for(;e<0;)e+=t;return e}kP.className="Concatenate",mS(kP);class CP extends mP{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Lm(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new yO("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new bO("Dimension incompatibility: "+"".concat(t[r[0]]," !== ").concat(n[r[1]]))}mergeFunction(e){if(2!==e.length)throw new bO("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(e.length," input(s)."));let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>SP(t,e[n].shape.length))):[SP(this.axes,n.shape.length),SP(this.axes,r.shape.length)],this.normalize&&(n=H_(n,t[0]),r=H_(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new yO("batchDot is not implemented for tensors of 4D or higher rank yet");if(Lm(e.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(e.shape.length))),Lm(e.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(t.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new yO("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);const o=n;return dk((()=>{let n,i;if(r>a){n=r-a;const e=[];for(let t=0;t<n;++t)e.push(1);t=IC(t,t.shape.concat(e))}else if(a>r){n=a-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=IC(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=o[0]===o[1]?lI(iS(e,t),o[0]):lI(iS(dE(e,[1,0]),t),o[1]);else{const n=o[0]!==e.shape.length-1,r=o[1]===t.shape.length-1;i=wI(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=tE(i,t)}return 1===i.shape.length&&(i=ZC(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[SP(this.axes,e.length),SP(this.axes,t.length)],n}computeOutputShape(e){Lm(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new yO("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}CP.className="Dot",mS(CP);class IP extends h_{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return dk((()=>{this.invokeCallHook(e,t);const n=e_(e);return RF((()=>rS(kF(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}IP.className="GaussianNoise",mS(IP);class EP extends h_{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return dk((()=>{this.invokeCallHook(e,t);const n=e_(e);if(this.rate>0&&this.rate<1){return RF((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return iS(n,kF(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}EP.className="GaussianDropout",mS(EP);class NP extends h_{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||e_(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return dk((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=e_(e),r=-1.7580993408473766;let a=aI(WI(n),this.rate);a=fF(a,"float32");const o=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-o*r*this.rate,s=rS(iS(t,a),iS(rS(a,-1),r));return rS(iS(s,o),i)};return RF(r,(()=>e_(e)),t.training||!1)}return e}))}}function TP(e,t,n,r,a){let o,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)o=RC(e,t,n,r,a,i);else if(3===e.rank)o=AC(e,t,n,r,a,i);else{if(4!==e.rank)throw new yO("batchNormalization is not implemented for array of rank ".concat(e.rank," ")+"yet");o=OC(e,t,n,r,a,i)}return o}function RP(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Um(r.slice().sort(),dF(0,e.rank-1))?function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return dk((()=>{const o=NI(e,r),i=o.mean,s=o.variance;return[TP(e,i,s,n,t,a),i,s]}))}(e,t,n,r,a):function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return dk((()=>{const o=NI(e,r),i=o.mean,s=o.variance,c=[];for(const t of dF(0,e.rank))-1!==r.indexOf(t)?c.push(1):c.push(e.shape[t]);const l=IC(i,c),u=IC(s,c),d=null==t?null:IC(t,c),h=null==n?null:IC(n,c);return[TP(e,l,u,h,d,a),i,s]}))}(e,t,n,r,a)}NP.className="AlphaDropout",mS(NP);class AP extends h_{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=QF(e.betaInitializer||"zeros"),this.gammaInitializer=QF(e.gammaInitializer||"ones"),this.movingMeanInitializer=QF(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=QF(e.movingVarianceInitializer||"ones"),this.betaConstraint=O_(e.betaConstraint),this.gammaConstraint=O_(e.gammaConstraint),this.betaRegularizer=vM(e.betaRegularizer),this.gammaRegularizer=vM(e.gammaRegularizer)}build(e){e=t_(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new bO("Axis ".concat(t," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(e),"."));this.inputSpec=[new s_({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return dk((()=>{const n=null!=t.training&&t.training,r=e_(e),a=r.shape,o=a.length,i=dF(0,o),s=this.axis>=0?this.axis:this.axis+o;i.splice(s,1);const c=kO(1,o);c[s]=a[s];const l=i.slice();l.sort();const u=!Um(l,dF(0,o).slice(0,o-1));if(!n)return(()=>{if(u){const e=IC(this.movingMean.read(),c),t=IC(this.movingVariance.read(),c),n=this.center?IC(this.beta.read(),c):null,a=this.scale?IC(this.gamma.read(),c):null;return TP(r,e,t,n,a,this.epsilon)}return TP(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,h,p]=RP(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{dk((()=>{const r=1-n,a=e.read(),o=iS(kS(a,t),r);e.write(kS(a,o))}))};return(()=>{f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:YF(this.betaInitializer),gammaInitializer:YF(this.gammaInitializer),movingMeanInitializer:YF(this.movingMeanInitializer),movingVarianceInitializer:YF(this.movingVarianceInitializer),betaRegularizer:gM(this.betaRegularizer),gammaRegularizer:gM(this.gammaRegularizer),betaConstraint:R_(this.betaConstraint),gammaConstraint:R_(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}AP.className="BatchNormalization",mS(AP);class OP extends h_{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const e of this.axis)if(!Number.isInteger(e))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=QF(e.betaInitializer||"zeros"),this.gammaInitializer=QF(e.gammaInitializer||"ones"),this.betaRegularizer=vM(e.betaRegularizer),this.gammaRegularizer=vM(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=t_(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error("Invalid axis: ".concat(a));if(this.axis.length!==DO(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=e_(e),r=n.shape,a=r.length;return dk((()=>{let{mean:e,variance:t}=NI(n,this.axis,!0);const o=kO(1,a);for(const n of this.axis)o[n]=r[n];const i=e=>null!=e&&e.shape.length!==a?IC(e,o):e;let s=this.scale?i(this.gamma.read()):null,c=this.center?i(this.beta.read()):null;const l=[],u=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(l.push(r[n]),u.push(1)):(l.push(1),u.push(r[n]));return e=JC(e,l),t=JC(t,l),null!=s&&(s=JC(s,u)),null!=c&&(c=JC(c,u)),TP(n,e,t,c,s,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:YF(this.betaInitializer),gammaInitializer:YF(this.gammaInitializer),betaRegularizer:gM(this.betaRegularizer),gammaRegularizer:gM(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}OP.className="LayerNormalization",mS(OP);class FP extends h_{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new bO("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(e.padding.length," array."));let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new bO("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(e.padding[0].length," array."));if(t=e.padding[0],2!==e.padding[1].length)throw new bO("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(e.padding[1].length," array."));n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new s_({ndim:4})]}computeOutputShape(e){let t,n;return e=t_(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return dk((()=>function(e,t,n){return dk((()=>{if(4!==e.rank)throw new bO("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(e.rank,"-D tensor."));if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new bO("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new bO("Unknown data format: ".concat(n,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],DI(e,r)}))}(e_(e),this.padding,this.dataFormat)))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function _P(e,t,n,r,a,o){return dk((()=>{let i;QO(a),JO(o),ZO(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==o&&(o="max"),e=NM(e,a);const s="same"===r?"same":"valid";return i="max"===o?kI(e,t,n,s):EC(e,t,n,s),"channelsFirst"===a&&(i=dE(i,[0,3,1,2])),i}))}function DP(e,t,n,r,a,o){return dk((()=>{let i;QO(a),JO(o),ZO(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==o&&(o="max"),e=TM(e,a);const s="same"===r?"same":"valid";return i="max"===o?SI(e,t,n,s):NC(e,t,n,s),"channelsFirst"===a&&(i=dE(i,[0,4,1,2,3])),i}))}FP.className="ZeroPadding2D",mS(FP);class MP extends h_{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new bO("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.poolSize)));this.poolSize=e.poolSize}if(zO(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new bO("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.strides)));this.strides=e.strides}zO(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,ZO(this.padding),this.inputSpec=[new s_({ndim:3})]}computeOutputShape(e){const t=IM((e=t_(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return dk((()=>{this.invokeCallHook(e,t),e=gF(e_(e),2);const n=this.poolingFunction(e_(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return tE(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class PP extends MP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return QO(a),ZO(r),_P(e,t,n,r,a,"max")}}PP.className="MaxPooling1D",mS(PP);class LP extends MP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return QO(a),ZO(r),_P(e,t,n,r,a,"avg")}}LP.className="AveragePooling1D",mS(LP);class zP extends h_{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new bO("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides];zO(this.poolSize,"poolSize"),zO(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,QO(this.dataFormat),ZO(this.padding),this.inputSpec=[new s_({ndim:4})]}computeOutputShape(e){e=t_(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=IM(t,this.poolSize[0],this.padding,this.strides[0]),n=IM(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return dk((()=>(this.invokeCallHook(e,t),this.poolingFunction(e_(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class BP extends zP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return QO(a),ZO(r),_P(e,t,n,r,a,"max")}}BP.className="MaxPooling2D",mS(BP);class WP extends zP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return QO(a),ZO(r),_P(e,t,n,r,a,"avg")}}WP.className="AveragePooling2D",mS(WP);class UP extends h_{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new bO("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];zO(this.poolSize,"poolSize"),zO(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,QO(this.dataFormat),ZO(this.padding),this.inputSpec=[new s_({ndim:5})]}computeOutputShape(e){e=t_(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=IM(t,this.poolSize[0],this.padding,this.strides[0]),n=IM(n,this.poolSize[1],this.padding,this.strides[1]),r=IM(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return dk((()=>(this.invokeCallHook(e,t),this.poolingFunction(e_(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class VP extends UP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return QO(a),ZO(r),DP(e,t,n,r,a,"max")}}VP.className="MaxPooling3D",mS(VP);class jP extends UP{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return QO(a),ZO(r),DP(e,t,n,r,a,"avg")}}jP.className="AveragePooling3D",mS(jP);class HP extends h_{constructor(e){super(e),this.inputSpec=[new s_({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new yO}}class GP extends HP{constructor(e){super(e||{})}call(e,t){return dk((()=>{const t=e_(e);return CI(t,1)}))}}GP.className="GlobalAveragePooling1D",mS(GP);class qP extends HP{constructor(e){super(e||{})}call(e,t){return dk((()=>{const t=e_(e);return cI(t,1)}))}}qP.className="GlobalMaxPooling1D",mS(qP);class KP extends h_{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,QO(this.dataFormat),this.inputSpec=[new s_({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new yO}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class XP extends KP{call(e,t){return dk((()=>{const t=e_(e);return"channelsLast"===this.dataFormat?CI(t,[1,2]):CI(t,[2,3])}))}}XP.className="GlobalAveragePooling2D",mS(XP);class $P extends KP{call(e,t){return dk((()=>{const t=e_(e);return"channelsLast"===this.dataFormat?cI(t,[1,2]):cI(t,[2,3])}))}}$P.className="GlobalMaxPooling2D",mS($P);class YP extends h_{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=j_(t.layer,n);delete t.layer;const a={layer:r};return Object.assign(a,t),new e(a)}}class QP extends YP{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=t_(e)).length<3)throw new bO("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(e)));this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=t_(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return dk((()=>GM(((e,n)=>[e_(this.layer.call(e,t)),[]]),e=e_(e),[],!1,null,null,!1,!0)[1]))}}QP.className="TimeDistributed",mS(QP);class ZP extends YP{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=j_(n),t.goBackwards=!0!==t.goBackwards;const r={};var a;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=j_(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,a=this.mergeMode,PO($O,"BidirectionalMergeMode",a),e.weights)throw new yO("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),t=a[0]):t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):IO(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=HM(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const o=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new bO("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,o.push(...n);const r=n.map((e=>new s_({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new yO("Support for constants in Bidirectional layers is not implemented yet.");const s=o[0]instanceof c_;for(const c of o)if(c instanceof c_!==s)throw new bO("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(s){const n=[e].concat(o),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const s=super.apply(n,t);return this.inputSpec=a,s}return super.apply(e,t)}call(e,t){return dk((()=>{const n=t.initialState;let r,a,o,i;if(null==n)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{const o=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=jI(a,1)),"concat"===this.mergeMode?i=yF([r,a]):"sum"===this.mergeMode?i=rS(r,a):"ave"===this.mergeMode?i=iS(.5,rS(r,a)):"mul"===this.mergeMode?i=iS(r,a):null==this.mergeMode&&(i=[r,a]),this.returnState?null==this.mergeMode?i.concat(o):[i].concat(o):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){nF(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),nF(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=j_(t.layer);if(delete t.layer,null!=t.numConstants)throw new yO("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}ZP.className="Bidirectional",mS(ZP);class JP extends h_{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return dk((()=>("float32"!==(e=e_(e)).dtype&&(e=fF(e,"float32")),rS(iS(e,this.scale),this.offset))))}}JP.className="Rescaling",mS(JP);const{resizeBilinear:eL,cropAndResize:tL}=hN;class nL extends h_{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,o,i,s){return dk((()=>{let c,l=!1;const u=[t/o,n/i,(r+t)/o,(a+n)/i],d=[];3===e.rank?(l=!0,c=nE([e])):c=e;for(let e=0;e<c.shape[0];e++)d.push(u);const h=sk(d,[d.length,4]),p=UI(0,d.length,1,"int32"),f=tL(c,h,p,[r,a],"nearest");return fF(l?e_(sE(f)):f,s)}))}upsize(e,t,n,r){return dk((()=>fF(eL(e,[t,n]),r)))}call(e,t){return dk((()=>{const t=e_(e),n=t.dtype,r=t.shape,a=r[r.length-3],o=r[r.length-2];let i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let s=0;return o!==this.width&&(s=Math.floor((o-this.width)/2),0===s&&(s=1)),i>=0&&s>=0?this.centerCrop(t,i,s,this.height,this.width,a,o,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=t_(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}nL.className="CenterCrop",mS(nL);class rL extends h_{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=t_(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return dk((()=>{let n;if("int32"!==(e=e_(e)).dtype&&(e=fF(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new bO("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(t.countWeights));n=e_(t.countWeights)}const r=cI(e),a=II(e),o=rI(this.numTokens,r).bufferSync().get(0),i=aI(a,0).bufferSync().get(0);if(!o||!i)throw new bO("Input values must be between 0 < values <="+" numTokens with numTokens=".concat(this.numTokens));return function(e,t,n,r){let a=e_(e);if("int32"!==a.dtype&&(a=fF(a,"int32")),"int"===t)return a;const o=a.shape;if(0===a.rank&&(a=ZC(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=ZC(a,-1)),a.rank>2)throw new bO("When outputMode is not int, maximum output rank is 2"+" Received outputMode ".concat(t," and input shape ").concat(o)+" which would result in output rank ".concat(a.rank,"."));const i=["multiHot","oneHot"].includes(t),s=a;let c;if(c=qC(s,"undefined"!==typeof r&&"count"===t?r:[],n,i),"tfIdf"!==t)return c;if(r)return iS(c,r);throw new bO("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}rL.className="CategoryEncoding",mS(rL);const aL=new Set(["bilinear","nearest"]);class oL extends h_{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!aL.has(e.interpolation))throw new bO("Invalid interpolation parameter: ".concat(e.interpolation," is not implemented"));this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=t_(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return dk((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return hN.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return hN.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([...aL]," are supported"))}))}}oL.className="Resizing",mS(oL);class iL{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}iL.className="RandomSeed";class sL extends h_{constructor(e){super(e),this.randomGenerator=new iL(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}sL.className="BaseRandomLayer";const cL=new Set(["bilinear","nearest"]);class lL extends sL{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new bO("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new bO("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new bO("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!cL.has(n))throw new bO("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=t_(e))[2];return[this.imgHeight,-1,t]}call(e,t){return dk((()=>{const t=e_(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=WI([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return hN.resizeBilinear(e,a);case"nearest":return hN.resizeNearestNeighbor(e,a);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...cL]," are supported"))}}))}}lL.className="RandomWidth",mS(lL);var uL,dL;vv().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(uL||(uL={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(dL||(dL={}));Error;new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function hL(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(mL(e)){const a=Array.isArray(e)?[]:{};r.add(e);for(const o in e){const i=hL(e[o],t,n,r);a[o]=i}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error("Can't recurse into non-iterable type: ".concat(e))}return n.set(e,a.value),a.value}function pL(e){return fL(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:gL)}function fL(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(mL(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const o in r){const r=e.map((e=>e[o])),i=fL(r,t,n);a[o]=i}return n.delete(r),a}throw new Error("Can't recurse into non-iterable type: ".concat(r))}return a.value}function gL(e){return null===e?null:mL(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function mL(e){let t=!1;if(vv().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(551);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof Ew)&&!(e instanceof Promise)&&!t)}function vL(e){return function(e,t){return hL(e,t)}(e,bL)}function bL(e){return e instanceof Ew?{value:e.clone(),recurse:!1}:mL(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class yL{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class xL extends yL{constructor(){super(xL.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function wL(e){return new IL(e)}function kL(e,t){return new PL(e,t)}xL.INITIAL_CAPACITY=32;class SL{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new FL(this,e)}filter(e){return new AL(this,e)}map(e){return new OL(this,e)}mapAsync(e){return new _L(this,e)}serialMapAsync(e){return new _L(this,e).serial()}flatmap(e){return new ML(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new RL(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:gL;return this.rowMajorBatch(e,t).map((e=>pL(e,n)))}concatenate(e,t){return new PL(new CL([this,e]),t)}take(e){return e<0||null==e?this:new TL(this,e)}skip(e){return e<0||null==e?this:new NL(this,e)}prefetch(e){return new zL(this,e)}shuffle(e,t){return new BL(this,e,t)}serial(){return new EL(this)}}class CL extends SL{constructor(e){super(),this.items=e,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:vL(e),done:!1}}}class IL extends SL{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(f0){throw f0.message="Error thrown while iterating through a dataset: ".concat(f0.message),f0}}}class EL extends SL{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class NL extends SL{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;hk(e.value)}return this.upstream.next()}}class TL extends SL{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class RL extends SL{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class AL extends SL{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;hk(e.value)}}}class OL extends SL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Uw(e.value),n=this.transform(e.value),r=Uw(n);for(const a of t)Ww(a,r)||a.dispose();return{value:n,done:!1}}}class FL extends SL{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(f0){if(!this.handler(f0))return{value:null,done:!0}}}}class _L extends SL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Uw(e.value),n=await this.transform(e.value),r=Uw(n);for(const a of t)Ww(a,r)||a.dispose();return{value:n,done:!1}}}class DL extends SL{constructor(){super(),this.outputQueue=new xL,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class ML extends DL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Uw(e.value),n=this.transform(e.value),r=Uw(n);this.outputQueue.pushAll(n);for(const a of t)Ww(a,r)||a.dispose();return!0}}class PL extends SL{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var LL;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(LL||(LL={}));class zL extends SL{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new yL(t)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class BL extends zL{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=PI.alea(n||iw().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class WL{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return Lm(e>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(e))),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),UL((async()=>(await n.iterator()).columnMajorBatch(e,t,VL)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,UL((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,UL((async()=>(await t.iterator()).filter((t=>dk((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return UL((async()=>(await t.iterator()).map((t=>dk((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return UL((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return UL((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,UL((async()=>kL(wL((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,UL((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const r=this,a=PI.alea(t||iw().toString());return UL((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,UL((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function UL(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends WL{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function VL(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof Ew||lw(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Ew?nE(e):sk(e)}(e),recurse:!1}}return{value:null,recurse:!0}}WL.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function jL(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Lm("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors in the CPU backend.")))}))}const HL=ET;class GL extends Om{nextDataId(){return GL.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Am(this,lk())}write(e,t,n){this.firstUse&&(this.firstUse=!1,vv().get("IS_NODE")&&_x("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Jm(n[0])){const a=n.map((e=>sw(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return HN(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype ".concat(t))}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>cw(e)));return Jk(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Jk(e.shape,e.dtype,t)}makeOutput(e,t,n){return lk().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=iw();e();return{kernelMs:iw()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){jL([e],"where");const t=this.readSync(e.dataId);return HL(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}GL.nextDataId=0;function qL(e){return(t,n,r)=>{const a=Ym(n,t.length);for(let o=0;o<t.length;++o)a[o]=e(t[o],r);return a}}function KL(e,t,n){return XL(e,qL(t),n)}function XL(e,t,n){return r=>{let{inputs:a,attrs:o,backend:i}=r;const{x:s}=a;jL(s,e);const c=i,l=c.data.get(s.dataId).values;let u;if("string"===s.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=CT(l)}else u=l;const d=n||s.dtype,h=t(u,d,o);return c.makeTensorInfo(s.shape,d,h)}}fk("cpu",(()=>new GL),1);const $L=KL(xb,(e=>e>=0?e:Math.exp(e)-1)),YL={kernelName:xb,backendName:"cpu",kernelFunc:$L};function QL(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const ZL={kernelName:Lb,backendName:"cpu",kernelFunc:QL};function JL(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:o}=r;jL([a],"leakyRelu");const i=Wm(a.shape),s=n.data.get(a.dataId).values,c=$m("float32",i);for(let l=0;l<s.length;l++)c[l]=s[l]<0?o*s[l]:s[l];return n.makeTensorInfo(a.shape,"float32",c)}const ez={kernelName:jb,backendName:"cpu",kernelFunc:JL};function tz(e){return(t,n,r,a,o)=>{const i=NS(t,n),s=i.length,c=av(i),l=$m(o,Wm(i)),u=t.length,d=n.length,h=av(t),p=av(n),f=IS(t,i),g=IS(n,i);if(f.length+g.length===0)for(let m=0;m<l.length;++m)l[m]=e(r[m%r.length],a[m%a.length]);else for(let m=0;m<l.length;++m){const t=hv(m,s,c),n=t.slice(-u);f.forEach((e=>n[e]=0));const o=dv(n,u,h),i=t.slice(-d);g.forEach((e=>i[e]=0));const v=dv(i,d,p);l[m]=e(r[o],a[v])}return[l,i]}}const nz=tz(((e,t)=>e<0?t*e:e));function rz(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t;jL([r,a],"prelu");const o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[s,c]=nz(r.shape,a.shape,o,i,"float32");return n.makeTensorInfo(c,"float32",s)}const az={kernelName:Cy,backendName:"cpu",kernelFunc:rz},oz=KL(Fy,(e=>Math.max(0,e))),iz={kernelName:Fy,backendName:"cpu",kernelFunc:oz},sz=KL(zy,(e=>Math.min(Math.max(0,e),6))),cz={kernelName:zy,backendName:"cpu",kernelFunc:sz},lz=qL((e=>1/(1+Math.exp(-e)))),uz=KL(Qy,(e=>1/(1+Math.exp(-e)))),dz={kernelName:Qy,backendName:"cpu",kernelFunc:uz};function hz(e,t,n,r,a){if("linear"===n)return QL({inputs:{x:t},backend:e});if("relu"===n)return oz({inputs:{x:t},backend:e});if("elu"===n)return $L({inputs:{x:t},backend:e});if("relu6"===n)return sz({inputs:{x:t},backend:e});if("prelu"===n)return rz({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return JL({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return uz({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function pz(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,s=n.makeTensorInfo(r.shape,"complex64");return n.data.get(s.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",o),imag:n.makeTensorInfo(a.shape,"float32",i)},s}const fz={kernelName:Xv,backendName:"cpu",kernelFunc:pz};function gz(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return pz({inputs:{real:gz(e,t,"float32"),imag:gz(e,t,"float32")},backend:e})}const r=cv(Wm(t),n);return e.makeTensorInfo(t,n,r)}function mz(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,o=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,o)}const vz={kernelName:Ay,backendName:"cpu",kernelFunc:mz};function bz(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=ow([0],n),[a,o]=tz(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[o,"bool",a]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(r))}function yz(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===a.dtype)return QL({inputs:{x:a},backend:n});const e=gz(n,a.shape,a.dtype),t=yz({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=pz({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=mz({inputs:{input:a},backend:n}),t=yz({inputs:{x:e},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(e),t}if(!Qm(a.dtype,o)){const e=QL({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:o}}const i=n.data.get(a.dataId).values,[s,c,l]=bz(i,a.shape,a.dtype,o);return n.makeTensorInfo(s,c,l)}const xz={kernelName:Gv,backendName:"cpu",kernelFunc:yz};function wz(e,t,n,r){return null==n?n=>{let{inputs:a,backend:o}=n;const{a:i,b:s}=a,c=o;jL([i,s],e);const l=c.data.get(i.dataId).values,u=c.data.get(s.dataId).values,d="string"===i.dtype?CT(l):l,h="string"===i.dtype?CT(u):u,p=r||i.dtype,[f,g]=t(i.shape,s.shape,d,h,p);return c.makeTensorInfo(g,p,f)}:e=>{let{inputs:a,backend:o}=e;const{a:i,b:s}=a,c=o;if("complex64"===i.dtype||"complex64"===s.dtype){const e=yz({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,o=c.data.get(r.dataId).values,l=c.data.get(a.dataId).values,u=yz({inputs:{x:s},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(u.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=c.data.get(h.dataId).values,g=c.data.get(p.dataId).values,[m,v,b]=n(i.shape,s.shape,o,l,f,g),y=c.makeTensorInfo(b,"float32",m),x=c.makeTensorInfo(b,"float32",v),w=pz({inputs:{real:y,imag:x},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(y),c.disposeIntermediateTensorInfo(x),w}{const e=c.data.get(i.dataId).values,n=c.data.get(s.dataId).values,a=r||i.dtype,[o,l]=t(i.shape,s.shape,e,n,a);return c.makeTensorInfo(l,a,o)}}}function kz(e){return(t,n,r,a,o,i)=>{const s=NS(t,n),c=Wm(s),l=s.length,u=av(s),d=$m("float32",c),h=$m("float32",c),p=IS(t,s),f=IS(n,s),g=HN(r,a),m=HN(o,i),v=t.length,b=av(t),y=n.length,x=av(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const t=w%g.length,n=w%m.length,r=e(g[2*t],g[2*t+1],m[2*n],m[2*n+1]);d[w]=r.real,h[w]=r.imag}else for(let w=0;w<d.length;w++){const t=hv(w,l,u),n=t.slice(-v);p.forEach((e=>n[e]=0));const r=dv(n,v,b),a=t.slice(-y);f.forEach((e=>a[e]=0));const o=dv(a,y,x),i=e(g[2*r],g[2*r+1],m[2*o],m[2*o+1]);d[w]=i.real,h[w]=i.imag}return[d,h,s]}}const Sz=tz(((e,t)=>e+t)),Cz=kz(((e,t,n,r)=>({real:e+n,imag:t+r}))),Iz=wz(Iv,Sz,Cz),Ez={kernelName:Iv,backendName:"cpu",kernelFunc:Iz};function Nz(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:o}=r,i=Wm(a.shape),s=qm(o,i),c=Wm(s);Lm(i===c,(()=>"The new shape (".concat(s,") has ").concat(c," elements and the old ")+"shape (".concat(a.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(a.dataId);const l=n.data.get(a.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=s,t.shape=s}return{dataId:a.dataId,shape:s,dtype:a.dtype}}const Tz={kernelName:_y,backendName:"cpu",kernelFunc:Nz};function Rz(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:o}=t,{transposeA:i,transposeB:s}=r;jL([a,o],"matMul");const c=a.shape.length,l=o.shape.length,u=i?a.shape[c-2]:a.shape[c-1],d=s?o.shape[l-1]:o.shape[l-2],h=i?a.shape[c-1]:a.shape[c-2],p=s?o.shape[l-2]:o.shape[l-1],f=a.shape.slice(0,-2),g=o.shape.slice(0,-2),m=Wm(f),v=Wm(g),b=NS(a.shape.slice(0,-2),o.shape.slice(0,-2)).concat([h,p]);Lm(u===d,(()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(d,") of Tensors with shapes ").concat(a.shape," and ")+"".concat(o.shape," and transposeA=").concat(i)+" and transposeB=".concat(s," must match.")));const y=s?[v,p,d]:[v,d,p],x=Nz({inputs:{x:a},backend:n,attrs:{shape:i?[m,u,h]:[m,h,u]}}),w=Nz({inputs:{x:o},backend:n,attrs:{shape:y}}),k=i?x.shape[1]:x.shape[2],S=i?x.shape[2]:x.shape[1],C=s?w.shape[1]:w.shape[2],I=Math.max(m,v),E=n.data.get(x.dataId).values,N=n.data.get(w.dataId).values,T=av(x.shape),R=av(w.shape),[A,O,F]=i?[T[0],1,T[1]]:[T[0],T[1],1],[_,D,M]=s?[1,R[1],R[0]]:[R[1],1,R[0]],P=S*C,L=Jk([I,S,C],x.dtype),z=L.values,B=n.blockSize;for(let W=0;W<I;W++){const e=W%m,t=W%v;for(let n=0;n<S;n+=B){const r=Math.min(n+B,S);for(let a=0;a<C;a+=B){const o=Math.min(a+B,C);for(let i=0;i<k;i+=B){const s=Math.min(i+B,k);for(let c=n;c<r;c++)for(let n=a;n<o;n++){let r=0;for(let a=i;a<s;a++){r+=E[e*A+c*O+a*F]*N[a*_+n*D+t*M]}z[W*P+(c*C+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,L.dtype,L.values)}const Az={kernelName:Wv,backendName:"cpu",kernelFunc:Rz};const Oz={kernelName:Ax,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:o,bias:i,preluActivationWeights:s}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=r;let h,p,f;const g=[];h=Rz({inputs:{a:a,b:o},attrs:{transposeA:c,transposeB:l},backend:n}),i&&(p=Iz({inputs:{a:h,b:i},backend:n}),g.push(h),h=p),u&&(f=hz(n,h,u,s,d),g.push(h),h=f);for(const m of g)n.disposeIntermediateTensorInfo(m);return h}};function Fz(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const _z={kernelName:kv,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;jL(t,"abs");let r=new Float32Array(Wm(t.shape));return r=Fz(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},Dz=KL(Sv,(e=>Math.acos(e))),Mz={kernelName:Sv,backendName:"cpu",kernelFunc:Dz},Pz=KL(Cv,(e=>Math.acosh(e))),Lz={kernelName:Cv,backendName:"cpu",kernelFunc:Pz};const zz={kernelName:Ev,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;jL(t,"addN");const a=r.map((e=>n.data.get(e.dataId).values)),o=Jk(r[0].shape,r[0].dtype),i=o.values;for(let s=0;s<r.length;s++){const e=a[s];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}};function Bz(e,t,n,r,a){const o=t.length,i=Wm(t),s=av(t),c=av(a),l=$m(n,Wm(a));for(let u=0;u<i;++u){const t=hv(u,o,s),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];l[dv(n,o,c)]=e[u]}return l}function Wz(e){const{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:o}=n;jL(a,"transpose");const i=a.shape.length,s=new Array(i);for(let l=0;l<s.length;l++)s[l]=a.shape[o[l]];const c=Bz(r.data.get(a.dataId).values,a.shape,a.dtype,o,s);return{dataId:r.write(c,s,a.dtype),shape:s,dtype:a.dtype}}const Uz={kernelName:kx,backendName:"cpu",kernelFunc:Wz};const Vz={kernelName:Nv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;jL(a,"all");const s=Km(o,a.shape);let c=s;const l=mI(c,a.shape.length);let u=a;null!=l&&(u=Wz({inputs:{x:a},backend:n,attrs:{perm:l}}),c=bI(c.length,a.shape.length)),gI("all",c,u.shape.length);const[d,h]=pI(u.shape,c),p=Wm(h),f=cv(Wm(d),u.dtype),g=n.data.get(u.dataId).values;for(let v=0;v<f.length;++v){const e=v*p;let t=g[e];for(let n=0;n<p;++n){const r=g[e+n];t=t&&r}f[v]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(d,u.dtype,f);if(i){const e=Nz({inputs:{x:m},backend:n,attrs:{shape:fI(d,s)}});return n.disposeIntermediateTensorInfo(m),e}return m}};const jz={kernelName:Tv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;jL(a,"any");const s=Km(o,a.shape);let c=s;const l=mI(c,a.shape.length);let u=a;null!=l&&(u=Wz({inputs:{x:a},backend:n,attrs:{perm:l}}),c=bI(c.length,a.shape.length)),gI("any",c,u.shape.length);const[d,h]=pI(u.shape,c),p=Wm(h),f=cv(Wm(d),u.dtype),g=n.data.get(u.dataId).values;for(let v=0;v<f.length;++v){const e=v*p;let t=g[e];for(let n=0;n<p;++n){const r=g[e+n];t=t||r}f[v]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(d,u.dtype,f);if(i){const e=Nz({inputs:{x:m},backend:n,attrs:{shape:fI(d,s)}});return n.disposeIntermediateTensorInfo(m),e}return m}};const Hz={kernelName:Rv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o}=r;jL(a,"argMax");let i=Km(o,a.shape);const s=mI(i,a.shape.length);let c=a;const l=[];null!=s&&(c=Wz({inputs:{x:a},backend:n,attrs:{perm:s}}),l.push(c),i=bI(i.length,c.shape.length)),i=[i[0]],gI("argMax",i,c.shape.length);const[u,d]=pI(c.shape,i),h=cv(Wm(u),"int32"),p=Wm(d),f=n.data.get(c.dataId).values;for(let g=0;g<h.length;++g){const e=g*p;let t=f[e],n=0;for(let r=0;r<p;++r){const a=f[e+r];a>t&&(t=a,n=r)}h[g]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",h)}};const Gz={kernelName:Av,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o}=r;jL(a,"argMin");let i=Km(o,a.shape);const s=mI(i,a.shape.length);let c=a;const l=[];null!=s&&(c=Wz({inputs:{x:a},backend:n,attrs:{perm:s}}),l.push(c),i=bI(i.length,c.shape.length)),i=[i[0]],gI("argMin",i,c.shape.length);const[u,d]=pI(c.shape,i),h=cv(Wm(u),"int32"),p=Wm(d),f=n.data.get(c.dataId).values;for(let g=0;g<h.length;++g){const e=g*p;let t=f[e],n=0;for(let r=0;r<p;++r){const a=f[e+r];a<t&&(t=a,n=r)}h[g]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",h)}},qz=KL(Ov,(e=>Math.asin(e))),Kz={kernelName:Ov,backendName:"cpu",kernelFunc:qz},Xz=KL(Fv,(e=>Math.asinh(e))),$z={kernelName:Fv,backendName:"cpu",kernelFunc:Xz},Yz=KL(_v,(e=>Math.atan(e))),Qz={kernelName:_v,backendName:"cpu",kernelFunc:Yz},Zz=tz(((e,t)=>Math.atan2(e,t))),Jz=wz(Mv,Zz),eB={kernelName:Mv,backendName:"cpu",kernelFunc:Jz},tB=KL(Dv,(e=>Math.atanh(e))),nB={kernelName:Dv,backendName:"cpu",kernelFunc:tB};function rB(e,t,n,r,a,o){const i=a.strideHeight,s=a.strideWidth,c=a.dilationHeight,l=a.dilationWidth,u=a.effectiveFilterHeight,d=a.effectiveFilterWidth,h=a.padInfo.top,p=a.padInfo.left,f="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Jk(a.outShape,n),m=g.values,v=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],y=a.outShape[3];for(let x=0;x<a.batchSize;++x){const t=x*v,n=x*r[0];for(let g=0;g<a.inChannels;++g)for(let v=0;v<a.outHeight;++v){const x=v*i-h,w=Math.max(0,x),k=Math.min(a.inHeight,u+x),S=t+v*b;for(let t=0;t<a.outWidth;++t){const i=t*s-p,u=Math.max(0,i),h=Math.min(a.inWidth,d+i);let v=f,b=0,x=0;for(let t=w;t<k;t+=c){const a=n+t*r[1];for(let t=u;t<h;t+=l){const n=e[a+t*r[2]+g];"max"===o&&n>v?v=n:"avg"===o&&(b+=n,x++)}if(isNaN(v))break}m[S+t*y+g]="avg"===o?b/x:v}}}return g}function aB(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Jk(r.outShape,"int32"),s=r.strideHeight,c=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,g=Jk(t,n,e);for(let m=0;m<r.batchSize;++m)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*s-p;let v=n;for(;v<0;)v+=l;const b=Math.min(r.inHeight,d+n);for(let s=0;s<r.outWidth;++s){const d=s*c-f;let p=d;for(;p<0;)p+=u;const y=Math.min(r.inWidth,h+d);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=v;t<b;t+=l){const i=t-n;for(let n=p;n<y;n+=u){const s=n-d,c=g.get(m,t,n,e);c>x&&(x=c,w=a?o?((m*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*h+s)}}i.set(w,m,t,s,e)}}return i}function oB(e,t,n,r,a,o){const i=a.strideDepth,s=a.strideHeight,c=a.strideWidth,l=a.dilationDepth,u=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,g=a.padInfo.front,m=a.padInfo.top,v=a.padInfo.left,b="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=Jk(a.outShape,n),x=y.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],C=a.outShape[4];for(let I=0;I<a.batchSize;++I){const t=I*w,n=I*r[0];for(let y=0;y<a.inChannels;++y)for(let w=0;w<a.outDepth;++w){const I=w*i-g;let E=I;for(;E<0;)E+=l;const N=Math.min(a.inDepth,h+I),T=t+w*k;for(let t=0;t<a.outHeight;++t){const i=t*s-m;let h=i;for(;h<0;)h+=u;const g=Math.min(a.inHeight,p+i),w=T+t*S;for(let t=0;t<a.outWidth;++t){const i=t*c-v;let s=i;for(;s<0;)s+=d;const p=Math.min(a.inWidth,f+i),m=w+t*C;let k=b,S=0,I=0;for(let t=E;t<N;t+=l){const a=n+t*r[1];for(let t=h;t<g;t+=u){const n=a+t*r[2];for(let t=s;t<p;t+=d){const a=e[n+t*r[3]+y];if("max"===o&&a>k?k=a:"avg"===o&&(S+=a,I++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[m+y]="avg"===o?S/Math.max(I,1):k}}}}return y}const iB={kernelName:Pv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;jL(a,"avgPool");const{filterSize:o,strides:i,pad:s,dimRoundingMode:c}=r;Lm(wC(i,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'")));const l=dC(a.shape,o,i,1,s,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&Um(l.inShape,l.outShape))u=QL({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=av(a.shape),r=rB(e,a.shape,a.dtype,t,l,"avg");u=n.makeTensorInfo(l.outShape,a.dtype,r.values)}return u}};const sB={kernelName:zv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:o,strides:i,pad:s,dimRoundingMode:c,dataFormat:l}=r;jL(a,"avgPool3d");const u=hC(a.shape,o,i,1,s,c,l),d=oB(n.data.get(a.dataId).values,a.shape,a.dtype,av(a.shape),u,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};const cB={kernelName:Bv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,{filterSize:i,strides:s,pad:c,dimRoundingMode:l}=r;jL([a,o],"avgPool3DGrad");const u=hC(o.shape,i,s,1,c,l),d=u.strideDepth,h=u.strideHeight,p=u.strideWidth,f=u.filterDepth,g=u.filterHeight,m=u.filterWidth,v=u.dilationDepth,b=u.dilationHeight,y=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,S=x-1-u.padInfo.front,C=k-1-u.padInfo.left,I=w-1-u.padInfo.top,E=Jk(o.shape,"float32"),N=1/(f*g*m),T=n.bufferSync(a);for(let R=0;R<u.batchSize;++R)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){const a=t-S,o=n-I,i=r-C;let s=0;for(let t=0;t<x;t+=v){const n=(a+t)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const r=(o+t)/h;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=y){const a=(i+t)/p;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;s+=T.get(R,n,r,a,e)}}}E.set(s*N,R,t,n,r,e)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}};const lB={kernelName:Lv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,i=o;jL([a,o],"avgPoolGrad");const{filterSize:s,strides:c,pad:l}=r,u=dC(i.shape,s,c,1,l),d=u.strideHeight,h=u.strideWidth,p=u.filterHeight,f=u.filterWidth,g=u.dilationHeight,m=u.dilationWidth,v=u.effectiveFilterHeight,b=u.effectiveFilterWidth,y=b-1-u.padInfo.left,x=v-1-u.padInfo.top,w=Jk(i.shape,"float32"),k=1/(p*f),S=n.data.get(a.dataId).values,C=Jk(a.shape,"float32",S);for(let I=0;I<u.batchSize;++I)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inHeight;++t)for(let n=0;n<u.inWidth;++n){const r=t-x,a=n-y;let o=0;for(let t=0;t<v;t+=g){const n=(r+t)/d;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=m){const r=(a+t)/h;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;o+=C.get(I,n,r,e)}}w.set(o*k,I,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const uB={kernelName:Fb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,scale:o,offset:i,mean:s,variance:c}=t;Lm(s.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Lm(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Lm(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),jL([a,s,c,o,i],"batchNorm");let{varianceEpsilon:l}=r;null==l&&(l=.001);const u=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,h=n.data.get(c.dataId).values,p=o?n.data.get(o.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(u.length),m=f.length,v=p.length,b=h.length,y=d.length;let x=0,w=0,k=0,S=0;for(let C=0;C<u.length;++C)g[C]=f[x++]+(u[C]-d[w++])*p[k++]/Math.sqrt(h[S++]+l),x>=m&&(x=0),w>=y&&(w=0),k>=v&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,g)}};function dB(e,t,n,r,a){const o=nC(r,t,n),i=Wm(n),s=av(r);if(o){const n=rC(t,s);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}const c=Jk(r,a,"string"===a?CT(e):e),l=Jk(n,a);for(let u=0;u<l.size;++u){const e=l.indexToLoc(u),n=e.map(((e,n)=>e+t[n]));l.set(c.get(...n),...e)}return"string"===a?IT(l.values):l.values}function hB(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:o,size:i}=r;jL(a,"slice");const[s,c]=aC(a,o,i);HS(a,s,c);const l=dB(n.data.get(a.dataId).values,s,c,a.shape,a.dtype);return n.makeTensorInfo(c,a.dtype,l)}const pB={kernelName:Ky,backendName:"cpu",kernelFunc:hB};const fB={kernelName:Uv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:o,crops:i}=r;jL([a],"batchToSpaceND");const s=o.reduce(((e,t)=>e*t)),c=NN(a.shape,o,s),l=TN(c.length,o.length),u=RN(a.shape,o,s),d=AN(i,o.length),h=ON(u,i,o.length),p=Nz({inputs:{x:a},backend:n,attrs:{shape:c}}),f=Wz({inputs:{x:p},backend:n,attrs:{perm:l}}),g=Nz({inputs:{x:f},backend:n,attrs:{shape:u}}),m=hB({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}};function gB(e,t,n,r,a){const o=Wm(r),i=cv(a,n);for(let s=0;s<e.length;s++){const n=e[s];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=o>0?t[s]:1)}return i}function mB(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e.shape[0],o=e.shape[1],i=Jk([a,n],t.dtype);for(let s=0;s<a;s++)for(let a=0;a<o;a++){const o=e.get(s,a);if(o<0)throw new Error("Input x must be non-negative!");o>=n||(r?i.set(1,s,o):t.size>0?i.set(i.get(s,o)+t.get(s,a),s,o):i.set(i.get(s,o)+1,s,o))}return i}const vB={kernelName:Vv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:o}=t,{size:i}=r,s=gB(n.data.get(a.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,s)}},bB=tz(((e,t)=>e&t)),yB={kernelName:jv,backendName:"cpu",kernelFunc:wz(jv,bB)};const xB={kernelName:Hv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,s=NS(Array.from(o),Array.from(i));return n.makeTensorInfo([s.length],"int32",Int32Array.from(s))}},wB=qL((e=>Math.ceil(e))),kB=XL(qv,wB),SB={kernelName:qv,backendName:"cpu",kernelFunc:kB},CB=KL(Kv,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),IB={kernelName:Kv,backendName:"cpu",kernelFunc:CB},EB={kernelName:$v,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Wm(t.shape)),a=n.data.get(t.dataId),o=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,s=n.data.get(o.dataId).values,c=n.data.get(i.dataId).values;for(let l=0;l<s.length;l++){const e=s[l],t=c[l];r[l]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function NB(e,t,n,r){const a=Ym(n,Wm(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=Wm(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const o="string"===n?CT(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const s=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[s+t]=o[i++]}r+=e.shape[1]}))}return a}function TB(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,o=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,o)}const RB={kernelName:Bb,backendName:"cpu",kernelFunc:TB};function AB(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,o=Km(a,t[0].shape)[0];vN(t.map((e=>e.shape)),o);let i=bN(t.map((e=>e.shape)),o);if(0===Wm(i))return n.makeTensorInfo(i,t[0].dtype,[]);const s=t.filter((e=>Wm(e.shape)>0));if(1===s.length)return QL({inputs:{x:s[0]},backend:n});if("complex64"===s[0].dtype){const e=s.map((e=>mz({inputs:{input:e},backend:n}))),t=s.map((e=>TB({inputs:{input:e},backend:n}))),r=AB({inputs:e,backend:n,attrs:{axis:o}}),a=AB({inputs:t,backend:n,attrs:{axis:o}}),i=pz({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}const c=s.map((e=>{const t=Wm(e.shape.slice(o));return Nz({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),l=c.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=bN(c.map((e=>e.shape)),1);const u=1===c[0].shape[0],d=NB(l,i,t[0].dtype,u),h=bN(s.map((e=>e.shape)),o),p=n.makeTensorInfo(h,t[0].dtype,d);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const OB={kernelName:Yv,backendName:"cpu",kernelFunc:AB};function FB(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dataFormat:c,dilations:l,dimRoundingMode:u}=r;jL([a,o],"conv2d");const d=SC(c),h=pC(a.shape,o.shape,i,l,s,u,!1,d),p=h.filterHeight,f=h.filterWidth,g=h.dilationHeight,m=h.dilationWidth,v=h.padInfo.left,b=h.padInfo.top,y="channelsLast"===h.dataFormat,x=new kw(h.outShape,a.dtype),w=av(a.shape),k=av(o.shape),S=w[0],C=y?w[1]:w[2],I=y?w[2]:1,E=y?1:w[1],N=x.strides[0],T=y?x.strides[1]:x.strides[2],R=y?x.strides[2]:1,A=y?1:x.strides[1],O=n.data.get(a.dataId).values,F=n.data.get(o.dataId).values,_=x.values;for(let D=0;D<h.batchSize;++D){const e=D*S,t=D*N;for(let n=0;n<h.outHeight;++n){const r=t+n*T,a=n*h.strideHeight-b;for(let t=0;t<p;++t){const n=a+t*g;if(n<0||n>=h.inHeight)continue;const o=t*k[0],i=e+n*C;for(let e=0;e<h.outWidth;++e){const t=r+e*R,n=e*h.strideWidth-v;for(let e=0;e<f;++e){const r=n+e*m;if(r<0||r>=h.inWidth)continue;const a=i+r*I;let s=o+e*k[1];for(let e=0;e<h.inChannels;++e){const n=O[a+e*E];for(let e=0;e<h.outChannels;++e)_[t+e*A]+=n*F[s+e];s+=h.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,_)}const _B={kernelName:Qv,backendName:"cpu",kernelFunc:FB};const DB={kernelName:Zv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,pad:s,dataFormat:c,dimRoundingMode:l,filterShape:u}=r;jL([a,o],"conv2dBackpropFilter");const d=SC(c),h=pC(a.shape,u,i,1,s,l,!1,d),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=h,v="channelsLast"===h.dataFormat,b=new kw(h.filterShape,"float32"),y=h.padInfo.left,x=h.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(o.dataId).values,S=new kw(a.shape,a.dtype,w),C=new kw(o.shape,o.dtype,k);for(let I=0;I<g;++I){const e=Math.max(0,Math.ceil((x-I)/p)),t=Math.min(h.outHeight,(h.inHeight+x-I)/p);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((y-n)/f)),a=Math.min(h.outWidth,(h.inWidth+y-n)/f);for(let o=0;o<h.inChannels;++o)for(let i=0;i<h.outChannels;++i){let s=0;for(let c=0;c<h.batchSize;++c)for(let l=e;l<t;++l){const e=I+l*p-x;for(let t=r;t<a;++t){const r=n+t*f-y;s+=v?S.get(c,e,r,o)*C.get(c,l,t,i):S.get(c,o,e,r)*C.get(c,i,l,t)}}b.set(s,I,n,o,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const MB={kernelName:Jv,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{inputShape:i,strides:s,pad:c,dataFormat:l,dimRoundingMode:u}=r;jL([a,o],"conv2dBackpropInput");const d=av(o.shape),h=av(a.shape);let p=SC(l);const f=pC(i,o.shape,s,1,c,u,!1,p),g=new kw(f.inShape,"float32"),m=g.values,v=n.data.get(a.dataId).values,b=n.data.get(o.dataId).values,[y,x,w]=d,{batchSize:k,filterHeight:S,filterWidth:C,inChannels:I,inHeight:E,inWidth:N,outChannels:T,outHeight:R,outWidth:A,strideHeight:O,strideWidth:F}=f;p=f.dataFormat;const _=S-1-f.padInfo.top,D=C-1-f.padInfo.left,M="channelsLast"===p,P=g.strides[0],L=M?g.strides[1]:g.strides[2],z=M?g.strides[2]:1,B=M?1:g.strides[1],W=h[0],U=M?h[1]:h[2],V=M?h[2]:1,j=M?1:h[1];for(let H=0;H<k;++H)for(let e=0;e<I;++e)for(let t=0;t<E;++t){const n=t-_,r=Math.max(0,Math.ceil(n/O)),a=Math.min(R,(S+n)/O);for(let o=0;o<N;++o){const i=o-D,s=Math.max(0,Math.ceil(i/F)),c=Math.min(A,(C+i)/F);let l=0;for(let t=r;t<a;++t){const r=t*O-n;for(let n=s;n<c;++n){const a=W*H+U*t+V*n,o=y*(S-1-r)+x*(C-1-(n*F-i))+w*e;for(let e=0;e<T;++e){l+=v[a+j*e]*b[o+e]}}}m[P*H+L*t+z*o+B*e]=l}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const PB={kernelName:eb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dilations:c}=r;jL([a,o],"conv3d");const l=fC(a.shape,o.shape,i,c,s),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=l,v=m.front,b=m.left,y=m.top,x=new kw(l.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(o.dataId).values,S=x.values,C=av(a.shape),I=av(o.shape);for(let E=0;E<l.batchSize;++E){const e=E*C[0],t=E*x.strides[0];for(let n=0;n<l.outDepth;++n){const r=t+n*x.strides[1],a=n*l.strideDepth-v;for(let t=0;t<u;++t){const n=a+t*p;if(n<0||n>=l.inDepth)continue;const o=t*I[0],i=e+n*C[1];for(let e=0;e<l.outHeight;++e){const t=r+e*x.strides[2],n=e*l.strideHeight-y;for(let e=0;e<d;++e){const r=n+e*f;if(r<0||r>=l.inHeight)continue;const a=o+e*I[1],s=i+r*C[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,r=e*l.strideWidth-b;for(let e=0;e<h;++e){const t=r+e*g;if(t<0||t>=l.inWidth)continue;const o=a+e*I[2],i=s+t*l.inChannels;let c=o;for(let e=0;e<l.inChannels;++e){const t=w[i+e];for(let e=0;e<l.outChannels;++e)S[n+e]+=t*k[c+e];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const LB={kernelName:tb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,pad:s,filterShape:c}=r;jL([a,o],"conv3dBackpropFilterV2");const l=av(a.shape),u=av(o.shape),d=fC(a.shape,c,i,1,s),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,g=d.filterDepth,m=d.filterHeight,v=d.filterWidth,b=new kw(d.filterShape,"float32"),y=b.values,[x,w,k,S]=b.strides,C=n.data.get(o.dataId).values,[I,E,N,T]=u,R=n.data.get(a.dataId).values,[A,O,F,_]=l,D=d.padInfo.front,M=d.padInfo.left,P=d.padInfo.top;for(let L=0;L<g;++L){const e=Math.max(0,Math.ceil((D-L)/h)),t=Math.min(d.outDepth,(d.inDepth+D-L)/h),n=L*x;for(let r=0;r<m;++r){const a=Math.max(0,Math.ceil((P-r)/p)),o=Math.min(d.outHeight,(d.inHeight+P-r)/p),i=r*w+n;for(let n=0;n<v;++n){const s=Math.max(0,Math.ceil((M-n)/f)),c=Math.min(d.outWidth,(d.inWidth+M-n)/f),l=n*k+i;for(let i=0;i<d.inChannels;++i){const u=i*S+l;for(let l=0;l<d.outChannels;++l){let g=0;for(let u=0;u<d.batchSize;++u){const d=u*A,m=u*I;for(let u=e;u<t;++u){const e=(L+u*h-D)*O+d,t=u*E+m;for(let u=a;u<o;++u){const a=(r+u*p-P)*F+e,o=u*N+t;for(let e=s;e<c;++e){const t=e*T+o;g+=R[(n+e*f-M)*_+a+i]*C[t+l]}}}}y[u+l]=g}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const zB={kernelName:nb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{pad:i,strides:s,inputShape:c}=r;jL([a],"conv3dBackpropInputV2");const l=av(a.shape),u=av(o.shape),d=fC(c,o.shape,s,1,i),h=new kw(d.inShape,"float32"),p=h.values,[f,g,m,v]=h.strides,b=n.data.get(a.dataId).values,[y,x,w,k]=l,S=n.data.get(o.dataId).values,[C,I,E,N]=u,{batchSize:T,filterDepth:R,filterHeight:A,filterWidth:O,inChannels:F,inDepth:_,inHeight:D,inWidth:M,outChannels:P,outDepth:L,outHeight:z,outWidth:B,strideDepth:W,strideHeight:U,strideWidth:V}=d,j=R-1-d.padInfo.front,H=A-1-d.padInfo.top,G=O-1-d.padInfo.left;for(let q=0;q<T;++q)for(let e=0;e<F;++e)for(let t=0;t<_;++t){const n=t-j,r=Math.max(0,Math.ceil(n/W)),a=Math.min(L,(R+n)/W);for(let o=0;o<D;++o){const i=o-H,s=Math.max(0,Math.ceil(i/U)),c=Math.min(z,(A+i)/U);for(let l=0;l<M;++l){const u=l-G,d=Math.max(0,Math.ceil(u/V)),h=Math.min(B,(O+u)/V);let T=0;for(let t=r;t<a;++t){const r=t*W-n;for(let n=s;n<c;++n){const a=n*U-i;for(let o=d;o<h;++o){const i=y*q+x*t+w*n+k*o,s=C*(R-1-r)+I*(A-1-a)+E*(O-1-(o*V-u))+N*e;for(let e=0;e<P;++e){T+=b[i+e]*S[s+e]}}}}p[f*q+g*t+m*o+v*l+e]=T}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},BB=KL(rb,(e=>Math.cos(e))),WB={kernelName:rb,backendName:"cpu",kernelFunc:BB},UB=KL(ab,(e=>Math.cosh(e))),VB={kernelName:ab,backendName:"cpu",kernelFunc:UB};const jB={kernelName:sb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:o,boxInd:i}=t,{cropSize:s,method:c,extrapolationValue:l}=r,[u,d,h,p]=a.shape,f=o.shape[0],[g,m]=s,v=Jk([f,g,m,p],"float32"),b=n.data.get(o.dataId).values,y=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,w=av(a.shape),k=av(v.shape);for(let S=0;S<f;S++){const e=4*S,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],o=y[S];if(o>=u)continue;const i=g>1?(r-t)*(d-1)/(g-1):0,s=m>1?(a-n)*(h-1)/(m-1):0;for(let u=0;u<g;u++){const e=g>1?t*(d-1)+u*i:.5*(t+r)*(d-1);if(e<0||e>d-1)for(let t=0;t<m;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];v.values[n]=l}else if("bilinear"===c){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<m;e++){const c=m>1?n*(h-1)+e*s:.5*(n+a)*(h-1);if(c<0||c>h-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];v.values[n]=l}continue}const d=Math.floor(c),f=Math.ceil(c),g=c-d;for(let n=0;n<p;n++){let a=n+d*w[2]+t*w[1]+o*w[0];const s=x[a];a=n+f*w[2]+t*w[1]+o*w[0];const c=x[a];a=n+d*w[2]+r*w[1]+o*w[0];const l=x[a];a=n+f*w[2]+r*w[1]+o*w[0];const h=s+(c-s)*g,p=l+(x[a]-l)*g;a=n+e*k[2]+u*k[1]+S*k[0],v.values[a]=h+(p-h)*i}}}else for(let t=0;t<m;++t){const r=m>1?n*(h-1)+t*s:.5*(n+a)*(h-1);if(r<0||r>h-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];v.values[n]=l}continue}const i=Math.round(r),c=Math.round(e);for(let e=0;e<p;e++){const n=e+i*w[2]+c*w[1]+o*w[0],r=e+t*k[2]+u*k[1]+S*k[0];v.values[r]=x[n]}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const HB={kernelName:ob,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,exclusive:i,reverse:s}=r;jL(a,"cumprod");const c=mI([o],a.shape.length);let l=a;null!=c&&(l=Wz({inputs:{x:a},backend:n,attrs:{perm:c}}));const u=bI(1,a.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const d=Mw(l.dtype,"int32"),h=sv(Wm(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],g=s?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let v=0;v<p.length;v+=f)for(let e=0;e<f;e++){const t=g(v,e);if(0===e)h[t]=i?1:p[t];else{const n=g(v,e-1);h[t]=i?p[n]*h[n]:p[t]*h[n]}}const m=n.makeTensorInfo(l.shape,d,h);if(null!=c){const e=Wz({inputs:{x:m},backend:n,attrs:{perm:vI(c)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(l),e}return m}};const GB={kernelName:ib,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,exclusive:i,reverse:s}=r;jL(a,"cumsum");const c=mI([o],a.shape.length);let l=a;null!=c&&(l=Wz({inputs:{x:a},backend:n,attrs:{perm:c}}));const u=bI(1,a.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const d=Mw(l.dtype,"int32"),h=cv(Wm(l.shape),d),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],g=s?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let v=0;v<p.length;v+=f)for(let e=0;e<f;e++){const t=g(v,e);if(0===e)h[t]=i?0:p[t];else{const n=g(v,e-1);h[t]=i?p[n]+h[n]:p[t]+h[n]}}const m=n.makeTensorInfo(l.shape,d,h);if(null!=c){const e=Wz({inputs:{x:m},backend:n,attrs:{perm:vI(c)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(l),e}return m}};const qB={kernelName:cb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:o}=t,{size:i,binaryOutput:s}=r;if(1===a.shape.length){const e=gB(n.data.get(a.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,e)}if(2===a.shape.length){const e=mB(n.bufferSync(a),n.bufferSync(o),i,s);return n.makeTensorInfo(e.shape,o.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(a.shape.length,"."))}};const KB={kernelName:lb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:o,dataFormat:i}=r;Lm("NHWC"===i,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(i)));const s=a.shape[0],c=a.shape[1],l=a.shape[2],u=a.shape[3],d=c*o,h=l*o,p=u/(o*o),f=n.data.get(a.dataId).values,g=new Float32Array(s*d*h*p);let m=0;for(let v=0;v<s;++v)for(let e=0;e<d;++e){const t=Math.floor(e/o),n=e%o;for(let e=0;e<h;++e){const r=Math.floor(e/o),a=(n*o+e%o)*p;for(let e=0;e<p;++e){const n=e+a+u*(r+l*(t+c*v));g[m++]=f[n]}}}return n.makeTensorInfo([s,d,h,p],a.dtype,g)}};function XB(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dilations:c,dimRoundingMode:l}=r;jL([a,o],"depthwiseConv2DNative");const u=av(a.shape),d=av(o.shape);let h=c;null==h&&(h=[1,1]),Lm(wC(i,h),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(i," and dilations '").concat(h,"'")));const p=pC(a.shape,o.shape,i,h,s,l,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:v,padInfo:b}=p,y=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new kw(p.outShape,a.dtype),S=n.data.get(a.dataId).values,C=n.data.get(o.dataId).values,I=k.values;for(let E=0;E<p.batchSize;++E){const e=E*u[0],t=E*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],a=n*p.strideHeight-x;for(let t=0;t<f;++t){const n=a+t*m;if(n<0||n>=p.inHeight)continue;const o=t*d[0],i=e+n*u[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-y;for(let e=0;e<g;++e){const r=n+e*v;if(r<0||r>=p.inWidth)continue;const a=o+e*d[1],s=i+r*p.inChannels;let c=t,l=a;for(let e=0;e<p.inChannels;++e){const t=S[s+e];for(let e=0;e<w;++e)I[c+e]+=t*C[l+e];c+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const $B={kernelName:ub,backendName:"cpu",kernelFunc:XB};const YB={kernelName:db,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,dilations:s,pad:c,dimRoundingMode:l,filterShape:u}=r;jL([a,o],"depthwiseConv2dNativeBackpropFilter");const d=pC(a.shape,u,i,s,c,l,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:g}=d,m=new kw(d.filterShape,"float32"),v=d.padInfo.left,b=d.padInfo.top,y=d.outChannels/d.inChannels,x=n.data.get(a.dataId).values,w=new kw(a.shape,a.dtype,x),k=n.data.get(o.dataId).values,S=new kw(o.shape,o.dtype,k);for(let C=0;C<f;++C){const e=Math.max(0,Math.ceil((b-C)/h)),t=Math.min(d.outHeight,(d.inHeight+b-C)/h);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((v-n)/p)),a=Math.min(d.outWidth,(d.inWidth+v-n)/p);for(let o=0;o<d.outChannels;++o){const i=Math.trunc(o/y),s=o%y;let c=0;for(let l=0;l<d.batchSize;++l)for(let s=e;s<t;++s){const e=C+s*h-b;for(let t=r;t<a;++t){const r=n+t*p-v;c+=w.get(l,e,r,i)*S.get(l,s,t,o)}}m.set(c,C,n,i,s)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const QB={kernelName:hb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{strides:i,dilations:s,pad:c,dimRoundingMode:l,inputShape:u}=r;jL([a,o],"depthwiseConv2DNativeBackpropInput");const d=av(a.shape),h=av(o.shape),p=pC(u,o.shape,i,s,c,l,!0),f=new kw(p.inShape,"float32"),g=f.values,[m,v,b]=f.strides,y=n.data.get(a.dataId).values,[x,w,k]=d,S=n.data.get(o.dataId).values,[C,I,E]=h,{batchSize:N,filterHeight:T,filterWidth:R,inChannels:A,inHeight:O,inWidth:F,outChannels:_,outHeight:D,outWidth:M,strideHeight:P,strideWidth:L}=p,z=T-1-p.padInfo.top,B=R-1-p.padInfo.left,W=_/A;for(let U=0;U<N;++U)for(let e=0;e<A;++e)for(let t=0;t<O;++t){const n=t-z,r=Math.max(0,Math.ceil(n/P)),a=Math.min(D,(T+n)/P);for(let o=0;o<F;++o){const i=o-B,s=Math.max(0,Math.ceil(i/L)),c=Math.min(M,(R+i)/L);let l=0;for(let t=r;t<a;++t){const r=t*P-n;for(let n=s;n<c;++n){const a=x*U+w*t+k*n,o=C*(T-1-r)+I*(R-1-(n*L-i))+E*e;for(let t=0;t<W;++t){l+=y[a+(e*W+t)]*S[o+t]}}}g[m*U+v*t+b*o+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const ZB={kernelName:pb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=Wm(r.shape),o=n.data.get(r.dataId).values,i=Jk([a,a],r.dtype),s=i.values;for(let l=0;l<o.length;l++)s[l*a+l]=o[l];const c=[...r.shape,...r.shape];return n.makeTensorInfo(c,i.dtype,i.values)}},JB={kernelName:fb,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:o}=t,{strides:i,pad:s,dilations:c}=r,l=n,u=l.data.get(a.dataId).values,d=a.shape.length,h=l.data.get(o.dataId).values,p=o.shape.length,{batchSize:f,inHeight:g,inWidth:m,inChannels:v,outHeight:b,outWidth:y,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:C,dilationHeight:I,dilationWidth:E,outShape:N}=uC(a.shape,o.shape,i,s,"NHWC",c),T=Wm(N),R=N.length,A=Ym(a.dtype,T);for(let O=0;O<f;++O)for(let e=0;e<b;++e){const t=e*w-x.top;for(let n=0;n<y;++n){const r=n*k-x.left;for(let i=0;i<v;++i){let s=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*I;if(n>=0&&n<g)for(let t=0;t<C;++t){const c=r+t*E;if(c>=0&&c<m){const r=dv([O,n,c,i],d,av(a.shape)),l=dv([e,t,i],p,av(o.shape)),f=u[r]+h[l];f>s&&(s=f)}}}A[dv([O,e,n,i],R,av(N))]=s}}}return{dataId:l.write(ow(A,a.dtype),N,a.dtype),shape:N,dtype:a.dtype}}},eW={kernelName:mb,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:o,dy:i}=t,{strides:s,pad:c,dilations:l}=r,u=n,d=iv(a.shape,u.data.get(a.dataId).values),h=iv(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:v,outWidth:b,padInfo:y,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:C,dilationWidth:I,outShape:E}=uC(a.shape,o.shape,s,c,"NHWC",l);Lm(i.rank===E.length,(()=>"Error in ".concat(mb,", dy ")+"must have the same rank as output ".concat(E.length,", but got ")+"".concat(i.rank)));const N=iv(E,u.data.get(i.dataId).values),T=lv(o.shape,o.dtype);for(let R=0;R<p;++R)for(let e=0;e<v;++e){const t=e*x-y.top;for(let n=0;n<b;++n){const r=n*w-y.left;for(let a=0;a<m;++a){let o=Number.MIN_SAFE_INTEGER,i=0,s=0;for(let e=0;e<k;++e){const n=t+e*C;if(n>=0&&n<f)for(let t=0;t<S;++t){const c=r+t*I;if(c>=0&&c<g){const r=d[R][n][c][a]+h[e][t][a];r>o&&(o=r,i=e,s=t)}}}T[i][s][a]+=N[R][e][n][a]}}}return{dataId:u.write(ow(T,a.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},tW={kernelName:gb,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:o,dy:i}=t,{strides:s,pad:c,dilations:l}=r,u=n,d=iv(a.shape,u.data.get(a.dataId).values),h=iv(o.shape,u.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:v,outWidth:b,padInfo:y,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:C,dilationWidth:I,outShape:E}=uC(a.shape,o.shape,s,c,"NHWC",l);Lm(i.rank===E.length,(()=>"Error in ".concat(gb,", dy ")+"must have the same rank as output ".concat(E.length,", but got ")+"".concat(i.rank)));const N=iv(E,u.data.get(i.dataId).values),T=lv(a.shape,a.dtype);for(let R=0;R<p;++R)for(let e=0;e<v;++e){const t=e*x-y.top;for(let n=0;n<b;++n){const r=n*w-y.left;for(let a=0;a<m;++a){let o=Number.MIN_SAFE_INTEGER,i=t<0?0:t,s=r<0?0:r;for(let e=0;e<k;++e){const n=t+e*C;if(n>=0&&n<f)for(let t=0;t<S;++t){const c=r+t*I;if(c>=0&&c<g){const r=d[R][n][c][a]+h[e][t][a];r>o&&(o=r,i=n,s=c)}}}T[R][i][s][a]+=N[R][e][n][a]}}}return{dataId:u.write(ow(T,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};const nW={kernelName:vb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:o,options:i}=r,{contextOptions:s,imageOptions:c}=i||{},l=(null===c||void 0===c?void 0:c.alpha)||1,u=(null===s||void 0===s?void 0:s.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(s.contextType," is not supported by the CPU backend."));const d=o.getContext(u,(null===s||void 0===s?void 0:s.contextAttributes)||{});if(null==d)throw new Error("Could not get the context with ".concat(u," type."));const[h,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],g=n.data.get(a.dataId).values,m="float32"===a.dtype?255:1,v=new Uint8ClampedArray(p*h*4);for(let y=0;y<h*p;++y){const e=[0,0,0,255*l];for(let n=0;n<f;n++){const t=g[y*f+n];if("float32"===a.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===a.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===f?(e[0]=t*m,e[1]=t*m,e[2]=t*m):e[n]=t*m}const t=4*y;v[t+0]=Math.round(e[0]),v[t+1]=Math.round(e[1]),v[t+2]=Math.round(e[2]),v[t+3]=Math.round(e[3])}o.width=p,o.height=h;const b=new ImageData(v,p,h);return d.putImageData(b,0,0),a}},rW=tz(((e,t)=>e*t)),aW=kz(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),oW=wz(py,rW,aW),iW={kernelName:py,backendName:"cpu",kernelFunc:oW};function sW(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;let s;jL(a,"sum"),s="bool"===a.dtype?yz({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):QL({inputs:{x:a},backend:n});const c=s.shape.length,l=Km(o,s.shape),u=mI(l,c);let d=l,h=s;null!=u&&(h=Wz({inputs:{x:s},backend:n,attrs:{perm:u}}),d=bI(d.length,c)),gI("sum",d,h.shape.length);const[p,f]=pI(h.shape,d);let g=gz(n,p,Mw(h.dtype,"int32"));const m=Wm(f),v=n.data.get(g.dataId).values,b=n.data.get(h.dataId).values;for(let y=0;y<v.length;++y){const e=y*m;let t=0;for(let n=0;n<m;++n)t+=b[e+n];v[y]=t}if(i){const e=g;g=Nz({inputs:{x:g},backend:n,attrs:{shape:fI(g.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(s),null!=u&&n.disposeIntermediateTensorInfo(h),g}const cW={kernelName:ex,backendName:"cpu",kernelFunc:sW};const lW={kernelName:yb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,o=t,{allDims:i,summedDims:s,idDims:c}=nT(a,o.length);aT(i.length,c,o);const{path:l,steps:u}=oT(s,c),d=u.length;let h=null,p=i.length;const f=[];for(let g=0;g<d;++g){for(const e of u[g]){const{permutationIndices:t,expandDims:r}=rT(p,c[e]);let a;iT(t)?a=o[e]:(a=Wz({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Um(a.shape,i)||(a=Nz({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===h?h=a:(h=oW({inputs:{a:a,b:h},backend:n}),f.push(h))}g<d-1&&(l[g]>=0&&(h=sW({inputs:{x:h},backend:n,attrs:{axis:l[g]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const g of f)g!==h&&n.disposeIntermediateTensorInfo(g);return h}};const uW={kernelName:wb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:a}=t;jL([r,a],"eluGrad");const o=new Float32Array(Wm(a.shape)),i=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values;for(let c=0;c<i.length;++c){const e=i[c];o[c]=e>=0?s[c]:s[c]*(e+1)}return n.makeTensorInfo(a.shape,"float32",o)}},dW=tz(((e,t)=>e===t?1:0)),hW=wz(Sb,dW,null,"bool"),pW={kernelName:Sb,backendName:"cpu",kernelFunc:hW},fW=zN,gW=BN,mW=WN,vW=UN,bW=VN,yW=jN,xW=KL(kb,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+fW*n);return t*(1-((((yW*r+bW)*r+vW)*r+mW)*r+gW)*r*Math.exp(-n*n))})),wW={kernelName:kb,backendName:"cpu",kernelFunc:xW},kW=qL((e=>Math.exp(e))),SW=XL(Cb,kW,"float32"),CW={kernelName:Cb,backendName:"cpu",kernelFunc:SW};function IW(e){const{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:o}=r,i=a.shape.length,s=a.shape.slice();let c=o;return o<0&&(Lm(-(i+1)<=o,(()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]"))),c=i+o+1),s.splice(c,0,1),Nz({inputs:{x:a},backend:n,attrs:{shape:s}})}const EW={kernelName:Ib,backendName:"cpu",kernelFunc:IW},NW=qL((e=>Math.expm1(e))),TW=XL(Eb,NW),RW={kernelName:Eb,backendName:"cpu",kernelFunc:TW},AW=tz(((e,t)=>e/t)),OW=wz(bb,AW),FW={kernelName:bb,backendName:"cpu",kernelFunc:OW},_W=tz(((e,t)=>e-t)),DW=kz(((e,t,n,r)=>({real:e-n,imag:t-r}))),MW=wz(mx,_W,DW),PW={kernelName:mx,backendName:"cpu",kernelFunc:MW};function LW(e,t,n){const r=e.shape,a=r[0],o=r[1],i=n.data.get(e.dataId),s=i.complexTensorInfos.real,c=i.complexTensorInfos.imag,l=[a,o],u=Wm(l),d=$m("float32",u),h=$m("float32",u);for(let m=0;m<a;m++){const e=hB({inputs:{x:s},backend:n,attrs:{begin:[m,0],size:[1,o]}}),r=hB({inputs:{x:c},backend:n,attrs:{begin:[m,0],size:[1,o]}}),a=pz({inputs:{real:e,imag:r},backend:n}),{real:i,imag:l}=zW(a,t,n),u=HN(i,l);for(let t=0;t<o;t++){const e=XN(u,t);d[m*o+t]=e.real,h[m*o+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(l,"float32",d),f=n.makeTensorInfo(l,"float32",h),g=pz({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}function zW(e,t,n){const r=Wm(e.shape),a=n.data.get(e.dataId),o=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(0===((s=r)&s-1)){const a=BW(o,i,r,t,n),s=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(s,"float32",a.real),t=n.makeTensorInfo(s,"float32",a.imag),o=n.makeTensorInfo([],"float32",aw(r,"float32")),i=QL({inputs:{x:o},backend:n}),c=FW.kernelFunc({inputs:{a:e,b:o},backend:n}),l=FW.kernelFunc({inputs:{a:t,b:i},backend:n}),u=n.data.get(c.dataId).values,d=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),{real:u,imag:d}}return a}{const e=function(e,t,n){const r=new Float32Array(2*t);for(let a=0;a<t;a++){let o=0,i=0;for(let r=0;r<t;r++){const s=QN(a*r,t,n),c=XN(e,r);o+=c.real*s.real-c.imag*s.imag,i+=c.real*s.imag+c.imag*s.real}n&&(o/=t,i/=t),$N(r,o,i,a)}return r}(HN(o,i),r,t);return GN(e)}var s}function BW(e,t,n,r,a){if(1===n)return{real:e,imag:t};const o=HN(e,t),i=n/2,s=qN(o),c=s.real,l=s.imag,u=[c.length],d=a.makeTensorInfo(u,"float32",c),h=a.makeTensorInfo(u,"float32",l),p=pz({inputs:{real:d,imag:h},backend:a}),f=KN(o),g=f.real,m=f.imag,v=[g.length],b=a.makeTensorInfo(v,"float32",g),y=a.makeTensorInfo(v,"float32",m),x=pz({inputs:{real:b,imag:y},backend:a}),w=BW(c,l,i,r,a),k=w.real,S=w.imag,C=[k.length],I=a.makeTensorInfo(C,"float32",k),E=a.makeTensorInfo(C,"float32",S),N=pz({inputs:{real:I,imag:E},backend:a}),T=BW(g,m,i,r,a),R=T.real,A=T.imag,O=[R.length],F=a.makeTensorInfo(O,"float32",R),_=a.makeTensorInfo(O,"float32",A),D=pz({inputs:{real:F,imag:_},backend:a}),M=YN(n,r),P=[M.real.length],L=a.makeTensorInfo(P,"float32",M.real),z=a.makeTensorInfo(P,"float32",M.imag),B=pz({inputs:{real:L,imag:z},backend:a}),W=oW({inputs:{a:B,b:D},backend:a}),U=Iz({inputs:{a:N,b:W},backend:a}),V=MW({inputs:{a:N,b:W},backend:a}),j=mz({inputs:{input:U},backend:a}),H=mz({inputs:{input:V},backend:a}),G=TB({inputs:{input:U},backend:a}),q=TB({inputs:{input:V},backend:a}),K=AB({inputs:[j,H],backend:a,attrs:{axis:0}}),X=AB({inputs:[G,q],backend:a,attrs:{axis:0}}),$=a.data.get(K.dataId).values,Y=a.data.get(X.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(I),a.disposeIntermediateTensorInfo(E),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(_),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),a.disposeIntermediateTensorInfo(X),{real:$,imag:Y}}const WW={kernelName:Nb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=Wm(r.shape),o=r.shape[r.shape.length-1],i=Nz({inputs:{x:r},backend:n,attrs:{shape:[a/o,o]}}),s=LW(i,!1,n),c=Nz({inputs:{x:s},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),c}};function UW(e){const{backend:t,attrs:n}=e,{shape:r,value:a,dtype:o}=n,i=o||tv(a),s=Ym(i,Wm(r));return function(e,t,n){e.fill(t)}(s,a),t.makeTensorInfo(r,i,s)}const VW={kernelName:Tb,backendName:"cpu",kernelFunc:UW};const jW={kernelName:Rb,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,o=r,i=$m(a.dtype,Wm(a.shape)),[s,c,l,u]=a.shape,d=o.data.get(a.dataId).values;for(let h=0;h<s;h++){const e=h*l*c*u;for(let t=0;t<c;t++){const n=t*(l*u);for(let t=0;t<l;t++){const r=t*u;for(let a=0;a<u;a++){const o=Math.round(l-t-1),s=e+n+r+a;let c=d[s];if(o>=0&&o<l){c=d[e+n+o*u+a]}i[s]=c}}}}return{dataId:o.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},HW=qL((e=>Math.floor(e))),GW=XL(Ab,HW),qW={kernelName:Ab,backendName:"cpu",kernelFunc:GW},KW=tz(((e,t)=>Math.floor(e/t))),XW=wz(Ob,KW,null,"int32"),$W={kernelName:Ob,backendName:"cpu",kernelFunc:XW};const YW={kernelName:Ox,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o,bias:i,preluActivationWeights:s}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let g=FB({inputs:{x:a,filter:o},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(i){const e=g;if("NCHW"===u&&1===i.shape.length&&1!==i.shape[0]){const e=Nz({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});g=Iz({inputs:{a:g,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else g=Iz({inputs:{a:g,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=g;if("NCHW"===u&&"prelu"===p&&1===s.shape.length&&1!==s.shape[0]){const e=Nz({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});g=hz(n,g,p,e,f),n.disposeIntermediateTensorInfo(e)}else g=hz(n,g,p,s,f);n.disposeIntermediateTensorInfo(e)}return g}};const QW={kernelName:Fx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o,bias:i,preluActivationWeights:s}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let g=XB({inputs:{x:a,filter:o},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h}});if(i){const e=g;g=Iz({inputs:{a:g,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=g;g=hz(n,g,p,s,f),n.disposeIntermediateTensorInfo(e)}return g}};function ZW(e,t,n,r,a,o,i,s,c){const l=Jk([r,o],n);for(let u=0;u<r;u++){const n=[];let r=0;for(let t=0;t<a;t++){const o=e[u*a+t];r+=o*i[t],n.push(o)}if(r<0||r>=c/o)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(s));for(let e=0;e<o;e++)l.values[u*o+e]=t.get(...t.indexToLoc(r*o+e))}return l}const JW={kernelName:Db,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,o=Wm(r.shape),i=a.shape,s=i[i.length-1],[c,l,u,d]=FN(r,a);if(0===l)return n.makeTensorInfo(c,r.dtype,[]);const h=ZW(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,l,s,u,d,r.shape,o);return n.makeTensorInfo(c,r.dtype,h.values)}};function eU(e,t,n){const r=Jk(n,e.dtype);for(let a=0;a<r.size;++a){const n=r.indexToLoc(a).slice(),o=n[0],i=n[2],s=t.locToIndex([o,i]);n[2]=t.values[s];const c=e.locToIndex(n);0<=c&&c<e.values.length&&(r.values[a]=e.values[c])}return r}const tU={kernelName:_b,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:o}=t,{axis:i,batchDims:s}=r;jL([a,o],"gatherV2");const c=Km(i,a.shape)[0],l=n.data.get(o.dataId).values,u=a.shape[c];for(let y=0;y<l.length;++y){const e=l[y];Lm(e<=u-1&&e>=0,(()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]")))}let d=s;null==s&&(d=0);const h=Wm(o.shape),p=ST(a,o,c,d),f=Nz({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=Nz({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),m=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],v=n.bufferSync(g),b=eU(n.bufferSync(f),v,m);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},nU=tz(((e,t)=>e>t?1:0)),rU=wz(Mb,nU,null,"bool"),aU={kernelName:Mb,backendName:"cpu",kernelFunc:rU},oU=tz(((e,t)=>e>=t?1:0)),iU=wz(Pb,oU,null,"bool"),sU={kernelName:Pb,backendName:"cpu",kernelFunc:iU};const cU={kernelName:zb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=Wm(r.shape),o=r.shape[r.shape.length-1],i=Nz({inputs:{x:r},backend:n,attrs:{shape:[a/o,o]}}),s=LW(i,!0,n),c=Nz({inputs:{x:s},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),c}},lU=KL(Wb,(e=>Number.isFinite(e)?1:0),"bool"),uU={kernelName:Wb,backendName:"cpu",kernelFunc:lU},dU=KL(Ub,(e=>Math.abs(e)===1/0?1:0),"bool"),hU={kernelName:Ub,backendName:"cpu",kernelFunc:dU},pU=KL(Vb,(e=>Number.isNaN(e)?1:0),"bool"),fU={kernelName:Vb,backendName:"cpu",kernelFunc:pU},gU=tz(((e,t)=>e<t?1:0)),mU=wz(Hb,gU,null,"bool"),vU={kernelName:Hb,backendName:"cpu",kernelFunc:mU},bU=tz(((e,t)=>e<=t?1:0)),yU=wz(Gb,bU,null,"bool"),xU={kernelName:Gb,backendName:"cpu",kernelFunc:yU};function wU(e,t,n){const r=(t-e)/(n-1),a=cv(n,"float32");a[0]=e;for(let o=1;o<a.length;o++)a[o]=a[o-1]+r;return a}const kU={kernelName:qb,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:o}=n,i=wU(r,a,o);return t.makeTensorInfo([i.length],"float32",i)}},SU=qL((e=>Math.log(e))),CU=XL(Kb,SU),IU={kernelName:Kb,backendName:"cpu",kernelFunc:CU},EU=KL(Xb,(e=>Math.log1p(e))),NU={kernelName:Xb,backendName:"cpu",kernelFunc:EU},TU=tz(((e,t)=>e&&t)),RU=wz($b,TU,null,"bool"),AU={kernelName:$b,backendName:"cpu",kernelFunc:RU},OU=KL(Yb,(e=>e?0:1),"bool"),FU={kernelName:Yb,backendName:"cpu",kernelFunc:OU},_U=tz(((e,t)=>e||t)),DU=wz(Qb,_U,null,"bool"),MU={kernelName:Qb,backendName:"cpu",kernelFunc:DU};const PU={kernelName:Zb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:o,bias:i,alpha:s,beta:c}=r;jL(a,"LRN");const l=a.shape[3],u=l-1,d=n.data.get(a.dataId).values,h=Wm(a.shape),p=new Float32Array(h);function f(e){const t=e%l;let n=e-t+Math.max(0,t-o);const r=e-t+Math.min(t+o,u);let a=0;for(;n<=r;n++){const e=d[n];a+=e*e}return a}for(let g=0;g<h;g++){const e=f(g),t=d[g]*Math.pow(i+s*e,-c);p[g]=t}return n.makeTensorInfo(a.shape,a.dtype,p)}};const LU={kernelName:Jb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,y:o,dy:i}=t,{depthRadius:s,bias:c,alpha:l,beta:u}=r;jL(i,"LRNGrad");const d=Wm(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,g=n.data.get(o.dataId).values,m=new Float32Array(d),v=d;for(let b=0;b<v;b++){const e=b%h,t=b-e+Math.max(0,e-s),n=b-e+Math.min(h,e+s+1);let r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=l*r+c;for(let a=t;a<n;a++){let e=-2*l*u*f[a]*g[b]/r;b===a&&(e+=Math.pow(r,-u)),e*=p[b],m[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,m)}};function zU(e,t,n,r){const a=$m(r,Wm(n));for(let o=0;o<a.length;++o){const n=o*t;let r=e[n];for(let a=0;a<t;++a){const t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[o]=r}return a}function BU(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:o,keepDims:i}=r,s=n;let c=a.shape;const l=c.length,u=Km(o,c);let d=u;const h=mI(d,l);let p=s.data.get(a.dataId).values;if(null!=h){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=c[h[t]];p=Bz(p,c,a.dtype,h,e),d=bI(d.length,l),c=e}jL(a,"max"),gI("max",d,l);const[f,g]=pI(c,d),m=zU(p,Wm(g),f,a.dtype),v=s.write(m,f,a.dtype);let b=f;if(i){b=fI(f,u)}return{dataId:v,shape:b,dtype:a.dtype}}const WU={kernelName:ey,backendName:"cpu",kernelFunc:BU},UU=tz(((e,t)=>Math.max(e,t))),VU=wz(ty,UU),jU={kernelName:ty,backendName:"cpu",kernelFunc:VU};const HU={kernelName:ny,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;jL(a,"maxPool");const{filterSize:o,strides:i,pad:s,dimRoundingMode:c}=r;Lm(wC(i,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'")));const l=dC(a.shape,o,i,1,s,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&Um(l.inShape,l.outShape))u=QL({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=av(a.shape),r=rB(e,a.shape,a.dtype,t,l,"max");u=n.makeTensorInfo(l.outShape,a.dtype,r.values)}return u}};const GU={kernelName:ay,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:o,strides:i,pad:s,dimRoundingMode:c,dataFormat:l}=r;jL(a,"maxPool3d");const u=hC(a.shape,o,i,1,s,c,l),d=oB(n.data.get(a.dataId).values,a.shape,a.dtype,av(a.shape),u,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};const qU={kernelName:oy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,{filterSize:i,strides:s,pad:c,dimRoundingMode:l}=r;jL([a,o],"maxPool3DGrad");const u=hC(o.shape,i,s,1,c,l),d=function(e,t){const n=Jk(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,s=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let m=0;m<t.inChannels;++m)for(let v=0;v<t.outDepth;++v){const b=v*r-h;let y=b;for(;y<0;)y+=i;const x=Math.min(t.inDepth,l+b);for(let r=0;r<t.outHeight;++r){const l=r*a-p;let h=l;for(;h<0;)h+=s;const w=Math.min(t.inHeight,u+l);for(let a=0;a<t.outWidth;++a){const p=a*o-f;let k=p;for(;k<0;)k+=c;const S=Math.min(t.inWidth,d+p);let C=Number.NEGATIVE_INFINITY,I=-1;for(let t=y;t<x;t+=i){const n=t-b;for(let r=h;r<w;r+=s){const a=r-l;for(let o=k;o<S;o+=c){const i=o-p,s=e.get(g,t,r,o,m);s>=C&&(C=s,I=n*u*d+a*u+i)}}}n.set(I,g,v,r,a,m)}}}return n}(n.bufferSync(o),u),h=u.strideDepth,p=u.strideHeight,f=u.strideWidth,g=u.dilationDepth,m=u.dilationHeight,v=u.dilationWidth,b=u.effectiveFilterDepth,y=u.effectiveFilterHeight,x=u.effectiveFilterWidth,w=b-1-u.padInfo.front,k=x-1-u.padInfo.left,S=y-1-u.padInfo.top,C=Jk(o.shape,"float32"),I=n.bufferSync(a);for(let E=0;E<u.batchSize;++E)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){const a=t-w,o=n-S,i=r-k;let s=0;for(let t=0;t<b;t+=g){const n=(a+t)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let r=0;r<y;r+=m){const a=(o+r)/p;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let o=0;o<x;o+=v){const c=(i+o)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;const l=b*y*x-1-d.get(E,n,a,c,e)===t*y*x+r*x+o?1:0;if(0===l)continue;s+=I.get(E,n,a,c,e)*l}}}C.set(s,E,t,n,r,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const KU={kernelName:ry,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o,output:i}=t,s=o;jL([o,i],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=r,h=dC(s.shape,c,l,1,u,d),p=n.data.get(s.dataId).values,f=Jk(h.outShape,s.dtype,aB(p,s.shape,s.dtype,h).values),g=h.strideHeight,m=h.strideWidth,v=h.dilationHeight,b=h.dilationWidth,y=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,k=y-1-h.padInfo.top,S=Jk(s.shape,"float32"),C=n.data.get(a.dataId).values,I=Jk(a.shape,"float32",C);for(let E=0;E<h.batchSize;++E)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){const r=t-k,a=n-w;let o=0;for(let t=0;t<y;t+=v){const n=(r+t)/g;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){const i=(a+r)/m;if(i<0||i>=h.outWidth||Math.floor(i)!==i)continue;const s=y*x-1-f.get(E,n,i,e)===t*x+r?1:0;if(0===s)continue;o+=I.get(E,n,i,e)*s}}S.set(o,E,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const XU={kernelName:iy,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:o,strides:i,pad:s,includeBatchInIndex:c}=n,l=r;jL(a,"MaxPoolWithArgmax");const u=l.data.get(a.dataId).values,d=dC(a.shape,o,i,[1,1],s),[h,p]=function(e,t,n,r,a){const o=rB(e,0,n,av(t),a,"max"),i=aB(e,t,n,a,!0,r);return[o.values,i.values]}(u,a.shape,a.dtype,c,d),f=l.write(h,d.outShape,a.dtype),g=l.write(p,d.outShape,a.dtype);return[{dataId:f,shape:d.outShape,dtype:a.dtype},{dataId:g,shape:d.outShape,dtype:"int32"}]}};const $U={kernelName:sy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r,s=Km(o,a.shape),c=Wm(pI(a.shape,s)[1]),l=[],u=n.makeTensorInfo([],"float32",new Float32Array([c]));l.push(u);const d=yz({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});l.push(d);const h=OW({inputs:{a:d,b:u},backend:n});l.push(h);const p=sW({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:i}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const YU={kernelName:cy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;jL(a,"min");const s=Km(o,a.shape);let c=s;const l=mI(c,a.shape.length);let u=a;null!=l&&(u=Wz({inputs:{x:a},backend:n,attrs:{perm:l}}),c=bI(c.length,a.shape.length)),gI("min",c,u.shape.length);const[d,h]=pI(u.shape,c),p=Wm(h),f=cv(Wm(d),u.dtype),g=n.data.get(u.dataId).values;for(let v=0;v<f.length;++v){const e=v*p;let t=g[e];for(let n=0;n<p;++n){const r=g[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[v]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const m=n.makeTensorInfo(d,u.dtype,f);if(i){const e=Nz({inputs:{x:m},backend:n,attrs:{shape:fI(d,s)}});return n.disposeIntermediateTensorInfo(m),e}return m}},QU=tz(((e,t)=>Math.min(e,t))),ZU=wz(ly,QU),JU={kernelName:ly,backendName:"cpu",kernelFunc:ZU};const eV={kernelName:uy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:o,mode:i}=r;jL(a,"mirrorPad");const s=o.map(((e,t)=>e[0]+a.shape[t]+e[1])),c=o.map((e=>e[0])),l=o.map(((e,t)=>e[0]+a.shape[t])),u="reflect"===i?0:1,d=n.data.get(a.dataId).values,h=a.shape.length,p=av(a.shape),f=Wm(s),g=s.length,m=av(s),v=$m(a.dtype,f);for(let b=0;b<f;b++){let e=hv(b,g,m);for(let n=0;n<g;n++)e[n]<c[n]?e[n]=2*c[n]-e[n]-u:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+u);e=e.map(((e,t)=>e-c[t]));const t=dv(e,h,p);v[b]=d[t]}return{dataId:n.write(v,s,a.dtype),shape:s,dtype:a.dtype}}},tV=tz(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),nV=wz(dy,tV),rV={kernelName:dy,backendName:"cpu",kernelFunc:nV};function aV(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:o}=r,i=a.shape.length;let s=o;if(-1===s&&(s=i-1),s!==i-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(i," and dim was ").concat(s));const c=Km([s],a.shape),l=BU({inputs:{x:a},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),u=fI(l.shape,c),d=Nz({inputs:{x:l},backend:n,attrs:{shape:u}}),h=MW({inputs:{a:a,b:d},backend:n}),p=SW({inputs:{x:h},backend:n}),f=sW({inputs:{x:p},backend:n,attrs:{axis:c,keepDims:!1}}),g=Nz({inputs:{x:f},backend:n,attrs:{shape:u}}),m=OW({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}const oV={kernelName:rx,backendName:"cpu",kernelFunc:aV};const iV={kernelName:hy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:o,seed:i,normalized:s}=r;jL(a,"multinomial");const c=s?a:aV({inputs:{logits:a},backend:n,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],d=n.data.get(c.dataId).values,h=[l,o],p=cv(Wm(h),"int32");for(let f=0;f<l;++f){const e=f*u,t=new Float32Array(u-1);t[0]=d[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+d[e+a];const n=PI.alea(i.toString()),r=f*o;for(let a=0;a<o;++a){const e=n();p[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+a]=n;break}}}return s||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(h,"int32",p)}};function sV(e,t,n){const r=aw(-1,n);return rW([],t,r,e,n)}const cV={kernelName:fy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;jL(r,"neg");const a=n.data.get(r.dataId).values,[o,i]=sV(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,o)}},lV=zE;const uV={kernelName:my,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:c}=r;jL(a,"NonMaxSuppression");const l=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values,{selectedIndices:d}=lV(l,u,i,s,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},dV=BE;const hV={kernelName:vy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:c,padToMaxOutputSize:l}=r;jL(a,"NonMaxSuppressionPadded");const u=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,{selectedIndices:h,validOutputs:p}=dV(u,d,i,s,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},pV=WE;const fV={kernelName:by,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:c,softNmsSigma:l}=r;jL(a,"NonMaxSuppressionWithScore");const u=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,h=i,p=s,f=c,g=l,{selectedIndices:m,selectedScores:v}=pV(u,d,h,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}},gV=tz(((e,t)=>e!==t?1:0)),mV=wz(gy,gV,null,"bool"),vV={kernelName:gy,backendName:"cpu",kernelFunc:mV};const bV={kernelName:xy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:o,depth:i,onValue:s,offValue:c}=r;jL(a,"oneHot");const l=Wm(a.shape),u=new Float32Array(l*i);u.fill(c);const d=n.data.get(a.dataId).values;for(let h=0;h<l;++h)d[h]>=0&&d[h]<i&&(u[h*i+d[h]]=s);return n.makeTensorInfo([...a.shape,i],o,u)}};function yV(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=mz({inputs:{input:r},backend:n}),t=yV({inputs:{x:e},backend:n}),a=TB({inputs:{input:r},backend:n}),o=yV({inputs:{x:a},backend:n}),i=pz({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),i}return UW({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const xV={kernelName:Ex,backendName:"cpu",kernelFunc:yV};const wV={kernelName:yy,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const t=mz({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),o=TB({inputs:{input:a},backend:r}),i=yV({inputs:{x:o},backend:r}),s=pz({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),s}return UW({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function kV(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return IW({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const o=t[0].shape,i=t[0].dtype;t.forEach((e=>{zm(o,e.shape,"All tensors passed to stack must have matching shapes"),Lm(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const s=[],c=AB({inputs:t.map((e=>{const t=IW({inputs:{input:e},backend:n,attrs:{dim:a}});return s.push(t),t})),backend:n,attrs:{axis:a}});return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const SV={kernelName:wy,backendName:"cpu",kernelFunc:kV};const CV={kernelName:ky,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:o,constantValue:i}=r;jL(a,"pad");const s=o.map(((e,t)=>e[0]+a.shape[t]+e[1])),c=o.map((e=>e[0])),l=n.data.get(a.dataId).values,u=Wm(a.shape),d=a.shape.length,h=av(a.shape),p=Wm(s),f=s.length,g=av(s),m=$m(a.dtype,p);0!==i&&m.fill(i);for(let v=0;v<u;v++){m[dv(hv(v,d,h).map(((e,t)=>e+c[t])),f,g)]=l[v]}return{dataId:n.write(m,s,a.dtype),shape:s,dtype:a.dtype}}},IV=tz(((e,t)=>Math.pow(e,t))),EV=wz(Sy,IV),NV={kernelName:Sy,backendName:"cpu",kernelFunc:EV};function TV(e,t,n,r){const[a,o]=pI(e,r),i=Mw(t,"int32"),s=cv(Wm(a),i),c=Wm(o);for(let l=0;l<s.length;++l){const e=l*c;let t=1;for(let r=0;r<c;++r)t*=n[e+r];s[l]=t}return{outVals:s,outShape:a,outDtype:i}}const RV={kernelName:Iy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;jL(a,"prod");const s=a.shape.length,c=Km(o,a.shape),l=mI(c,s);let u=c,d=a;const h=[];null!=l&&(d=Wz({inputs:{x:a},backend:n,attrs:{perm:l}}),h.push(d),u=bI(u.length,s));const p=n.data.get(d.dataId).values,{outVals:f,outShape:g,outDtype:m}=TV(d.shape,d.dtype,p,u);let v=g;return i&&(v=fI(g,c)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(v,m,f)}};function AV(e,t,n,r){const a=[];let o=0;const i=t.length-1+n.length,s=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let c=1;for(let l=0;l<t.length-1;++l){c*=t[l];const e=t[l+1];for(let t=1;t<c+1;++t)s[l].push(t*e)}for(let l=0;l<e.length;++l){let r=e[l],i=e[l]+1;for(let e=0;e<n.length;++e){const a=n[e],o=e+t.length-1;if(o>=0){const e=s[o],t=e[e.length-1]-a[r];for(let n=r;n<i;++n)s[o].push(a[n+1]+t)}r=a[r],i=a[i]}i!==r&&(a.push([r,i]),o+=i-r)}return{outSplits:s,valueSlices:a,numValues:o}}function OV(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function FV(e,t,n,r,a){const o=t.slice();o[0]=a;const i=Ym(n,Wm(o)),s=e.length;return function(e,t,n,r,a,o){const i=OV(t,2)[1],s=OV(o,2)[1];let c=0;for(const l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<r;++n)a[c*s+n]=e[t*i+n];++c}}(e,t,r,0===s?0:s/t[0],i,o),[i,o]}function _V(e,t,n,r,a,o,i,s){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const a=hv(r,t.length,av(t)).join(",");throw new Error("indices[".concat(a,"] = ").concat(e," is not in [0, ").concat(n,")"))}}))}(o,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:l,valueSlices:u,numValues:d}=AV(o,i,e,c),h=function(e){const t=[];for(let n=0;n<e.length;++n){const r=Ym("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(l),p=FV(n,r,a,u,d);return[h,p[0],p[1]]}const DV={kernelName:Ey,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:o,indices:i}=t,{outputRaggedRank:s}=r,c=a.map((e=>n.data.get(e.dataId).values)),l=a.map((e=>e.shape)),u=n.data.get(o.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=_V(c,l,u,o.shape,o.dtype,d,i.shape),g=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),m=n.makeTensorInfo(f,o.dtype,p);return g.concat([m])}},MV=2147483647;function PV(e,t,n,r,a,o,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const s=0===t.length,c=0===a.length,l=0===i.length,u=[];s||u.push(t[0]),c||u.push(a[0]),l||u.push(i[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===u.length?1:u[0],h=Ym("int32",d+1);h[0]=0;for(let g=0;g<d;++g){const t=s?e[0]:e[g],n=c?r[0]:r[g],a=l?o[0]:o[g];if(0===a)throw new Error("Requires delta != 0");let i;if(a>0&&n<t||a<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/a)),i>MV)throw new Error("Requires ((limit - start) / delta) <= ".concat(MV));h[g+1]=h[g]+i}const p=Ym(n,h[d]);let f=0;for(let g=0;g<d;++g){const t=h[g+1]-h[g];let n=s?e[0]:e[g];const r=l?o[0]:o[g];for(let e=0;e<t;++e)p[f++]=n,n+=r}return[h,p]}const LV={kernelName:Ny,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:o}=t,i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values,[l,u]=PV(i,r.shape,r.dtype,s,a.shape,c,o.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],r.dtype,u)]}};var zV=yN;class BV{constructor(e,t,n,r,a,o,i,s,c,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=o,this.defaultValueShape=i,this.rowPartitionValues=s,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=wN(l),this.raggedRank=kN(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===zV.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===zV.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case zV.VALUE_ROWIDS:return BV.getMaxWidthValueRowID(t);case zV.ROW_SPLITS:return BV.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(zV[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let o=1;o<t;++o){const t=e[o];t!==r&&(r=t,a=Math.max(o-n,a),n=o)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return UV(e,n)}calculateOutputSize(e){const t=this.valuesShape;SN(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=xN(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let a=1;a<=this.raggedRank;++a)r[a]<0&&(r[a]=this.getMaxWidth(a));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),a=[];let o=0;for(let i=0;i<r;++i,o+=t)a.push(o);for(let i=r;i<e;++i)a.push(-1);return Lm(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){const a=e.length,o=[];for(let i=0;i<a-1;++i){const a=e[i+1]-e[i];let s=Math.min(r,a),c=t[i];-1===c&&(s=0);for(let e=0;e<s;++e)o.push(c),c+=n;for(let e=0;e<a-s;++e)o.push(-1)}if(a>0&&o.length!==e[a-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,n,r){const a=e.length,o=[];if(0===a)return[];let i=0,s=e[0];if(s>=t.length)throw new Error("Got currentValueRowId=".concat(s,", which is not less than ").concat(t.length));let c=t[s];o.push(c);for(let l=1;l<a;++l){const a=e[l];if(a===s)c>=0&&(++i,i<r?c+=n:c=-1);else{if(i=0,s=a,a>=t.length)throw new Error("Got nextValueRowId=".concat(a," which is not less than ").concat(t.length));c=t[a]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,n,r){const a=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case zV.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case zV.ROW_SPLITS:if(a.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(a.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error("Unsupported partition type: ".concat(zV[o]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case zV.FIRST_DIM_SIZE:return e[0];case zV.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case zV.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(zV[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let o=n.length-2;o>=0;--o)n[o]=n[o+1]*t[o+1];const r=UV(t,!1),a=Ym(this.valuesDType,Wm(r));if(n[0]*t[0]>0){let o=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){o=this.calculateOutputIndex(e-1,o,n[e],t[e])}this.setOutput(this.raggedRank,o,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;const a=this.values,o=n;let i=r.slice();i=i.slice(e+1);const s=Wm(i),c=t.length;let l=this.defaultValue;if(l.length!==s&&1!==l.length){const e=this.defaultValueShape;dk((()=>{const t=IC(l,e),n=FC(t,i);l=n.dataSync()}))}let u=0,d=0,h=0;for(let p=0;p<=c;++p){let e=p<c?t[p]:-1;if(e!==h){if(d<h){const e=a.subarray(u*s);WV(o.subarray(d*s),e,(h-d)*s)}if(p>=c){const t=n.length;e=Math.floor(t/s)}if(e>h)if(1===this.defaultValue.length)o.subarray(h*s,e*s).fill(this.defaultValue[0]),h=e;else for(;e>h;){WV(o.slice(h*s),l,s),++h}e<0?(u=p+1,d=h):(u=p,d=h,h=d+1)}else++h}}}function WV(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function UV(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error("Dimension ".concat(r," must be >= 0"));if(r<-1)throw new Error("Dimension ".concat(r," must be >= -1"));r=-1}n.push(r)}return n}function VV(e,t,n,r,a,o,i,s,c,l){return new BV(e,t,n,r,a,o,i,s,c,l).compute()}const jV={kernelName:Ty,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:o,defaultValue:i,rowPartitionTensors:s}=t,{rowPartitionTypes:c}=r,l=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values,d=n.data.get(i.dataId).values,h=s.map((e=>n.data.get(e.dataId).values)),p=s.map((e=>e.shape)),[f,g]=VV(l,a.shape,u,o.shape,o.dtype,d,i.shape,h,p,c);return n.makeTensorInfo(f,o.dtype,g)}};function HV(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return cv(0,r);const a=cv(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),a[0]=e;for(let o=1;o<a.length;o++)a[o]=a[o-1]+n;return a}const GV={kernelName:Ry,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,dtype:o,step:i}=n,s=HV(r,a,i,o);return t.makeTensorInfo([s.length],o,s)}},qV=KL(Oy,(e=>1/e)),KV={kernelName:Oy,backendName:"cpu",kernelFunc:qV};const XV={kernelName:Py,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:o,halfPixelCenters:i,size:s}=r;jL(a,"resizeBilinear");const c=av(a.shape),[l,u]=s,[d,h,p,f]=a.shape,g=n.data.get(a.dataId).values,m=new Float32Array(Wm([d,l,u,f])),v=[o&&l>1?h-1:h,o&&u>1?p-1:p],b=[o&&l>1?l-1:l,o&&u>1?u-1:u];let y=0;const x=v[0]/b[0],w=v[1]/b[1];for(let k=0;k<d;k++)for(let e=0;e<l;e++){let t;t=i?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(h-1,Math.ceil(t)),o=k*c[0]+n*c[1],s=k*c[0]+a*c[1];for(let e=0;e<u;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),a=t-n,l=Math.min(p-1,Math.ceil(t)),u=o+n*c[2],d=s+n*c[2],h=o+l*c[2],v=s+l*c[2];for(let e=0;e<f;e++){const t=g[u+e],n=g[d+e],o=t+(g[h+e]-t)*a,i=o+(n+(g[v+e]-n)*a-o)*r;m[y++]=i}}}return n.makeTensorInfo([d,l,u,f],"float32",m)}};const $V={kernelName:Ly,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:o}=t,{alignCorners:i}=r;jL([o,a],"resizeBilinearGrad");const s=av(a.shape),[c,l,u,d]=a.shape,[,h,p]=o.shape,f=new Float32Array(c*l*u*d),g=[i&&h>1?l-1:l,i&&p>1?u-1:u],m=[i&&h>1?h-1:h,i&&p>1?p-1:p],v=g[0]/m[0],b=g[1]/m[1],y=n.data.get(o.dataId).values;let x=0;for(let w=0;w<c;w++){const e=w*s[0];for(let t=0;t<h;t++){const n=t*v,r=Math.floor(n),a=Math.min(Math.ceil(n),l-1),o=e+r*s[1],i=e+a*s[1],c=n-r,h=1-c;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),u-1),a=t-n,l=1-a,p=o+n*s[2],g=o+r*s[2],m=i+n*s[2],v=i+r*s[2],w=h*l,k=h*a,S=c*l,C=c*a;for(let e=0;e<d;e++){const t=y[x++];f[p+e]+=t*w,f[g+e]+=t*k,f[m+e]+=t*S,f[v+e]+=t*C}}}}return n.makeTensorInfo([c,u,l,d],"float32",f)}};const YV={kernelName:Dy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:o,halfPixelCenters:i,size:s}=r;jL(a,"resizeNearestNeighbor");const c=av(a.shape),[l,u]=s,[d,h,p,f]=a.shape,g=n.data.get(a.dataId).values,m=new Float32Array(d*l*u*f),v=[o&&l>1?h-1:h,o&&u>1?p-1:p],b=[o&&l>1?l-1:l,o&&u>1?u-1:u],y=v[0]/b[0],x=v[1]/b[1];let w=0;for(let k=0;k<d;k++){const e=k*c[0];for(let t=0;t<l;t++){const n=i?y*(t+.5):y*t;let r=Math.min(h-1,o?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const a=e+r*c[1];for(let e=0;e<u;e++){const t=i?x*(e+.5):x*e;let n=Math.min(p-1,o?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=a+n*c[2];for(let e=0;e<f;e++){const t=g[r+e];m[w++]=t}}}}return n.makeTensorInfo([d,l,u,f],a.dtype,m)}};const QV={kernelName:My,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:o}=t,{alignCorners:i}=r;jL([o,a],"resizeNearestNeighborGrad");const s=av(a.shape),c=av(o.shape),[l,u,d,h]=a.shape,[,p,f]=o.shape,g=new Float32Array(l*u*d*h),m=n.data.get(o.dataId).values,v=[i&&p>1?u-1:u,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],y=v[0]/b[0],x=v[1]/b[1],w=1/y,k=1/x,S=2*Math.ceil(w)+2,C=2*Math.ceil(k)+2;for(let I=0;I<l;I++){const e=I*s[0];for(let t=0;t<u;t++){const n=e+t*s[1],r=Math.floor(t*w),a=Math.floor(r-S/2);for(let o=0;o<d;o++){const r=n+o*s[2],l=Math.floor(o*k),v=Math.floor(l-C/2);for(let n=0;n<h;n++){let s=0;for(let r=0;r<S;r++){const l=r+a;if(l<0||l>=p)continue;const h=e+l*c[1],g=l*y;if(t===Math.min(u-1,i?Math.round(g):Math.floor(g)))for(let e=0;e<C;e++){const t=e+v;if(t<0||t>=f)continue;const r=h+t*c[2],a=t*x;o===Math.min(d-1,i?Math.round(a):Math.floor(a))&&(s+=m[r+n])}}g[r+n]=s}}}}return n.makeTensorInfo(a.shape,a.dtype,g)}};const ZV={kernelName:By,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:o}=r;jL(a,"reverse");const i=a.shape.length,s=Km(o,a.shape);if(0===i)return QL({inputs:{x:a},backend:n});const c=new kw(a.shape,a.dtype),l=n.bufferSync(a);for(let u=0;u<c.size;u++){const e=c.indexToLoc(u),t=e.slice();s.forEach((e=>t[e]=a.shape[e]-1-t[e])),c.set(l.get(...t),...e)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},JV={kernelName:Rx,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:o,fillValue:i,center:s}=n,c=r,l=$m(a.dtype,Wm(a.shape)),[u,d,h,p]=a.shape,[f,g]=EN(s,d,h),m=Math.sin(o),v=Math.cos(o),b=c.data.get(a.dataId).values;for(let y=0;y<u;y++){const e=y*h*d*p;for(let t=0;t<d;t++){const n=t*(h*p);for(let r=0;r<h;r++){const a=r*p;for(let o=0;o<p;o++){const s=[u,t,r,o],c=s[2],y=s[1];let x=(c-f)*v-(y-g)*m,w=(c-f)*m+(y-g)*v;x=Math.round(x+f),w=Math.round(w+g);let k=i;if("number"!==typeof i&&(k=3===o?255:i[o]),x>=0&&x<h&&w>=0&&w<d){k=b[e+w*(h*p)+x*p+o]}l[e+n+a+o]=k}}}}return{dataId:c.write(l,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},ej=KL(Wy,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),tj={kernelName:Wy,backendName:"cpu",kernelFunc:ej},nj=qL((e=>1/Math.sqrt(e))),rj=XL(Uy,nj),aj={kernelName:Uy,backendName:"cpu",kernelFunc:rj};function oj(e,t,n,r,a,o,i,s,c,l){const u=[r/a,a],d=e.values,h=t.values;if(0===r)return Jk(n,t.dtype);const p=c instanceof kw?c:Jk(u,t.dtype);"string"===typeof c||"number"===typeof c?p.values.fill(c):"boolean"===typeof c&&p.values.fill(+c);for(let f=0;f<o;f++){const e=[];let o=0;for(let t=0;t<i;t++){const n=d[f*i+t];e.push(n),o+=n*s[t]}if(o<0||o>=r/a)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<a;n++)l?p.values[o*a+n]+=h[f*a+n]:p.values[o*a+n]=0===t.rank?h[0]:h[f*a+n]}return p}const ij={kernelName:Vy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:o}=t,{shape:i}=r,{sliceRank:s,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=MN(0,a,i),h=oj(n.bufferSync(a),n.bufferSync(o),i,d,l,c,s,u,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function sj(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function cj(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}const lj={kernelName:Hy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:o}=t,{side:i}=r,s=function(e,t,n,r,a,o){const i=Ym("int32",n*a);for(let s=0;s<n;++s){const n=e.slice(s*r,(s+1)*r),c=s*a;for(let e=0;e<a;++e)i[c+e]="left"===o?sj(n,t[e+c]):cj(n,t[e+c])}return i}(n.data.get(a.dataId).values,n.data.get(o.dataId).values,a.shape[0],a.shape[1],o.shape[1],i);return n.makeTensorInfo(o.shape,"int32",s)}};const uj={kernelName:Gy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:o}=t;jL([r,a,o],"select");const i=r.shape.length,s=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,l=n.data.get(o.dataId).values,u=Mw(a.dtype,o.dtype),d=cv(Wm(a.shape),u);let h=0;const p=0===i||i>1||1===a.shape.length?1:Wm(a.shape.slice(1));for(let f=0;f<s.length;f++)for(let e=0;e<p;e++)1===s[f]?d[h++]=c[f]:d[h++]=l[f];return n.makeTensorInfo(a.shape,u,d)}},dj=PN,hj=LN,pj=KL(qy,(e=>e>=0?hj*e:dj*(Math.exp(e)-1))),fj={kernelName:qy,backendName:"cpu",kernelFunc:pj},gj=KL(Yy,(e=>e<0?-1:e>0?1:0)),mj={kernelName:Yy,backendName:"cpu",kernelFunc:gj},vj=KL(Xy,(e=>Math.sin(e))),bj={kernelName:Xy,backendName:"cpu",kernelFunc:vj},yj=KL($y,(e=>Math.sinh(e))),xj={kernelName:$y,backendName:"cpu",kernelFunc:yj},wj=Math.log(1.1920928955078125e-7)+2,kj=KL(Zy,(e=>{const t=e>-wj,n=e<wj,r=Math.exp(e);let a;return a=n?r:t?e:Math.log(1+r),a})),Sj={kernelName:Zy,backendName:"cpu",kernelFunc:kj};const Cj={kernelName:tx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:o,paddings:i}=r;jL([a],"spaceToBatchND");const s=Wm(o),c=[[0,0]];c.push(...i);for(let m=1+o.length;m<a.shape.length;++m)c.push([0,0]);const l=CV.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:c,constantValue:0}}),u=NN(l.shape,o,s,!1),d=TN(u.length,o.length,!1),h=RN(l.shape,o,s,!1),p=Nz({inputs:{x:l},backend:n,attrs:{shape:u}}),f=Wz({inputs:{x:p},backend:n,attrs:{perm:d}}),g=Nz({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}};function Ij(e,t,n,r,a,o,i){const s=t[0],c=o[0],l=new Array(c),u=new Array(s),d=t[1];if(0===c){if(0!==s)throw new Error(lT(s));return[Ym(n,0),[0,d],Ym(a,0),l,u]}let h=!0,p=0;const f=new Array(c).fill(0);for(let m=0;m<s;++m){const t=e[m*d];if(t<0)throw new Error(uT(m,t));if(t>=c)throw new Error(dT(m,t,c));++f[t],h=h&&t>=p,p=t}let g=!0;for(let m=0;m<c;++m){const e=0===f[m];l[m]=e,g=g&&!e,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&h){const t=e,n=r;for(let e=0;e<s;++e)u[e]=e;return[t,[s,d],n,l,u]}{const t=f[c-1],o=Ym(n,t*d),h=Ym(a,t),p=new Array(c).fill(0);for(let n=0;n<s;++n){const t=e[n*d],a=p[t],i=(0===t?0:f[t-1])+a;p[t]++;for(let r=0;r<d;++r)o[i*d+r]=e[n*d+r];h[i]=r[n],u[n]=i}for(let e=0;e<c;++e){if(0===p[e]){const t=0===e?0:f[e-1];o[t*d+0]=e;for(let e=1;e<d;++e)o[t*d+e]=0;h[t]=i}}return[o,[t,d],h,l,u]}}const Ej={kernelName:ax,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(o.shape));if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(r.shape));if(1!==a.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(a.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));const s=n.data.get(r.dataId).values,c=n.data.get(a.dataId).values,l=n.data.get(o.dataId).values,u=n.data.get(i.dataId).values[0],[d,h,p,f,g]=Ij(s,r.shape,r.dtype,c,a.dtype,l,u);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};function Nj(e,t,n,r,a){const o=Wm(r),i=t[0],s=a.length,c=[];let l=1,u=-1;for(let g=0;g<s;++g){const e=a[g];if(-1===e){if(-1!==u)throw new Error(hT(u,g));u=g,c.push(1)}else{if(e<0)throw new Error(pT(g,e));l*=e,c.push(e)}}if(-1!==u){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(o/l);if(l*e!==o)throw new Error(gT(r,c));c[u]=e}if(Wm(c)!==o)throw new Error(mT(r,c));const d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}const p=[];if(s>0){p[s-1]=1;for(let e=s-2;e>=0;--e)p[e]=p[e+1]*c[e+1]}const f=Ym(n,i*s);for(let g=0;g<i;++g){let t=0;for(let n=0;n<d;++n)t+=e[g*d+n]*h[n];for(let e=0;e<s;++e)f[g*s+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,s],c]}const Tj={kernelName:ox,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:o}=t;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(r.shape));if(1!==a.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(a.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const i=Array.from(n.data.get(a.dataId).values),s=n.data.get(r.dataId).values,c=Array.from(n.data.get(o.dataId).values),[l,u,d]=Nj(s,r.shape,r.dtype,i,c);return[n.makeTensorInfo(u,r.dtype,l),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function Rj(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const s=r.length,c=[t[0],e.length/t[0]],l=c[1],u=s>0?a[s-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=u;const h=Ym(n,d.reduce(((e,t)=>e*t),1));if(0===s)return u>0&&h.fill(i),[h,d];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,g=0,m=a[p];for(;;){let t=0;if(f<s){if(t=a[f],m===t){++f;continue}if(m>=t)throw new Error("segment ids are not increasing")}if(m<0||m>=u)throw new Error(yT(m,u));m>g&&h.fill(i,g*l,m*l);for(let n=p;n<f;++n){const t=r[n];if(t<0||t>=c[0])throw new Error(xT(n,r[n],c[0]));for(let n=0;n<l;n++)h[m*l+n]+=e[t*l+n]}if(o)for(let e=0;e<l;e++)h[m*l+e]/=f-p;if(p=f,++f,g=m+1,m=t,f>s)break}return g<u&&h.fill(i,g*l,u*l),[h,d]}const Aj={kernelName:ix,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(a.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(o.shape));if(a.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values,[l,u]=Rj(i,r.shape,r.dtype,s,c,!0);return n.makeTensorInfo(u,r.dtype,l)}};const Oj={kernelName:sx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(a.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(o.shape));if(a.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values,[l,u]=Rj(i,r.shape,r.dtype,s,c);return n.makeTensorInfo(u,r.dtype,l)}};const Fj={kernelName:cx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:o,defaultValue:i}=t,{outputShape:s}=r,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=MN(0,a,s),p=!1,f=n.bufferSync(a);let g;switch(o.dtype){case"bool":g=oj(f,n.bufferSync(o),s,h,u,l,c,d,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":g=oj(f,n.bufferSync(o),s,h,u,l,c,d,n.data.get(i.dataId).values[0],p);break;case"int32":g=oj(f,n.bufferSync(o),s,h,u,l,c,d,n.data.get(i.dataId).values[0],p);break;case"string":g=oj(f,n.bufferSync(o),s,h,u,l,c,d,cw(n.data.get(i.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(o.dtype))}return n.makeTensorInfo(s,g.dtype,g.values)}};const _j={kernelName:nx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:o,axis:i}=r,s=Km(i,a.shape)[0],c=cT(a,o,s),l=new Array(a.shape.length).fill(0),u=a.shape.slice();return c.map((e=>{const t=[...u];t[s]=e;const r=hB({inputs:{x:a},backend:n,attrs:{begin:l,size:t}});return l[s]+=e,r}))}},Dj=qL((e=>Math.sqrt(e))),Mj=KL(Jy,(e=>Math.sqrt(e))),Pj={kernelName:Jy,backendName:"cpu",kernelFunc:Mj},Lj={kernelName:ux,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:r}=t,a=n;jL(r,"square");const o=a.data.get(r.dataId).values,i=new Float32Array(o.length);for(let s=0;s<o.length;++s){const e=o[s];i[s]=e*e}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},zj=tz(((e,t)=>{const n=e-t;return n*n})),Bj=wz(lx,zj),Wj={kernelName:lx,backendName:"cpu",kernelFunc:Bj},Uj=qL(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),Vj=XL(dx,Uj),jj={kernelName:dx,backendName:"cpu",kernelFunc:Vj},Hj=KL(Nx,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),Gj={kernelName:Nx,backendName:"cpu",kernelFunc:Hj};function qj(e,t,n,r){const a=Jk(e,t.dtype);for(let o=0;o<a.size;o++){const e=a.indexToLoc(o),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}const Kj={kernelName:hx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:o,end:i,strides:s,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r;jL(a,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:v,begin:b,end:y,strides:x}=oC(a.shape,o,i,s,c,l,u,d,h);let w;if(g)w=Nz({inputs:{x:a},backend:n,attrs:{shape:f}});else if(m||v){Lm(a.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(a.shape.length)));const e=qS(b,y,x),t=hB({inputs:{x:a},backend:n,attrs:{begin:b,size:e}});w=Nz({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=qj(p,n.bufferSync(a),x,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class Xj{constructor(e,t,n,r,a,o){this.separator=sw(e),this.nGramWidths=t,this.leftPad=sw(n),this.rightPad=sw(r),this.padWidth=a,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,o){for(let i=0;i<a;++i){const s=this.getPadWidth(o),c=Math.max(0,s-i),l=Math.max(0,s-(a-(i+1))),u=o-(c+l),d=t+(c>0?0:i-s);let h=0;h+=c*this.leftPad.length;for(let t=0;t<u;++t)h+=e[d+t].length;h+=l*this.rightPad.length;h+=(c+l+u-1)*this.separator.length,n[r+i]=new Uint8Array(h);const p=n[r+i];let f=0;const g=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<c;++e)g(this.leftPad),g(this.separator);for(let t=0;t<u-1;++t)g(e[d+t]),g(this.separator);if(u>0){g(e[d+u-1]);for(let e=0;e<l;++e)g(this.separator),g(this.rightPad)}else{for(let e=0;e<l-1;++e)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error("Invalid split value ".concat(t[a],", must be in [").concat(e,", ").concat(n,"]"));e=t[a]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const a=r-1,o=Ym("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=a;++t)o[t]=0;return[e,o]}o[0]=0;for(let s=1;s<=a;++s){const e=t[s]-t[s-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),o[s]=o[s-1]+n}const i=new Array(o[a]);for(let s=0;s<a;++s){const n=t[s];let r=o[s];if(this.nGramWidths.forEach((a=>{const o=t[s+1]-t[s],c=this.getNumNGrams(o,a);this.createNGrams(e,n,i,r,c,a),r+=c})),this.preserveShort&&r===o[s]){const a=t[s+1]-t[s];if(0===a)continue;const o=a+2*this.padWidth,c=1;this.createNGrams(e,n,i,r,c,o)}}return[i,o]}}function $j(e,t,n,r,a,o,i,s){return new Xj(n,r,a,o,i,s).compute(e,t)}const Yj={kernelName:px,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:o,leftPad:i,rightPad:s,padWidth:c,preserveShortSequences:l}=r,{data:u,dataSplits:d}=t,h=n.data.get(u.dataId).values,p=n.data.get(d.dataId).values,[f,g]=$j(h,p,a,o,i,s,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",g)]}};function Qj(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const a=t[0];let o=e.indexOf(a);for(;-1!==o;){const t=e.subarray(0,o);n&&0===t.length||r.push(t),o=(e=e.subarray(o+1)).indexOf(a)}return void(n&&0===e.length||r.push(e))}let a=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==t.indexOf(e[o])){const t=e.subarray(a,o);n&&0===t.length||r.push(t),a=o+1}}function Zj(e,t,n){const r=e.length,a=[];let o=0,i=0;const s=new Array(r);for(let h=0;h<r;++h){const r=a.length;Qj(e[h],t,n,a);const c=a.length-r;s[h]=c,o+=c,i=Math.max(i,c)}const c=Ym("int32",2*o),l=new Array(o),u=[r,i];let d=0;for(let h=0;h<r;++h)for(let e=0;e<s[h];++e)c[2*d]=h,c[2*d+1]=e,l[d]=a[d],++d;return[c,l,u]}const Jj={kernelName:fx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));const s=n.data.get(o.dataId).values,c=n.data.get(i.dataId).values[0],[l,u,d]=Zj(s,c,a),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function eH(e,t){const n=Ym("int32",e.length);for(let r=0;r<e.length;++r)n[r]=rw(e[r]).modulo(t).getLowBitsUnsigned();return n}const tH={kernelName:gx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=eH(n.data.get(o.dataId).values,a);return n.makeTensorInfo(o.shape,"int32",i)}},nH=KL(vx,(e=>Math.tan(e))),rH={kernelName:vx,backendName:"cpu",kernelFunc:nH},aH=KL(bx,(e=>Math.tanh(e)));const oH={kernelName:jy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:o}=t,{sliceRank:i,numUpdates:s,sliceSize:c,strides:l,outputSize:u}=MN(0,a,r.shape),d=n.bufferSync(a),h=n.bufferSync(o),p=n.bufferSync(r),f=oj(d,h,r.shape,u,c,s,i,l,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function iH(e,t){const n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];const r=Jk(n,e.dtype);for(let a=0;a<r.values.length;++a){const t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const o=e.locToIndex(n);r.values[a]=e.values[o]}return r}const sH={kernelName:yx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:o}=r;jL(a,"tile");const i=iH(n.bufferSync(a),o);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},cH=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function lH(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){const a=r-n+1,o=t-n+1,i=Math.log(a),s=.5*Math.exp(2*i/3),c=.5*Math.sqrt(i*s*(a-s)/a)*Math.sign(o-a/2);lH(e,t,Math.max(n,Math.floor(t-o*s/a+c)),Math.min(r,Math.floor(t+(a-o)*s/a+c)))}const a=e[t];let o=n,i=r;for(Pm(e,n,t),cH(e[r],a)>0&&Pm(e,n,r);o<i;){for(Pm(e,o,i),o++,i--;cH(e[o],a)<0;)o+=1;for(;cH(e[i],a)>0;)i-=1}0===cH(e[n],a)?Pm(e,n,i):(i+=1,Pm(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function uH(e,t,n,r,a){const o=t[t.length-1],[i,s]=[e.length/o,o],c=$m(n,i*r),l=$m("int32",i*r);for(let d=0;d<i;d++){const t=d*s,n=e.subarray(t,t+s);let o=new Array(n.length);n.forEach(((e,t)=>o[t]={value:e,index:t})),r<o.length&&(lH(o,r),o=o.slice(0,r)),a&&o.sort(cH);const i=d*r,u=c.subarray(i,i+r),h=l.subarray(i,i+r);for(let e=0;e<r;e++)u[e]=o[e].value,h[e]=o[e].index}const u=t.slice();return u[u.length-1]=r,[Jk(u,n,c),Jk(u,"int32",l)]}const dH={kernelName:xx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:o,sorted:i}=r;jL(a,"topk");const s=n.data.get(a.dataId).values,[c,l]=uH(s,a.shape,a.dtype,o,i);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const hH={kernelName:wx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:o}=t,{interpolation:i,fillMode:s,fillValue:c,outputShape:l}=n,[u,d,h,p]=a.shape,[f,g]=null!=l?l:[d,h],m=[u,f,g,p],v=av(a.shape),b=v[0],y=v[1],x=v[2],w=av(m),k=w[0],S=w[1],C=w[2],I=$m(a.dtype,Wm(m));I.fill(c);const E=r.data.get(a.dataId).values,N=r.data.get(o.dataId).values;for(let T=0;T<u;++T){const e=1===o.shape[0]?N:N.subarray(8*T,8*T+8);for(let t=0;t<f;++t)for(let n=0;n<g;++n)for(let r=0;r<p;++r){let a;const o=e[6]*n+e[7]*t+1;if(0===o)continue;const l=(e[0]*n+e[1]*t+e[2])/o,u=(e[3]*n+e[4]*t+e[5])/o,p=pH(l,h,s),f=pH(u,d,s);switch(i){case"nearest":a=gH(E,d,h,b,y,x,T,f,p,r,c);break;case"bilinear":a=mH(E,d,h,b,y,x,T,f,p,r,c);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(i))}I[T*k+t*S+n*C+r]=a}return r.makeTensorInfo(m,a.dtype,I)}return{dataId:r.write(I,m,a.dtype),shape:a.shape,dtype:a.dtype}}};function pH(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Dm(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return Dm(0,n,t-1)}(e,t);case"nearest":return function(e,t){return Dm(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function fH(e,t,n,r,a,o,i,s,c,l,u){return 0<=s&&s<t&&0<=c&&c<n?e[i*r+s*a+c*o+l]:u}function gH(e,t,n,r,a,o,i,s,c,l,u){return fH(e,t,n,r,a,o,i,Math.round(s),Math.round(c),l,u)}function mH(e,t,n,r,a,o,i,s,c,l,u){const d=Math.floor(s),h=Math.floor(c),p=d+1,f=h+1;return(p-s)*((f-c)*fH(e,t,n,r,a,o,i,d,h,l,u)+(c-h)*fH(e,t,n,r,a,o,i,d,f,l,u))+(s-d)*((f-c)*fH(e,t,n,r,a,o,i,p,h,l,u)+(c-h)*fH(e,t,n,r,a,o,i,p,f,l,u))}function vH(e,t,n,r){const a=Km(t,n)[0],o=[1,n[0],1];for(let f=0;f<a;f++)o[0]*=n[f];o[1]=n[a];for(let f=a+1;f<n.length;f++)o[2]*=n[f];const i=new Map,s=new Int32Array(n[a]),c=new kw(o,r,e),l=[],u=1===o[0]&&1===o[2];for(let f=0;f<n[a];f++){let t;if(u)t=e[f].toString();else{const e=[];for(let t=0;t<o[0];t++)for(let n=0;n<o[2];n++)e.push(c.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)s[f]=n;else{const e=i.size;i.set(t,e),s[f]=e,l.push(f)}}const d=o.slice();d[1]=i.size;const h=new kw(d,r);l.forEach(((e,t)=>{for(let n=0;n<o[0];n++)for(let r=0;r<o[2];r++)h.set(c.get(n,e,r),n,t,r)}));const p=n.slice();return p[a]=d[1],{outputValues:h.values,outputShape:p,indices:s}}const bH={kernelName:Sx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:o}=t;jL(o,"unique");const i=r.data.get(o.dataId).values,{outputValues:s,outputShape:c,indices:l}=vH(i,a,o.shape,o.dtype);return[r.makeTensorInfo(c,o.dtype,s),r.makeTensorInfo([l.length],"int32",l)]}};const yH={kernelName:Cx,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:o}=r;o<0&&(o+=a.shape.length);const i=a.shape.length,s=a.shape[o],c=new Array(i-1);let l=0;for(let p=0;p<i;p++)p!==o&&(c[l++]=a.shape[p]);const u=new Array(i).fill(0),d=a.shape.slice();d[o]=1;const h=new Array(s);for(let p=0;p<h.length;p++){u[o]=p;const e=hB({inputs:{x:a},backend:n,attrs:{begin:u,size:d}});h[p]=Nz({inputs:{x:e},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(e)}return h}};const xH={kernelName:Ix,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:o}=t,{numSegments:i}=r;jL(a,"unsortedSegmentSum");const s=[],c=[],l=a.shape.length-o.shape.length;let u=o;for(let h=0;h<l;++h){const e=IW({inputs:{input:u},backend:n,attrs:{dim:h+1}});u=e,c.push(e)}for(let h=0;h<i;++h){const e=aw(h,"int32"),t=n.makeTensorInfo([],"int32",e),r=hW({inputs:{a:t,b:u},backend:n}),o=yz({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=oW({inputs:{a:o,b:a},backend:n}),l=sW({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});s.push(l),c.push(t),c.push(r),c.push(o),c.push(i),c.push(l)}const d=kV({inputs:s,backend:n,attrs:{axis:0}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},wH=[Oz,_z,Mz,Lz,Ez,zz,Vz,jz,Hz,Gz,Kz,$z,Qz,eB,nB,iB,sB,cB,lB,Az,uB,fB,vB,yB,xB,xz,SB,IB,fz,EB,OB,_B,DB,MB,PB,LB,zB,WB,VB,jB,HB,GB,qB,KB,$B,YB,QB,ZB,JB,eW,tW,nW,lW,YL,uW,pW,wW,CW,EW,RW,WW,VW,jW,qW,$W,YW,QW,JW,tU,aU,sU,ZL,cU,RB,uU,hU,fU,ez,vU,xU,kU,IU,NU,AU,FU,MU,PU,LU,WU,jU,HU,GU,qU,KU,XU,$U,YU,JU,eV,rV,iV,iW,cV,uV,hV,fV,vV,bV,wV,SV,CV,NV,az,RV,DV,LV,jV,GV,vz,FW,KV,iz,cz,Tz,XV,$V,YV,QV,ZV,JV,tj,aj,ij,lj,uj,fj,dz,mj,bj,xj,pB,oV,Sj,Cj,Ej,Tj,Aj,Oj,Fj,_j,Pj,Lj,Wj,jj,Gj,Kj,Yj,Jj,tH,PW,cW,rH,{kernelName:bx,backendName:"cpu",kernelFunc:aH},oH,sH,dH,hH,Uz,bH,yH,xH,xV];for(const n of wH)Wx(n);const kH={},SH={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function CH(e,t){if(!(e in kH)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(vv().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete kH[e]}),!1),vv().getBool("SOFTWARE_WEBGL_ENABLED")&&(SH.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",SH)||n.getContext("experimental-webgl",SH);return n.getContext("webgl2",SH)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;kH[e]=n}const n=kH[e];return null==n||n.isContextLost()?(delete kH[e],CH(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),kH[e])}var IH,EH,NH;function TH(e,t){return[t,e]}function RH(e){const t=Wm(e);return jm(Math.ceil(t/4))}function AH(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function OH(e,t){const n=e;let r,a,o,i,s,c,l,u,d,h;return 2===vv().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,o=n.RGBA16F,i=n.RGBA32F,s=n.RED,l=4,u=1,d=n.HALF_FLOAT,h=n.FLOAT,c=n.RGBA8):(r=e.RGBA,a=e.RGBA,o=e.RGBA,i=n.RGBA,s=e.RGBA,l=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,c=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:s,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:h}}function FH(e,t){const n=t();return vv().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(IH||(IH={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(EH||(EH={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(NH||(NH={}));function _H(e){return!!(vv().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function DH(e,t){return jH(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const MH=/ERROR: [0-9]+:([0-9]+):/g;function PH(e,t){const n=MH.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const r=+n[1],a=e.split("\n"),o=a.length.toString().length+2,i=a.map(((e,t)=>Hm((t+1).toString(),o)+e));let s=0;for(let d=0;d<i.length;d++)s=Math.max(i[d].length,s);const c=i.slice(0,r-1),l=i.slice(r-1,r),u=i.slice(r);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(Hm(l[0],s)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function LH(e,t){if(FH(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function zH(e,t,n,r,a,o,i){const s=e.getAttribLocation(t,n);return-1!==s&&(FH(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),FH(e,(()=>e.vertexAttribPointer(s,a,e.FLOAT,!1,o,i))),FH(e,(()=>e.enableVertexAttribArray(s))),!0)}function BH(e,t,n,r){FH(e,(()=>function(e,t,n){HH(e,n),FH(e,(()=>e.activeTexture(e.TEXTURE0+n))),FH(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),FH(e,(()=>e.uniform1i(n,r)))}function WH(e,t,n){FH(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),FH(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function UH(e,t){FH(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),FH(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function VH(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function jH(e,t,n){const r=FH(e,(()=>t()));if(null==r)throw new Error(n);return r}function HH(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function GH(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Wm(e.slice(0,e.length-t))}function qH(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function KH(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[GH(e),...qH(e)]),t}function XH(e){return e%2===0}function $H(e,t){if(Um(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(XH(n)&&XH(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&XH(e[0])&&XH(t[0])}let YH,QH;function ZH(e,t){return null!=e.getExtension(t)}function JH(e){try{if(null!=CH(e))return!0}catch(f0){return console.log("Error when getting WebGL context: ",f0),!1}return!1}function eG(e){if(0===e)return!1;const t=CH(e);if(1!==e){if(ZH(t,"EXT_color_buffer_float"))return tG(t);const e="EXT_color_buffer_half_float";if(ZH(t,e)){const n=t.getExtension(e);return function(e,t){const n=OH(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const a=1,o=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),s}(t,n)}return!1}if(!ZH(t,"OES_texture_float"))return!1;if(!ZH(t,"WEBGL_color_buffer_float"))return!1;return tG(t)}function tG(e){const t=OH(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function nG(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Lm("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend."))}))}const rG=vv();function aG(){let e,t,n,r,a,o,i,s,c,l;return 2===vv().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",o="outputColor",i="out vec4 outputColor;",s=vv().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",o="gl_FragColor",i="",s="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:o,defineOutput:i,defineSpecialNaN:s,defineSpecialInf:c,defineRound:l}}function oG(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=av(t);return r.map(((t,a)=>{const o="int ".concat(e[a]," = ").concat(n," / ").concat(t),i=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * ").concat(t):"index -= ".concat(e[a]," * ").concat(t);return"".concat(o,"; ").concat(i,";")})).join("")}function iG(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=av(t);return r.map(((t,a)=>{const o="int ".concat(e[a]," = ").concat(n," / outShapeStrides[").concat(a,"]"),i=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * outShapeStrides[").concat(a,"]"):"index -= ".concat(e[a]," * outShapeStrides[").concat(a,"]");return"".concat(o,"; ").concat(i,";")})).join("")}function sG(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=function(e,t){const n=e.length,r=e.map((e=>"".concat(t,"[").concat(e,"]"))),a=new Array(n-1);a[n-2]=r[n-1];for(let o=n-3;o>=0;--o)a[o]="(".concat(a[o+1]," * ").concat(r[o+1],")");return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>{const o="int ".concat(e[a]," = ").concat(n," / ").concat(r[a]),i=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * ").concat(r[a]):"index -= ".concat(e[a]," * ").concat(r[a]);return"".concat(o,"; ").concat(i,";")})).join("")}function cG(e){const t=av(e).map((e=>e.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}rG.registerFlag("HAS_WEBGL",(()=>rG.getNumber("WEBGL_VERSION")>0)),rG.registerFlag("WEBGL_VERSION",(()=>JH(2)?2:JH(1)?1:0)),rG.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),rG.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===rG.get("WEBGL_VERSION"))),rG.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),rG.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),rG.registerFlag("WEBGL_PACK",(()=>rG.getBool("HAS_WEBGL"))),rG.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>rG.getBool("WEBGL_PACK"))),rG.registerFlag("WEBGL_PACK_CLIP",(()=>rG.getBool("WEBGL_PACK"))),rG.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>rG.getBool("WEBGL_PACK"))),rG.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>rG.getBool("WEBGL_PACK"))),rG.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>rG.getBool("WEBGL_PACK"))),rG.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>rG.getBool("WEBGL_PACK"))),rG.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>rG.getBool("WEBGL_PACK"))),rG.registerFlag("WEBGL_PACK_REDUCE",(()=>rG.getBool("WEBGL_PACK"))),rG.registerFlag("WEBGL_LAZILY_UNPACK",(()=>rG.getBool("WEBGL_PACK"))),rG.registerFlag("WEBGL_CONV_IM2COL",(()=>rG.getBool("WEBGL_PACK"))),rG.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>rG.getBool("WEBGL_PACK"))),rG.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==YH){const t=CH(e);YH=t.getParameter(t.MAX_TEXTURE_SIZE)}return YH}(rG.getNumber("WEBGL_VERSION")))),rG.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==QH){const t=CH(e);QH=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,QH)}(rG.getNumber("WEBGL_VERSION")))),rG.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=rG.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=CH(e);return t=ZH(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:ZH(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),rG.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>rG.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Yw())),rG.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=CH(e);if(1===e){if(!ZH(t,"OES_texture_float"))return!1}else if(!ZH(t,"EXT_color_buffer_float"))return!1;return tG(t)}(rG.getNumber("WEBGL_VERSION")))),rG.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!rG.getBool("WEBGL_FORCE_F16_TEXTURES")&&rG.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),rG.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>eG(rG.getNumber("WEBGL_VERSION")))),rG.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=rG.getNumber("WEBGL_VERSION"))&&null!=CH(e).fenceSync;var e})),rG.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>rG.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),rG.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))})),rG.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Yw()?1:-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))})),rG.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),rG.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),rG.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),rG.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),rG.registerFlag("WEBGL_EXP_CONV",(()=>!1)),rG.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>rG.getBool("IS_TEST"))),rG.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),rG.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),rG.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),rG.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const lG="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:uG}=r;function dG(e,t,n){const r=[];if(e.forEach((e=>{const t=Wm(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(r.push("uniform sampler2D ".concat(e.name,";")),r.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=wG(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push("uniform int ".concat(e.name,"Shape;"));break;case 2:r.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:r.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:r.push("uniform ivec4 ".concat(e.name,"Shape;"))}r.push("uniform ivec2 ".concat(e.name,"TexShape;"))}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))}));const a=r.join("\n"),o=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?pG(e,r):hG(e,r);const o=e.shapeInfo.logicalShape,i=t.logicalShape;o.length<=i.length&&(a+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",o=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,s=uG(e.shapeInfo.logicalShape,t.logicalShape),c=xG(i),l=i-o;let u;const d=["x","y","z","w","u","v"];u=0===o?"":i<2&&s.length>=1?"coords = 0;":s.map((e=>"coords.".concat(d[e+l]," = 0;"))).join("\n");let h="";h=i<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(d[t+l]))).join(", ");let p="return outputValue;";const f=1===Wm(e.shapeInfo.logicalShape),g=Wm(t.logicalShape),m=1===g;if(1!==o||f||m){if(f&&!m)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(s.length){const e=o-2,t=o-1;s.indexOf(e)>-1&&s.indexOf(t)>-1?p="return vec4(outputValue.x);":s.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":s.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(a,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(r,"(").concat(h,");\n      ").concat(p,"\n    }\n  ")}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",o=t.texShape,i=e.shapeInfo.texShape,s=e.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&s===c&&null==e.shapeInfo.flatOffset&&Um(i,o))return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const l=xG(c),u=uG(e.shapeInfo.logicalShape,t.logicalShape),d=c-s;let h;const p=["x","y","z","w","u","v"];h=0===s?"":c<2&&u.length>=1?"coords = 0;":u.map((e=>"coords.".concat(p[e+d]," = 0;"))).join("\n");let f="";f=c<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(p[t+d]))).join(", ");return"\n    float ".concat(a,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(h,"\n      return get").concat(r,"(").concat(f,");\n    }\n  ")}(e,t));return a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,s=aG(),c=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(s);let l,u,d=function(e){const t="".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(fG,"\n    ").concat(gG,"\n    ").concat(mG,"\n  ");return t}(s);t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(r[1],".0);\n      }\n    ");if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(r[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n      return 2 * (resTexRC.x * ").concat(r[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Um(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(r[0],", ").concat(r[1],"));\n      }\n    ");const a=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),o=a*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),o=a*Math.ceil(e[e.length-2]/2);let i=o,s="",c="b, r, c";for(let l=2;l<e.length-1;l++)i*=e[e.length-l-1],s="\n      int b".concat(l," = index / ").concat(i,";\n      index -= b").concat(l," * ").concat(i,";\n    ")+s,c="b".concat(l,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(r[0],", ").concat(r[1],"));\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n\n      ").concat(s,"\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(s)):(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(Um(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=iG(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const r=oG(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=iG(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const r=oG(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=oG(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=oG(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,i,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(s)),n.packedInputs&&(d+=vG);return[d,c,u,a,l,o,n.userCode].join("\n")}function hG(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(r,"() {return ").concat(n,";}");const[a,o]=e.shapeInfo.texShape;if(1===a&&1===o)return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=bG(n);if(t)return"\n    float ".concat(r,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[s,c]=e.shapeInfo.texShape;return"\n    float ".concat(r,"() {\n      vec2 uv = uvFromFlat(").concat(s,", ").concat(c,", ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int index) {\n        ").concat(yG(e),"\n      }\n    ");const a=e.shapeInfo.texShape,o=a[0],i=a[1];if(1===i&&1===o)return"\n      float ".concat(r,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const s=bG(n);if(1===i)return t?"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(s,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(s,") + 0.5) / ").concat(o,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===o)return t?"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(s,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(s,") + 0.5) / ").concat(i,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(t)return"\n    float ".concat(r,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int index) {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(i,", index + ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape;if(null!=o&&Um(n,o)){if(t)return"\n      float ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");const e=o[0],n=o[1];return"\n    float ".concat(a,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ")}const{newShape:i,keptDims:s}=Xm(n),c=i;if(c.length<n.length){const n=kG(e,c),r=["row","col"];return"\n      ".concat(hG(n,t),"\n      float ").concat(a,"(int row, int col) {\n        return ").concat(a,"(").concat(SG(r,s),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(yG(e),"\n      }\n    ");const l=o[0],u=o[1],d=bG(r);if(1===u)return t?"\n      float ".concat(a,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(r,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(r,"TexShape[0]));\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");if(1===l)return t?"\n      float ".concat(a,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(r,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(r,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(d,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");if(t)return"\n      float ".concat(a,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(r,"Shape[1] + col + ").concat(d,";\n        vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");return"\n  float ".concat(a,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(d,";\n    vec2 uv = uvFromFlat(").concat(l,", ").concat(u,", index);\n    return sampleTexture(").concat(r,", uv);\n  }\n")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[1]*n[2],i=n[2],{newShape:s,keptDims:c}=Xm(n),l=s;if(l.length<n.length){const n=kG(e,l),r=["row","col","depth"];return"\n        ".concat(hG(n,t),"\n        float ").concat(a,"(int row, int col, int depth) {\n          return ").concat(a,"(").concat(SG(r,c),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(o,", ").concat(i,", 1)));\n        ").concat(yG(e),"\n      }\n    ");const u=e.shapeInfo.texShape,d=u[0],h=u[1],p=e.shapeInfo.flatOffset;if(h===o&&null==p)return t?"\n      float ".concat(a,"(int row, int col, int depth) {\n        int stride1 = ").concat(r,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n        float ".concat(a,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(i,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(h,".0, ").concat(d,".0);\n          return sampleTexture(").concat(r,", uv);\n        }\n      ");if(h===i&&null==p)return t?"\n      float ".concat(a,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(r,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(h,".0, ").concat(d,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");const f=bG(r);if(t)return"\n    float ".concat(a,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(r,"Shape[1] * ").concat(r,"Shape[2];\n      int stride1 = ").concat(r,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index);\n      return sampleTexture(").concat(r,", uv);\n    }\n    ");return"\n      float ".concat(a,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(o," + col * ").concat(i," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(d,", ").concat(h,", index);\n        return sampleTexture(").concat(r,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[3],i=n[2]*o,s=n[1]*i,{newShape:c,keptDims:l}=Xm(n);if(c.length<n.length){const n=kG(e,c),r=["row","col","depth","depth2"];return"\n      ".concat(hG(n,t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2) {\n        return ").concat(a,"(").concat(SG(r,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(s,", ").concat(i,", ").concat(o,", 1)));\n        ").concat(yG(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f="int stride2 = ".concat(r,"Shape[3];"),g="int stride1 = ".concat(r,"Shape[2] * stride2;"),m="int stride0 = ".concat(r,"Shape[1] * stride1;");if(p===s&&null==u)return t?"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(g,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(i,", ").concat(o,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");if(p===o&&null==u)return t?"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(r,"Shape[1] * ").concat(r,"Shape[2], ").concat(r,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");const v=bG(r);if(t)return"\n    float ".concat(a,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(g,"\n      ").concat(m,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index + ").concat(v,");\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(s," + col * ").concat(i," +\n          depth * ").concat(o," + depth2;\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index + ").concat(v,");\n      return sampleTexture(").concat(r,", uv);\n    }\n  ")}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],o=t[3]*a,i=t[2]*o,s=t[1]*i,{newShape:c,keptDims:l}=Xm(t);if(c.length<t.length){const t=kG(e,c),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(hG(t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(r,"(").concat(SG(n,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(s,", ").concat(i,", ").concat(o,", ").concat(a,")) +\n          depth3;\n        ").concat(yG(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===s&&null==u)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(i,", ").concat(o,", ").concat(a,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===a&&null==u)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(h,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=bG(n);return"\n    float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(s," + col * ").concat(i," + depth * ").concat(o," +\n          depth2 * ").concat(a," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(h,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:o}=Xm(t);if(a.length<t.length){const t=kG(e,a),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(hG(t),"\n      float ").concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(r,"(").concat(SG(n,o),");\n      }\n    ")}const i=t[5],s=t[4]*i,c=t[3]*s,l=t[2]*c,u=t[1]*l;if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(l,", ").concat(c,", ").concat(s,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(i,", 1)));\n        ").concat(yG(e),"\n      }\n    ");const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===u&&null==d)return"\n      float ".concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(l,", ").concat(c,", ").concat(s,", ").concat(i,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===i&&null==d)return"\n      float ".concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const g=bG(n);return"\n    float ".concat(r,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," + depth * ").concat(c," +\n          depth2 * ").concat(s," + depth3 * ").concat(i," + depth4 + ").concat(g,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function pG(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=aG();return"\n    vec4 ".concat(n,"() {\n      return ").concat(r.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,o=aG();if(t)return"\n    vec4 ".concat(r,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ");const i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return"\n    vec4 ".concat(r,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(i[0],", ").concat(i[1],", index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,i=o[0],s=o[1],c=aG();if(null!=o&&Um(n,o))return t?"\n      vec4 ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n\n        return ").concat(c.texture2D,"(").concat(r,", uv);\n      }\n    "):"\n      vec4 ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s,".0, ").concat(i,".0);\n\n        return ").concat(c.texture2D,"(").concat(r,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(a,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r,"TexShape[0]) / 2.0), ceil(float(").concat(r,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(c.texture2D,"(").concat(r,", uv);\n    }\n  ");const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(a,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(l[0],", ").concat(l[1],", row, col);\n      return ").concat(c.texture2D,"(").concat(r,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===n[0]){const r=[1,2],o=kG(e,n.slice(1)),i=["b","row","col"];return"\n        ".concat(pG(o,t),"\n        vec4 ").concat(a,"(int b, int row, int col) {\n          return ").concat(a,"(").concat(SG(i,r),");\n        }\n      ")}const s=aG();if(t)return"\n    vec4 ".concat(a,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r,"TexShape[0]) / 2.0), ceil(float(").concat(r,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(r,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(s.texture2D,"(").concat(r,", uv);\n    }\n  ");const c=i[0],l=i[1],u=Math.ceil(n[2]/2),d=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(a,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(c,", ").concat(l,", ").concat(d,", ").concat(u,", b, row, col);\n      return ").concat(s.texture2D,"(").concat(r,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=aG();if(t)return"\n    vec4 ".concat(r,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(a.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=e.shapeInfo.logicalShape,i=o.length,s=e.shapeInfo.texShape,c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],l=c[0],u=c[1],d=Math.ceil(o[i-1]/2);let h=d*Math.ceil(o[i-2]/2),p="int b, int row, int col",f="b * ".concat(h," + (row / 2) * ").concat(d," + (col / 2)");for(let g=2;g<i-1;g++)p="int b".concat(g,", ")+p,h*=o[i-g-1],f="b".concat(g," * ").concat(h," + ")+f;return"\n    vec4 ".concat(r,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(l,");\n      return ").concat(a.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const fG="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",gG="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",mG="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",vG="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function bG(e){return"offset".concat(e)}function yG(e){const t=e.name,n=Wm(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function xG(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function wG(e,t,n){const{newShape:r,keptDims:a}=Xm(t),o=t.length,i=e&&3===o&&1===t[0],s=i?t.slice(1):r,c=!e&&o>1&&!Um(t,n)&&r.length<o||i;return{useSqueezeShape:c,uniformShape:c?s:t,keptDims:a}}function kG(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function SG(e,t){return t.map((t=>e[t])).join(", ")}function CG(e,t,n,r){const a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),o=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},s=dG(a,i,t),c=function(e,t){const n=jH(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(FH(e,(()=>e.shaderSource(n,t))),FH(e,(()=>e.compileShader(n))),vv().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw PH(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,s),l=e.createProgram(c);return vv().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:s,webGLProgram:l,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:c,source:s,webGLProgram:l,inShapeInfos:o,outShapeInfo:i},IG(e,t,l)))}function IG(e,t,n){const r=[],a=[];let o,i,s,c=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===vv().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const d of t.variableNames){const a={name:d,uniform:e.getUniformLocation(n,d,u),offset:e.getUniformLocation(n,"offset".concat(d),u)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,"".concat(d,"Shape"),u),a.texShape=e.getUniformLocation(n,"".concat(d,"TexShape"),u)),r.push(a)}if(t.enableShapeUniforms&&(o=e.getUniformLocation(n,"outShape",u),s=e.getUniformLocation(n,"outShapeStrides",u),i=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(const d of t.customUniforms)a.push(e.getUniformLocation(n,d.name,u));return{variablesLocations:r,customUniformLocations:a,infLoc:c,nanLoc:l,outShapeLocation:o,outShapeStridesLocation:s,outTexShapeLocation:i}}function EG(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach(((e,n)=>{const r=e.logicalShape,a=t[n],o=a.shape;if(!Um(r,o))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(r," and ").concat(o," must match"));if(e.isUniform&&a.isUniform)return;const i=e.texShape,s=a.isUniform?null:a.texData.texShape;if(!Um(i,s))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(i," and ").concat(s," must match"))}))}function NG(e){return vv().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class TG{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=IH.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=aG();this.outputShape=e,this.enableShapeUniforms=NG(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?iG(["r","c","d"],e):oG(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class RG{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=IH.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=aG();this.outputShape=e,this.enableShapeUniforms=NG(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?iG(["r","c","d"],e):oG(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class AG{constructor(e){this.variableNames=["A"],this.outTexUsage=EH.DOWNLOAD;const t=aG();this.outputShape=e,this.userCode="\n      ".concat(lG,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class OG{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=EH.DOWNLOAD;const t=aG();this.outputShape=e,this.userCode="\n      ".concat(lG,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}const FG={R:0,G:1,B:2,A:3};class _G{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=aG();this.outputShape=e,this.enableShapeUniforms=NG(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let o="";for(let i=0;i<n.length;i++){const e=n[i];o+="\n          if(offset == ".concat(i,") {\n            result = values[").concat(FG[e],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":cG(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(r.texture2D,"(A, uv);\n          ").concat(o,"\n        }\n        ").concat(r.output," = vec4(").concat(a,", 0., 0., 0.);\n      }\n    ")}}class DG{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=aG();this.outputShape=e,this.enableShapeUniforms=NG(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let t=0;t<=1;t++){const a=2*o+t;r+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(o," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(o,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(a,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(a,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(a,"] = values[2];\n            } else {\n              result[").concat(a,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":cG(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(r,"\n\n          ").concat(n.output," = ").concat(a,";\n        }\n    ")}}function MG(e){const t=aG();return function(e,t){const n=jH(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(FH(e,(()=>e.shaderSource(n,t))),FH(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function PG(e){return function(e,t){const n=jH(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return FH(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),FH(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function LG(e){return function(e,t){const n=jH(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return FH(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),FH(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function zG(e,t,n,r,a,o){!function(e,t){const n=vv().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const r="[".concat(e,"x").concat(t,"]"),a="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}(t,n);const i=function(e){return jH(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),s=e.TEXTURE_2D;return FH(e,(()=>e.bindTexture(s,i))),FH(e,(()=>e.texParameteri(s,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),FH(e,(()=>e.texParameteri(s,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),FH(e,(()=>e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.NEAREST))),FH(e,(()=>e.texParameteri(s,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===vv().getNumber("WEBGL_VERSION")?FH(e,(()=>e.texImage2D(s,0,r,t,n,0,a,o,null))):FH(e,(()=>e.texStorage2D(s,1,r,t,n))),FH(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function BG(e){return e.internalFormatFloat}function WG(e){return e.internalFormatHalfFloat}function UG(e){return e.downloadTextureFormat}function VG(e){return e.internalFormatPackedFloat}function jG(e){return e.internalFormatPackedHalfFloat}function HG(e,t,n,r,a,o,i,s){const c=e,l=new Float32Array(function(e,t){const[n,r]=AH(e,t);return n*r*4}(o,i));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}class GG{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=vv().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){kH[e]=t}(t,e)):this.gl=CH(t),e=this.gl,2===vv().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>FH(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>FH(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>FH(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>FH(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>FH(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>FH(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>FH(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>FH(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===vv().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=DH(this.gl,e),ZH(this.gl,t))this.textureHalfFloatExtension=DH(this.gl,t);else if(vv().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),ZH(this.gl,r))this.colorBufferHalfFloatExtension=DH(this.gl,r);else if(vv().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",ZH(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!ZH(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=PG(this.gl),this.indexBuffer=LG(this.gl),this.framebuffer=function(e){return jH(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=OH(this.gl,this.textureHalfFloatExtension)}get debug(){return vv().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;FH(e,(()=>e.finish())),FH(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),FH(e,(()=>e.deleteFramebuffer(this.framebuffer))),FH(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),FH(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),FH(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,o]=TH(t,n);return zG(e,a,o,BG(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,o]=TH(t,n);return zG(e,a,o,WG(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,o]=TH(t,n);return zG(e,a,o,UG(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){FH(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===vv().getNumber("WEBGL_VERSION")?FH(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):FH(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===vv().getNumber("WEBGL_VERSION")?FH(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):FH(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),FH(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,a,o){let i,s,c;FH(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),s=e.UNSIGNED_BYTE,c=e.RGBA):(i=new Float32Array(n*r*4),s=e.FLOAT,c=o.internalFormatPackedFloat),i.set(a),2===vv().getNumber("WEBGL_VERSION")?FH(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,s,i))):FH(e,(()=>e.texImage2D(e.TEXTURE_2D,0,c,n,r,0,e.RGBA,s,i))),FH(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,o]=AH(t,n);return zG(e,a,o,jG(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,o]=AH(t,n);return zG(e,a,o,VG(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(UH(this.gl,this.framebuffer),this.outputTexture=null),FH(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[a,o]=TH(t,n),i=new Uint8Array(t*n*4);return FH(e,(()=>e.readPixels(0,0,a,o,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,o){return HG(this.gl,e,0,0,0,a,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n,r){const a=e.createBuffer();FH(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));const o=16*t*n;return FH(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ))),FH(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),FH(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(vv().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return FH(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=MG(t));const n=function(e){return jH(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);FH(t,(()=>t.attachShader(n,this.vertexShader))),FH(t,(()=>t.attachShader(n,e))),function(e,t){if(FH(e,(()=>e.linkProgram(t))),!vv().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&LH(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;FH(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){FH(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),zH(e,t,"clipSpacePos",n,3,20,0)&&zH(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(FH(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&LH(this.gl,this.program),FH(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return jH(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),FH(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),BH(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=AH(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&LH(this.gl,this.program),VH(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}FH(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),FH(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=DH(this.gl,2===vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Gm((()=>this.disposed||this.isQueryAvailable(e,vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in vv().platform&&(n=vv().platform.setTimeoutCustom.bind(vv().platform)),Gm((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),WH(this.gl,e,this.framebuffer),this.debug&&VH(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(WH(this.gl,this.outputTexture,this.framebuffer),this.debug&&VH(this.gl)):UH(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;WH(r,e,this.framebuffer),this.debug&&VH(r),this.outputTexture=e,FH(r,(()=>r.viewport(0,0,t,n))),FH(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),FH(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:qG,XI:KG,Nk:XG,f6:$G,ct:YG,YG:QG,hH:ZG,z3:JG,sG:eq,uM:tq,vS:nq,qB:rq,GG:aq,rq:oq,lg:iq,WR:sq,cu:cq,GE:lq,px:uq,jC:dq,He:hq,hE:pq,BF:fq,Dk:gq,cl:mq,_B:vq,ub:bq,_f:yq,Ku:xq,qy:wq,Zy:kq,bu:Sq,zv:Cq,dH:Iq,HS:Eq,yH:Nq,l3:Tq,z9:Rq,x6:Aq,_m:Oq,eW:Fq,GK:_q,SP:Dq,yr:Mq,dl:Pq,Dw:Lq,xT:zq,_X:Bq,wz:Wq}=a;function Uq(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>"".concat(e,".").concat(t)))}function Vq(e,t){return 1===t?[e]:Uq(e,t)}class jq{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=NG(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Vq("rc",this.rank),t=xG(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(r,"\n\n            setOutput(vec4(").concat(a,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a="".concat(0===n?"r":"rp1",", ").concat(0===r?"c":"cp1");for(let t=2;t<this.rank;t++)a="".concat(e[e.length-1-t],",")+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],r=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(r,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class Hq{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=NG(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2===1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(r,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(r>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?sG(["r","c","d"],"inputShape"):oG(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":cG(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class Gq{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=Kq(t,n),a=Xq(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const o=qq(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}let i;return r===NH.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===NH.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===NH.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===NH.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===NH.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const a=Kq(n,r),o=Xq(t,a,r);o in this.freeTextures||(this.freeTextures[o]=[]);const i=qq(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),s=vv().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==s&&this._numBytesAllocated>s?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const c=this.usedTextures[o],l=c&&c.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function qq(e,t,n,r,a){const o=function(e,t){switch(e){case NH.PACKED_2X2_FLOAT32:return VG(t);case NH.PACKED_2X2_FLOAT16:return jG(t);case NH.UNPACKED_FLOAT32:return BG(t);case NH.UNPACKED_FLOAT16:return WG(t);case NH.PACKED_4X1_UNSIGNED_BYTE:return UG(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,r);let i;if(a){const[t,n]=AH(e[0],e[1]);i=t*n}else{const[t,n]=TH(e[0],e[1]);i=t*n}const s=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,o);return i*s}function Kq(e,t){if(e===EH.UPLOAD)return NH.PACKED_2X2_FLOAT32;if(e===EH.RENDER||null==e)return function(e){return vv().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?NH.PACKED_2X2_FLOAT32:NH.UNPACKED_FLOAT32:e?NH.PACKED_2X2_FLOAT16:NH.UNPACKED_FLOAT16}(t);if(e===EH.DOWNLOAD||e===EH.PIXELS)return NH.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function Xq(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class $q{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=NG(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const Yq="if (isnan(x)) return x;",Qq="return x;",Zq="return abs(x);";const Jq="return (x >= 0.0) ? x : (exp(x) - 1.0);",eK=Yq+"\n  return (x < 0.0) ? 0.0 : x;\n",tK=Yq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",nK="return x;",rK="return 1.0 / (1.0 + exp(-1.0 * x));",aK="return x;",oK="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",iK="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",sK="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cK="return 1.0 / (1.0 + exp(-1.0 * x));";class lK{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=NG(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class uK{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=NG(this.outputShape.length);const t=e.length,n=Vq("rc",t),r=xG(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),i=t<=1?"rc":"vec2(".concat(o.join(","),")");this.userCode="\n      void main() {\n        ".concat(r," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(a,");\n\n        setOutput(getChannel(packedInput, ").concat(i,"));\n      }\n    ")}}const dK=ET,hK={};const pK=vv().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class fK extends Om{nextDataId(){return fK.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!vv().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof GG)t=e;else{const n=CH(vv().getNumber("WEBGL_VERSION"),e);t=new GG(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=CH(vv().getNumber("WEBGL_VERSION"));t=new GG(e),this.binaryCache=((n=vv().getNumber("WEBGL_VERSION"))in hK||(hK[n]={}),hK[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Gq(this.gpgpu),this.numMBBeforeWarning=null==vv().global.screen?1024:vv().global.screen.height*vv().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Am(this,lk())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,o){const i=this.makeTensorInfo(t,n),s=this.texData.get(i.dataId);s.isPacked=!1,s.texture={texture:e,texShape:[r,a]},s.texShape=[r,a];const c=KH(t),l=new _G(c,!1,o),u=this.runWebGLProgram(l,[i],n,[[r,a]]);return u.shape=t,s.texture=null,this.disposeIntermediateTensorInfo(i),u.dataId}write(e,t,n){if((vv().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||vv().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:EH.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if(vv().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:EH.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:o,shape:i,isPacked:s}=t;if(null!=o){let t;t=s?new lK(i,nK):new $q(i,nK);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const c=null!=this.activeTimers;let l,u;if(c&&(l=iw()),"complex64"===r){u=HN(this.readSync(a.real.dataId),this.readSync(a.imag.dataId))}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=iw()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:o,complexTensorInfos:i,isPacked:s}=t;if(null!=a){let t;t=s?new lK(r,nK):new $q(r,nK);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:o}],o),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(vv().getBool("DEBUG")&&!vv().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===vv().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,l,u=null;if("complex64"!==o&&vv().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...RH(r))}if(this.pendingRead.set(e,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);l=HN(e[0],e[1])}else if(null==u)l=this.getValuesFromTexture(e);else{const e=Wm(r);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=u){const e=this.gpgpu.gl;FH(e,(()=>e.deleteBuffer(u)))}const d=this.convertAndCacheOnCPU(e,l),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&lk().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:r,shape:a,slice:o,dtype:i,isPacked:s,texture:c}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let n;n=s?new lK(a,nK):new $q(a,nK);const r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),o=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),o}if(null==c)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),u=lk().makeTensorFromTensorInfo(l),d=this.texData.get(l.dataId);return Object.assign({tensorRef:u},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>cw(e)));return Jk(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Jk(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!_H(n)){if(vv().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=Wm(t);if(vv().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...RH(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),o}const o=vv().getBool("WEBGL_PACK")&&!0===r,i=o?KH(t):t,s=o?new OG(i):new AG(i),c=this.runWebGLProgram(s,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=uw(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),o=uw(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(a);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:o[t],ms:e}))).map((e=>"".concat(e.name,": ").concat(e.ms))).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:iw(),endMs:null}}endTimer(e){return vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=iw(),e)}async getQueryTime(e){if(vv().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:o,slice:i}=this.texData.get(e),s=i&&i.origDataId||e,c=this.dataRefCount.get(s);c>1?this.dataRefCount.set(s,c-1):(this.dataRefCount.delete(s),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,o)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:pK;return vv().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Wm(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){_x("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return dK(e.shape,t)}packedUnaryOp(e,t,n){const r=new lK(e.shape,t),a=this.compileAndRun(r,[e],n);return lk().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=Iq(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(vv().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Zq,e.dtype);const t=new $q(e.shape,Zq),n=this.compileAndRun(t,[e]);return lk().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Jm(n[0])){const a=n.map((e=>sw(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return lk().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new uK(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new jq(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[GH(e.shape),...qH(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[GH(t),...qH(t)],o=new Hq(a,n),i=[n],s=this.runWebGLProgram(o,[r],e.dtype,i,!0);return{dataId:s.dataId,shape:t,dtype:s.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:a,dtype:o}=n;if(null!=t){Lm(Wm(a)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=KH(a);let s;s=r?new RG(i):new TG(i);const c=[null!=t?t:RH(i)];return{dtype:o,shape:a,dataId:this.runWebGLProgram(s,[{shape:i,dtype:o,dataId:e}],o,c,!0,t).dataId}}runWebGLProgram(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5?arguments[5]:void 0;const i=this.makeTensorInfo(e.outputShape,n),s=this.texData.get(i.dataId);if(e.packedOutput&&(s.isPacked=!0),e.outPackingScheme===IH.DENSE){const t=null!=o?o:RH(e.outputShape);s.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(s.usage=e.outTexUsage),0===Wm(i.shape))return s.values=$m(i.dtype,0),i;const c=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Wm(t.shape)<=vv().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!$H(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),c.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const u={shape:i.shape,texData:s,isUniform:!1},d=function(e,t,n){let r="";t.concat(n).forEach((t=>{const a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const o=t.texData.texShape,{useSqueezeShape:i,uniformShape:s,keptDims:c}=wG(e.packedInputs,t.shape,o);let l="",u="",d="";if(1===s.length&&e.packedInputs){const e=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];l="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==s.length||e.packedInputs){if(s.length>2&&!e.packedInputs){const e=av(s);d="".concat(e[0]===o[1],"_").concat(e[e.length-1]===o[1])}}else u="".concat(s[0]>1,"_").concat(s[1]>1);const h=t.shape.length,p=2===s.length&&Um(t.shape,o),f=1===Wm(t.shape),g=IS(t.shape,n.shape),m=!e.packedInputs&&h===n.shape.length&&Um(o,n.texData.texShape),v=e.packedInputs||s.length>2?"":"".concat(o[0]>1,"_").concat(o[1]>1);r+="".concat(h,"_").concat(m,"_").concat(i?c:"","_").concat(s.length,"_").concat(f,"_").concat(g,"_").concat(p,"_").concat(l,"_").concat(u,"_").concat(d,"_").concat(v,"_").concat(a)}else{const e=t.isUniform?"uniform":t.texData.texShape;r+="".concat(t.shape,"_").concat(e,"_").concat(a)}}));const a=e.userCode;let o=e.constructor.name;return o+="_"+r+"_"+a+"".concat(vv().getNumber("WEBGL_VERSION")),o}(e,l,u),h=this.getAndSaveBinary(d,(()=>CG(this.gpgpu,e,l,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),vv().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(EG(t.inShapeInfos,n),EG([t.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):e.setOutputMatrixTexture(o.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===vv().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<n.length;++c){const r=n[c],{uniform:a,offset:o,shape:i,texShape:s}=t.variablesLocations[c];if(i){const{uniformShape:n}=wG(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(s&&e.gl.uniform2i(s,r.texData.texShape[0],r.texData.texShape[1]),null!=a)if(r.isUniform)if(Wm(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=r.texData.slice&&null!=o&&e.gl.uniform1i(o,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,c)}const s=t.outShapeLocation;if(s)switch(r.shape.length){case 1:e.gl.uniform1iv(s,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(s,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(s,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(s,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=av(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let c=0;c<t.program.customUniforms.length;++c){const n=t.program.customUniforms[c],r=t.customUniformLocations[c],o=a[c];if("float"===n.type)e.gl.uniform1fv(r,o);else if("vec2"===n.type)e.gl.uniform2fv(r,o);else if("vec3"===n.type)e.gl.uniform3fv(r,o);else if("vec4"===n.type)e.gl.uniform4fv(r,o);else if("int"===n.type)e.gl.uniform1iv(r,o);else if("ivec2"===n.type)e.gl.uniform2iv(r,o);else if("ivec3"===n.type)e.gl.uniform3iv(r,o);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(r,o)}}e.executeProgram()}(this.gpgpu,h,l,u,r),c.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const g=vv().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const e=iw();e-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!vv().getBool("WEBGL_LAZILY_UNPACK")&&s.isPacked&&!1===a){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!vv().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=dk((()=>{if(!vv().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=vv().getBool("DEBUG");vv().set("DEBUG",!1);const t=this.abs(dS(1e-8)).dataSync()[0];if(vv().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:o,usage:i,isPacked:s}=t;if(null!=o)return;const c=null!=this.activeTimers;let l;c&&(l=iw());let u=t.texShape;if(null==u&&(u=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=vv().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=vv().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&vv().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?Mm(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=Xm(e);e=t.newShape}let a=Wm(e),o=null;e.length<=1&&a<=n?o=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?o=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?o=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?o=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?o=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(o=[e[0],e[1]*e[2]*e[3]]);const i=null!=o&&Math.max(...o)>r&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||i)if(t){const t=GH(e);let n=2,r=2;e.length&&([n,r]=qH(e)),a=t*(n/2)*(r/2),o=jm(a).map((e=>2*e))}else o=jm(a);return o}(n,s),t.texShape=u),null!=a){const e=KH(n);let o,i=u[1],d=u[0];const h=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!s&&h||([i,d]=AH(u[0],u[1])),o=s?new DG(e,h):new _G(e,h);const p=h?[d,i]:u,f=this.makeTensorInfo(p,r),g=this.texData.get(f.dataId);g.usage=h?EH.PIXELS:EH.UPLOAD,g.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,a);const m=[[d,i]],v=!0,b=this.runWebGLProgram(o,[f],r,m,v),y=this.texData.get(b.dataId);t.texShape=y.texShape,t.isPacked=y.isPacked,t.usage=y.usage,vv().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=y.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),c&&(this.uploadWaitMs+=iw()-l)}else{const e=this.acquireTexture(u,i,r,s);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Zm(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await mN(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw PH(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:s}=IG(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=o,e.outShapeStridesLocation=i,e.outTexShapeLocation=s}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:a,width:o,channels:i}=e,s=lk().backend;if(!s.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=s.writeTexture(r,t,n,a,o,i);return lk().makeTensorFromDataId(c,t,n,s)}}fK.nextDataId=0;Qw()&&fk("webgl",(()=>new fK),2);const gK="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class mK{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=NS(t,n),this.enableShapeUniforms=NG(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const vK="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class bK{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=NS(t,n);const a=this.outputShape.length;this.enableShapeUniforms=NG(a);let o="";if(r)if(0===a||1===Wm(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=xG(a);if(o="\n          ".concat(e," coords = getOutputCoords();\n        "),1===a)this.enableShapeUniforms?o+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":o+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=Vq("coords",a);this.enableShapeUniforms?o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[a-2]," + 1) >= outShape[").concat(a," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[a-1]," + 1) >= outShape[").concat(a," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[a-2]," + 1) >= ").concat(this.outputShape[a-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[a-1]," + 1) >= ").concat(this.outputShape[a-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(o,"\n\n        setOutput(result);\n      }\n    ")}}function yK(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const xK={kernelName:Lb,backendName:"webgl",kernelFunc:yK};function wK(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,o=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(o.dataId),s=yK({inputs:{x:r},backend:n}),c=yK({inputs:{x:a},backend:n});return i.complexTensorInfos={real:s,imag:c},o}const kK={kernelName:Xv,backendName:"webgl",kernelFunc:wK},SK="return (a < 0.) ? b * a : a;",CK="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const IK={kernelName:jb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:o}=r,i=n.makeTensorInfo([],"float32",aw(o,"float32")),s=vv().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bK(CK,a.shape,i.shape):new mK(SK,a.shape,i.shape),c=n.runWebGLProgram(s,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),c}},EK="return (a < 0.) ? b * a : a;",NK="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const TK={kernelName:Cy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,o=vv().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bK(NK,r.shape,a.shape):new mK(EK,r.shape,a.shape);return n.runWebGLProgram(o,[r,a],"float32")}},RK="if (isnan(x)) return x;";function AK(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=e;return e=>{let{inputs:o,backend:i}=e;const{x:s}=o,c=i,l=a||s.dtype;if(c.shouldExecuteOnCPU([s])&&null!=r){const e=c.texData.get(s.dataId),t=r(e.values,l);return c.makeTensorInfo(s.shape,l,t)}let u;return u=vv().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new lK(s.shape,n):new $q(s.shape,t),c.runWebGLProgram(u,[s],l)}}function OK(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:o,dtype:i}=e;return e=>{let{inputs:s,backend:c}=e;const{a:l,b:u}=s,d=c;if(a&&"complex64"===l.dtype){const e=d.texData.get(l.dataId),n=d.texData.get(u.dataId),[r,a]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,a={dataId:n.dataId,dtype:n.dtype,shape:l.shape},o={dataId:r.dataId,dtype:r.dtype,shape:u.shape},i=new mK(t,l.shape,u.shape);return d.runWebGLProgram(i,[a,o],Mw(n.dtype,r.dtype))})),o=wK({inputs:{real:r,imag:a},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(a),o}const h=i||Mw(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||d.shouldExecuteOnCPU([l,u]))&&null!=o){const e=d.texData.get(l.dataId).values,t=d.texData.get(u.dataId).values,n="string"===l.dtype?CT(e):e,r="string"===l.dtype?CT(t):t,[a,i]=o(l.shape,u.shape,n,r,h),s=d.makeTensorInfo(i,h);return d.texData.get(s.dataId).values=a,s}let p;return p=vv().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new bK(n,l.shape,u.shape,r):new mK(t,l.shape,u.shape),d.runWebGLProgram(p,[l,u],h)}}function FK(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?aK:Qq;if("relu"===e)return t?iK:eK;if("elu"===e)return t?oK:Jq;if("relu6"===e)return t?sK:tK;if("prelu"===e)return t?NK:EK;if("leakyrelu"===e)return t?CK:SK;if("sigmoid"===e)return t?cK:rK;throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class _K{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,s=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=NG(this.outputShape.length);const l=r?e[1]:e[2],u=Math.ceil(l/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",m="";i&&(g=s?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(i,"\n        }"):c?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(i,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(i,"\n        }"),m="result = activation(result);");const v=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let b="rc.x",y="rc.x";e[0]<t[0]?b="imod(rc.x, ".concat(e[0],")"):t[0]<e[0]&&(y="imod(rc.x, ".concat(t[0],")")),this.userCode="\n      ".concat(g,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(b,";\n        int batchB = ").concat(y,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(d,");\n          vec4 b = getMatrixB(batchB, ").concat(h,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(v,"\n\n        ").concat(m,"\n\n        setOutput(result);\n      }\n    ")}}const DK={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class MK{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=NS(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const PK="return a * b;";function LK(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,o=Mw(r.dtype,a.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),o=new MK(DK.REAL,r.shape,a.shape),i=new MK(DK.IMAG,r.shape,a.shape),s=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:a.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:a.shape}],c=n.runWebGLProgram(o,s,"float32"),l=n.runWebGLProgram(i,s,"float32"),u=wK({inputs:{real:c,imag:l},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([r,a])){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),[i,s]=fq(r.shape,a.shape,e.values,t.values,o),c=n.makeTensorInfo(s,o);return n.texData.get(c.dataId).values=i,c}let i;return i=vv().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bK(PK,r.shape,a.shape):new mK(PK,r.shape,a.shape),n.runWebGLProgram(i,[r,a],o)}const zK={kernelName:py,backendName:"webgl",kernelFunc:LK};function BK(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:o}=r,i=n,s=Wm(a.shape),c=qm(o,s),l=Wm(c);Lm(s===l,(()=>"The new shape (".concat(c,") has ").concat(l," elements and the old ")+"shape (".concat(a.shape,") has ").concat(s," elements. The new shape and old ")+"shape must have the same number of elements."));const u=i.texData.get(a.dataId);return!u.isPacked||$H(a.shape,c)||null!==u.texture&&$H(u.shape,c)?(i.incRef(a.dataId),{dataId:a.dataId,shape:c,dtype:a.dtype}):function(e,t,n){const r=[GH(e.shape),...qH(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},o=[GH(t),...qH(t)],i=new Hq(o,r),s=[r],c=n.runWebGLProgram(i,[a],e.dtype,s,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(a,c,i)}const WK={kernelName:_y,backendName:"webgl",kernelFunc:BK};class UK{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:o}=e;this.outputShape=[r,o];const i=4*Math.floor(n/4),s=n%4;let c="sumValue += dot(values, ones);";if(null!=t){const e=1/t;c="sumValue += dot(values * ".concat(Vm(e)?e.toPrecision(2):e,", ones);")}let l="";a%n>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===s,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(2===s,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(3===s,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class VK{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:o}=e;this.outputShape=[r,o];let i="0.0",s="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",s="min"):"max"===t&&(i="-1.0 / 1e-20",s="max");let c="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const l=4*Math.floor(n/4),u=n%4;let d="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(s,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(s,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";a%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(i,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(i,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(d,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(2===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(d,"\n        } else if (").concat(3===u,") {\n          ").concat(h," values = ").concat(h,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(d,"\n        }\n        setOutput(").concat(c,");\n      }\n    ")}}function jK(e,t,n,r){const a=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=IN(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let o=e;for(let i=0;i<a.length;i++){const{inSize:s,windowSize:c,outSize:l}=a[i];let u,d;u="mean"===n?0===i?new UK({windowSize:c,inSize:s,batchSize:e.shape[0],outSize:l},s):new UK({windowSize:c,inSize:s,batchSize:e.shape[0],outSize:l}):new VK({windowSize:c,inSize:s,batchSize:e.shape[0],outSize:l},n),d=o,o=r.runWebGLProgram(u,[o],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return o}class HK{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;const r=xG(this.rank),a=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode="\n    void main() {\n      ".concat(r," resRC = getOutputCoords();\n      setOutput(getA(").concat(a,"));\n    }\n    ")}}class GK{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const r=xG(this.rank),a=Uq("rc",this.rank),o=new Array(this.rank);for(let l=0;l<t.length;l++)o[t[l]]=a[l];const i="vec2(".concat(o.slice(-2).join(),")"),s="++".concat(a[this.rank-1]," < ").concat(n[this.rank-1]),c="getChannel(getA(".concat(o.join(),"), ").concat(i,")");this.userCode="\n    void main() {\n      ".concat(r," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(c,";\n      if(").concat(s,") {\n        result[1] = ").concat(c,";\n      }\n      --").concat(a[this.rank-1],";\n      if(++").concat(a[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(c,";\n        if(").concat(s,") {\n          result[3] = ").concat(c,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function qK(e,t,n){const r=vv().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new GK(e.shape,t):new HK(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function KK(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;return function(e,t,n,r){const a=t,o=e.shape.length,i=Km(a,e.shape);let s=i;const c=mI(s,o),l=null!=c;let u=e;l&&(u=qK(e,c,r),s=bI(s.length,o)),gI("sum",s,o);const[d,h]=pI(u.shape,s);let p=d;n&&(p=fI(d,i));const f=Wm(h),g=BK({inputs:{x:u},attrs:{shape:[Wm(e.shape)/f,f]},backend:r}),m=jK(g,Pw(e.dtype),"sum",r),v=BK({inputs:{x:m},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(m),l&&r.disposeIntermediateTensorInfo(u),v}(a,o,i,n)}const XK={kernelName:ex,backendName:"webgl",kernelFunc:KK};function $K(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:o}=r,i=n,s=a.shape.length,c=new Array(s);for(let u=0;u<c.length;u++)c[u]=a.shape[o[u]];let l;if(i.shouldExecuteOnCPU([a])){const e=i.texData.get(a.dataId).values,t=Bq(e,a.shape,a.dtype,o,c);l=i.makeTensorInfo(c,a.dtype);i.texData.get(l.dataId).values=t}else l=qK(a,o,i);return l}const YK={kernelName:kx,backendName:"webgl",kernelFunc:$K},QK=1e3;function ZK(e){let{a:t,b:n,transposeA:r,transposeB:a,backend:o,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape.length,d=n.shape.length,h=r?t.shape[u-2]:t.shape[u-1],p=a?n.shape[d-1]:n.shape[d-2],f=r?t.shape[u-1]:t.shape[u-2],g=a?n.shape[d-2]:n.shape[d-1],m=t.shape.slice(0,-2),v=n.shape.slice(0,-2),b=Wm(m),y=Wm(v),x=NS(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,g]);Lm(h===p,(()=>"Error in matMul: inner shapes (".concat(h,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const w=r?[b,h,f]:[b,f,h],k=a?[y,g,p]:[y,p,g],S=BK({inputs:{x:t},backend:o,attrs:{shape:w}}),C=BK({inputs:{x:n},backend:o,attrs:{shape:k}}),I=[S,C],E=Math.max(b,y),N=r?S.shape[1]:S.shape[2],T=null!=i,R=null!=s,A="leakyrelu"===l,O=null!=l?FK(l,!0):null;let F;if((1===f||1===g)&&N>QK&&!1===(T||R||A||null!=O)){let e=S,t=C;r&&(e=$K({inputs:{x:S},backend:o,attrs:{perm:[0,2,1]}}),I.push(e)),a&&(t=$K({inputs:{x:C},backend:o,attrs:{perm:[0,2,1]}}),I.push(t));const n=1===g;let i=e;1!==g&&(i=BK({inputs:{x:e},backend:o,attrs:{shape:[E,N,1]}}),I.push(i));const s=1===g?2:1;let c=t;n&&(c=BK({inputs:{x:t},backend:o,attrs:{shape:[E,1,N]}}),I.push(c));const l=LK({inputs:{a:i,b:c},backend:o});F=KK({inputs:{x:l},backend:o,attrs:{axis:s,keepDims:!0}}),I.push(l)}else{const e=Mw(t.dtype,n.dtype),l=new _K(w,k,[E,f,g],r,a,T,O,R,A),u=[S,C];if(null!=i&&u.push(i),R&&u.push(s),A){const e=o.makeTensorInfo([],"float32",aw(c,"float32"));u.push(e),I.push(e)}F=o.runWebGLProgram(l,u,e)}const _=BK({inputs:{x:F},backend:o,attrs:{shape:x}});I.push(F);for(const D of I)o.disposeIntermediateTensorInfo(D);return _}const JK={kernelName:Ax,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:o,bias:i,preluActivationWeights:s}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=r;return ZK({a:a,b:o,transposeA:c,transposeB:l,backend:n,bias:i,preluActivationWeights:s,leakyreluAlpha:d,activation:u})}},eX="return abs(x);";const tX={kernelName:kv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=Iq(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let a;return a=vv().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new lK(r.shape,eX):new $q(r.shape,eX),n.runWebGLProgram(a,[r],r.dtype)}},nX=AK({opSnippet:Yq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),rX={kernelName:Sv,backendName:"webgl",kernelFunc:nX},aX=AK({opSnippet:Yq+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),oX={kernelName:Cv,backendName:"webgl",kernelFunc:aX},iX="return a + b;",sX=OK({opSnippet:iX,packedOpSnippet:iX,supportsComplex:!0,cpuKernelImpl:qG}),cX={kernelName:Iv,backendName:"webgl",kernelFunc:sX};class lX{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))}));const r=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(r,";\n        setOutput(result);\n      }\n    ")}}class uX{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))}));const r=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(r,";\n        setOutput(result);\n      }\n    ")}}const dX={kernelName:Ev,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,a=n;if(1===a.length)return yK({inputs:{x:a[0]},backend:r});if(a.length>vv().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),o=e({inputs:a.slice(t),backend:r});return e({inputs:[n,o],backend:r})}const o=a.map((e=>e.dtype)).reduce(((e,t)=>Mw(e,t))),i=a.map((e=>e.shape)),s=vv().getBool("WEBGL_PACK")?new uX(a[0].shape,i):new lX(a[0].shape,i);return r.runWebGLProgram(s,a,o)}};const hX={kernelName:Nv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r,s=a.shape.length,c=Km(o,a.shape);let l=c;const u=mI(l,s);let d=a;null!=u&&(d=$K({inputs:{x:a},backend:n,attrs:{perm:u}}),l=bI(l.length,s)),gI("all",l,s);const[h,p]=pI(d.shape,l),f=BK({inputs:{x:d},backend:n,attrs:{shape:[-1,Wm(p)]}}),g=jK(f,f.dtype,"all",n);let m;if(i){m=BK({inputs:{x:g},backend:n,attrs:{shape:fI(h,c)}})}else m=BK({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(d),m}};const pX={kernelName:Tv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r,s=a.shape.length,c=Km(o,a.shape);let l=c;const u=mI(l,s);let d=a;null!=u&&(d=$K({inputs:{x:a},backend:n,attrs:{perm:u}}),l=bI(l.length,s)),gI("any",l,s);const[h,p]=pI(d.shape,l),f=BK({inputs:{x:d},backend:n,attrs:{shape:[-1,Wm(p)]}}),g=jK(f,f.dtype,"any",n);let m;if(i){m=BK({inputs:{x:g},backend:n,attrs:{shape:fI(h,c)}})}else m=BK({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(d),m}};class fX{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,o];const i="max"===t?">":"<",s=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(r,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          int inIdx = ").concat(s,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(i," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class gX{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Lm(e.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const a=e[e.length-1],o=Math.ceil(a/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,s=i.length,c=xG(s),l=Vq("coords",s);let u,d;if(1===o){d=s+1;const e=xG(d);u="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[s-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[s-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[s-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[s-2],";")}else d=s,u="\n        ".concat(c," sourceLocR = coords;\n        ++").concat(l[s-1],";\n        ").concat(c," sourceLocG = coords;\n        ++").concat(l[s-2],";\n        ").concat(c," sourceLocA = coords;\n        --").concat(l[s-1],";\n        ").concat(c," sourceLocB = coords;\n        --").concat(l[s-2],";");const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),g=Vq("sourceLocR",d-1).concat("inIdx.r"),m=Vq("sourceLocG",d-1).concat("inIdx.g"),v=Vq("sourceLocB",d-1).concat("inIdx.b"),b=Vq("sourceLocA",d-1).concat("inIdx.a"),y="max"===n?"greaterThan":"lessThan",x=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(v.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),")));"),w="vec4(\n            getAChannel(".concat(g.join(),"),\n            hasNextCol ? getAChannel(").concat(m.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(v.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(b.join(),") : 0.)"),k=r?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(h.join(),"),\n                                          vec2(").concat(h.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(h.join(),"),\n                               vec2(").concat(h.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(c," coords = getOutputCoords();\n        bool hasNextCol = ").concat(l[s-1]," < ").concat(i[s-1]-1,";\n        bool hasNextRow = ").concat(l[s-2]," < ").concat(i[s-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(x,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(y,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function mX(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=t.shape[0],o=t.shape[1];null!=r&&(a=r.shape[0],o=r.shape[1]);const i=IN(o),s={windowSize:i,inSize:o,batchSize:a,outSize:Math.ceil(o/i)},c=new fX(s,n,null==r),l=[t];null!=r&&l.push(r);const u=e.runWebGLProgram(c,l,"int32");if(1===u.shape[1])return u;const d=mX(e,t,n,u);return e.disposeIntermediateTensorInfo(u),d}function vX(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const a=null!=r?r.shape:t.shape,o=IN(a[a.length-1]),i=new gX(a,o,n,null==r),s=null==r?[t]:[t,r],c=e.runWebGLProgram(i,s,"int32");if(c.shape.length===t.shape.length){const r=vX(e,t,n,c);return e.disposeIntermediateTensorInfo(c),r}return c}function bX(e,t,n,r){const a=[n];if(gI("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!vv().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],o=e.texData.get(t.dataId);let i=t;null!==o&&o.isPacked&&(i=e.unpackTensor(t),n.push(i));const[s,c]=pI(i.shape,a),l=Wm(c),u=BK({inputs:{x:i},backend:e,attrs:{shape:[-1,l]}});n.push(u);const d=mX(e,u,r);n.push(d);const h=BK({inputs:{x:d},backend:e,attrs:{shape:s}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return vX(e,t,r)}const yX={kernelName:Rv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o}=r;let i=Km(o,a.shape);const s=mI(i,a.shape.length);let c=a;const l=[];null!=s&&(c=$K({inputs:{x:a},backend:n,attrs:{perm:s}}),l.push(c),i=bI(i.length,c.shape.length)),gI("argMax",[i[0]],c.shape.length);const u=bX(n,c,i[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};const xX={kernelName:Av,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o}=r;let i=Km(o,a.shape);const s=mI(i,a.shape.length);let c=a;const l=[];null!=s&&(c=$K({inputs:{x:a},backend:n,attrs:{perm:s}}),l.push(c),i=bI(i.length,c.shape.length)),gI("argMin",[i[0]],c.shape.length);const u=bX(n,c,i[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},wX=AK({opSnippet:Yq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),kX={kernelName:Ov,backendName:"webgl",kernelFunc:wX},SX=AK({opSnippet:Yq+"return log(x + sqrt(x * x + 1.0));"}),CX={kernelName:Fv,backendName:"webgl",kernelFunc:SX},IX=AK({opSnippet:Yq+"\n  return atan(x);\n"}),EX={kernelName:_v,backendName:"webgl",kernelFunc:IX},NX=OK({opSnippet:gK+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+vK+"\n  return result;\n"}),TX={kernelName:Mv,backendName:"webgl",kernelFunc:NX},RX=AK({opSnippet:Yq+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),AX={kernelName:Dv,backendName:"webgl",kernelFunc:RX};class OX{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideHeight,s=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,g="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),m="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let v="0.0";if(f||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(i,", ").concat(s,");\n        const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(c,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(r?a?g:m:"wR * ".concat(d," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let b="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(b="avgValue / max(count, 1.0)");const y=4*Math.floor(o/4),x=o%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(i,", ").concat(s,");\n      const ivec2 pads = ivec2(").concat(h,", ").concat(p,");\n      const float initializationValue = ").concat(v,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(v,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(c,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(y,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(y,";\n          if (").concat(1===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(b,");\n      }\n    ")}}class FX{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideDepth,s=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,g=e.padInfo.front,m=e.padInfo.top,v=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let y="0.0";if(b||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(i,", ").concat(s,", ").concat(c,");\n        const ivec3 pads = ivec3(").concat(g,", ").concat(m,", ").concat(v,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(h,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(d,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(r?a?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let x="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(o/4),k=o%4,S="\n      if (".concat(b,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(i,", ").concat(s,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(g,", ").concat(m,", ").concat(v,");\n      const float initializationValue = ").concat(y,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(y,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(h,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(d,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(d,", ch)\n              );\n\n              ").concat(S,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(d,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(d,", ch),\n                initializationValue\n              );\n\n              ").concat(S,"\n            }\n          }\n        }\n        setOutput(").concat(x,");\n      }\n    ")}}const _X={kernelName:Pv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;nG(a,"avgPool");const{filterSize:o,strides:i,pad:s,dimRoundingMode:c}=r;Lm(wC(i,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'")));const l=dC(a.shape,o,i,1,s,c);if(1===l.filterWidth&&1===l.filterHeight&&Um(l.inShape,l.outShape))return yK({inputs:{x:a},backend:n});const u=new OX(l,"avg",!1);return n.runWebGLProgram(u,[a],"float32")}};const DX={kernelName:zv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:o,strides:i,pad:s,dimRoundingMode:c,dataFormat:l}=r,u=hC(a.shape,o,i,[1,1,1],s,c,l),d=new FX(u,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}};class MX{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=s-1-e.padInfo.top,u=c-1-e.padInfo.left,d=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(u,");\n      const float avgMultiplier = float(").concat(d,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(s,";\n            wR += ").concat(o,") {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c,";\n            wC+= ").concat(i,") {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class PX{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,s=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=d-1-e.padInfo.top,g=h-1-e.padInfo.left,m=1/(t*n*r);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(g,");\n      const float avgMultiplier = float(").concat(m,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(s,") {\n          float dyD = float(dyDCorner + wD) / ").concat(a,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(d,";\n              wR += ").concat(c,") {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const LX={kernelName:Bv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,i=o,{filterSize:s,strides:c,pad:l,dimRoundingMode:u}=r,d=hC(i.shape,s,c,[1,1,1],l,u),h=new PX(d);return n.runWebGLProgram(h,[a],i.dtype)}};const zX={kernelName:Lv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,i=o;nG([a,o],"avgPoolGrad");const{filterSize:s,strides:c,pad:l}=r,u=dC(i.shape,s,c,1,l),d=new MX(u);return n.runWebGLProgram(d,[a],i.dtype)}};const BX={kernelName:Wv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:o}=t,{transposeA:i,transposeB:s}=r;return ZK({a:a,b:o,transposeA:i,transposeB:s,backend:n})}};class WX{constructor(e,t,n,r,a,o){this.outputShape=[],this.variableNames=["x","mean","variance"],NS(e,t),NS(e,n);let i="0.0";null!=r&&(NS(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let s="1.0";null!=a&&(NS(e,a),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(i,";\n        float scale = ").concat(s,";\n        float inv = scale * inversesqrt(variance + float(").concat(o,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class UX{constructor(e,t,n,r,a,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],NS(e,t),NS(e,n);let i="vec4(0.0)";null!=r&&(NS(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let s="vec4(1.0)";null!=a&&(NS(e,a),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(i,";\n        vec4 scale = ").concat(s,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(o,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const VX={kernelName:Fb,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,mean:o,variance:i,offset:s,scale:c}=t;Lm(o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Lm(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Lm(null==c||o.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=r;null==l&&(l=.001);const u=[a,o,i];let d=null;null!=s&&(d=s.shape,u.push(s));let h=null;null!=c&&(h=c.shape,u.push(c));const p=vv().getBool("WEBGL_PACK_NORMALIZATION")?new UX(a.shape,o.shape,i.shape,d,h,l):new WX(a.shape,o.shape,i.shape,d,h,l);return n.runWebGLProgram(p,u,u[0].dtype)}};class jX{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=xG(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return HX.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let r;const a=e.map(((e,t)=>"sourceLoc.".concat(HX[t]," = start[").concat(t,"] + coords.").concat(HX[t],";")));r="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(a.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(r,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const HX=["x","y","z","w","u","v"];class GX{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=xG(this.rank),n=Vq("coords",this.rank),r=Vq("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":"vec2(".concat(r.slice(-2).join(),")"),o="getChannel(getSource(".concat(r.join(),"), ").concat(a,")"),i="\n      result.x = ".concat(o,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(r[this.rank-1],";\n        result.y = ").concat(o,";\n        --").concat(r[this.rank-1],";\n      }\n    "),s=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(r[this.rank-2],";\n        result.z = ").concat(o,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(r[this.rank-1],";\n          result.w = ").concat(o,";\n        }\n      }\n    "),c=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map(((e,t)=>"start[".concat(t,"]"))).join(),");"):e.map(((e,t)=>"".concat(r[t]," = ").concat(n[t]," + start[").concat(t,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(c,"\n        vec4 result = vec4(0.);\n        ").concat(i,"\n        ").concat(s,"\n        setOutput(result);\n      }\n    ")}}function qX(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:o,size:i}=r,[s,c]=aC(a,o,i);if(HS(a,s,c),0===Wm(c))return n.makeTensorInfo(c,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.texData.get(a.dataId),t=Eq(e.values,s,c,a.shape,a.dtype);return n.makeTensorInfo(c,a.dtype,t)}const{isPacked:l}=n.texData.get(a.dataId),u=nC(a.shape,s,c);if(l||!u){const e=vv().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new GX(c):new jX(c),t=[s];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){const a=r.texData.get(e.dataId),o=r.makeTensorInfo(n,e.dtype),i=r.texData.get(o.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let s=rC(t,av(e.shape));a.slice&&(s+=a.slice.flatOffset),i.slice={flatOffset:s,origDataId:a.slice&&a.slice.origDataId||e.dataId};const c=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,c+1),o}(a,s,c,n)}const KX={kernelName:Ky,backendName:"webgl",kernelFunc:qX},XX={kernelName:Uv,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:o,crops:i}=r;Lm(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const s=o.reduce(((e,t)=>e*t)),c=NN(a.shape,o,s),l=TN(c.length,o.length),u=RN(a.shape,o,s),d=AN(i,o.length),h=ON(u,i,o.length),p=[],f=BK({inputs:{x:a},backend:n,attrs:{shape:c}}),g=$K({inputs:{x:f},backend:n,attrs:{perm:l}}),m=BK({inputs:{x:g},backend:n,attrs:{shape:u}}),v=qX({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(g),p.push(m),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),v}};const $X={kernelName:Vv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:o}=t,{size:i}=r,s=n.readSync(a.dataId),c=n.readSync(o.dataId),l=KG(s,c,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,l)}};const YX={kernelName:jv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,o=vv().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=vv().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(a.dataId).values,[o,i]=$G(r.shape,a.shape,e,t,r.dtype),s=n.makeTensorInfo(i,r.dtype);return n.texData.get(s.dataId).values=o,s}let s;return s=o?new bK("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,a.shape,!1):new mK("\n  return float(int(a.r) & int(b.r));\n",r.shape,a.shape),n.runWebGLProgram(s,[r,a],r.dtype)}};const QX={kernelName:Hv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,o=n.readSync(r.dataId),i=n.readSync(a.dataId),s=NS(Array.from(o),Array.from(i));return n.makeTensorInfo([s.length],"int32",Int32Array.from(s))}},ZX=OK({opSnippet:"return float(a != b);",cpuKernelImpl:mq,dtype:"bool"}),JX={kernelName:gy,backendName:"webgl",kernelFunc:ZX};function e$(e){const{inputs:t,backend:n}=e,{input:r}=t;return yK({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const t$={kernelName:Ay,backendName:"webgl",kernelFunc:e$},n$="return float(int(x));";const r$={kernelName:Gv,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:a}=t,{x:o}=n,{dtype:i}=a;if("complex64"===i){if("complex64"===o.dtype)return yK({inputs:{x:o},backend:r});const t=OI(o.shape),n=e({inputs:{x:o},backend:r,attrs:{dtype:"float32"}}),a=wK({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===o.dtype){const t=e$({inputs:{input:o},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!Qm(o.dtype,i)){const e=yK({inputs:{x:o},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([o])){const e=r.texData.get(o.dataId).values,[t,n,a]=YG(e,o.shape,o.dtype,i);return r.makeTensorInfo(t,n,a)}if("int32"===i)return function(e,t){const n=new $q(e.shape,n$),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(o,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",$m("bool",1)),t=ZX({inputs:{a:o,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(o.dtype," to ").concat(i))}},a$="return ceil(x);",o$=AK({opSnippet:a$,packedOpSnippet:a$,cpuKernelImpl:QG}),i$={kernelName:qv,backendName:"webgl",kernelFunc:o$};class s${constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class c${constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const l$={kernelName:Kv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:o,clipValueMax:i}=r;let s;s=vv().getBool("WEBGL_PACK_CLIP")?new c$(a.shape):new s$(a.shape);const c=[[o],[i]];return n.runWebGLProgram(s,[a],a.dtype,c)}};class u${constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function d$(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const h$={kernelName:$v,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),o=new u$(r.shape),i=[d$(r,a.complexTensorInfos.real),d$(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(o,i,i[0].dtype)}};class p${constructor(e){this.outputShape=[],this.outputShape=bN(e,1),this.variableNames=e.map(((e,t)=>"T".concat(t)));const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let o=1;o<t.length;o++){const e=t[o-1];n.push("else if (yC < ".concat(t[o],") ")+"setOutput(getT".concat(o,"(yR, yC-").concat(e,"));"))}const r=t.length,a=t[t.length-1];n.push("else setOutput(getT".concat(r,"(yR, yC-").concat(a,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class f${constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=bN(e,t);const n=this.outputShape,r=n.length,a=xG(r),o=Vq("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>"T".concat(t)));const s=new Array(e.length-1);s[0]=e[0][t];for(let f=1;f<s.length;f++)s[f]=s[f-1]+e[f][t];const c=i[t],l=i.slice(-2),u=i.join();let d="if (".concat(c," < ").concat(s[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(l.join(),"));\n        }");for(let f=1;f<s.length;f++){const e=s[f-1];d+="\n        if (".concat(c," < ").concat(s[f],"  && ").concat(c," >= ").concat(s[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(g$(i,c,e),"),\n            vec2(").concat(g$(l,c,e),"));\n        }")}const h=s.length,p=s[s.length-1];d+="\n        return getChannel(\n          getT".concat(h,"(").concat(g$(i,c,p),"),\n          vec2(").concat(g$(l,c,p),"));"),this.userCode="\n      float getValue(".concat(i.map((e=>"int "+e)),") {\n        ").concat(d,"\n      }\n\n      void main() {\n        ").concat(a," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(o,"), 0., 0., 0.);\n\n        ").concat(o[r-1]," = ").concat(o[r-1]," + 1;\n        if (").concat(o[r-1]," < ").concat(n[r-1],") {\n          result.g = getValue(").concat(o,");\n        }\n\n        ").concat(o[r-2]," = ").concat(o[r-2]," + 1;\n        if (").concat(o[r-2]," < ").concat(n[r-2],") {\n          result.a = getValue(").concat(o,");\n        }\n\n        ").concat(o[r-1]," = ").concat(o[r-1]," - 1;\n        if (").concat(o[r-2]," < ").concat(n[r-2]," &&\n            ").concat(o[r-1]," < ").concat(n[r-1],") {\n          result.b = getValue(").concat(o,");\n        }\n        setOutput(result);\n      }\n    ")}}function g$(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?"".concat(e," - ").concat(n):e)).join()}function m$(e){const{inputs:t,backend:n}=e,{input:r}=t;return yK({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const v$={kernelName:Bb,backendName:"webgl",kernelFunc:m$};function b$(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>e$({inputs:{input:e},backend:n}))),a=e.map((e=>m$({inputs:{input:e},backend:n}))),o=b$(r,t,n),i=b$(a,t,n),s=wK({inputs:{real:o,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),s}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const r=Wm(e.shape.slice(t));return BK({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),o=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=bN(a.map((e=>e.shape)),1),s=1===a[0].shape[0],c=ZG(o,i,r,s),l=bN(e.map((e=>e.shape)),t),u=n.makeTensorInfo(l,r,c);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const o=e.filter((e=>Wm(e.shape)>0)),i=vv().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const t=i?new $q(e[0].shape,nK):new lK(e[0].shape,nK);return n.runWebGLProgram(t,e,r)}const s=vv().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>s){const e=[];for(let a=0;a<o.length;a+=s){const r=o.slice(a,a+s);e.push(b$(r,t,n))}const r=b$(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new f$(o.map((e=>e.shape)),t);return n.runWebGLProgram(e,o,r)}const{tensors2D:c,outShape:l}=function(e,t,n){const r=bN(e.map((e=>e.shape)),t),a=e.map((e=>BK({inputs:{x:e},attrs:{shape:[-1,Wm(e.shape.slice(t))]},backend:n})));return{tensors2D:a,outShape:r}}(o,t,n),u=new p$(c.map((e=>e.shape))),d=n.runWebGLProgram(u,c,r);c.forEach((e=>n.disposeIntermediateTensorInfo(e)));const h=BK({inputs:{x:d},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(d),h}function y$(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,o=Km(a,t[0].shape)[0];vN(t.map((e=>e.shape)),o);const i=bN(t.map((e=>e.shape)),o);if(0===Wm(i))return n.makeTensorInfo(i,t[0].dtype,[]);const s=t.filter((e=>Wm(e.shape)>0));return 1===s.length?yK({inputs:{x:s[0]},backend:n}):b$(s,o,n)}const x$={kernelName:Yv,backendName:"webgl",kernelFunc:y$};class w${constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,i=e.padInfo.left,s=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,g="channelsLast"===e.dataFormat,m=g?1:2,v=g?2:3,b=g?3:1;let y="",x="";n&&(y=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(y,"\n\n      const ivec2 strides = ivec2(").concat(s,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(b,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(m,"], coords[").concat(v,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(d,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(h,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(g,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(g,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(g,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(g,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(x,"\n        setOutput(result);\n      }\n    ")}}class k${constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,s=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(a,", ").concat(o,", ").concat(i,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(r,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(s,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(d,"; wR++) {\n            int xR = xRCorner + wR * ").concat(c,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class S${constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=NG(this.outputShape.length);const o=e.padInfo.left,i=e.strideWidth,s=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,u=l;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<l;g++)d+="\n           vec4 xTexelC".concat(2*g,";\n           int xTexelC").concat(2*g,"Ready;\n           vec4 xTexelC").concat(2*g+1,";\n           int xTexelC").concat(2*g+1,"Ready;\n           vec4 xC").concat(g,";");d+="\n     for (int r = 0; r < ".concat(c,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let g=0;g<l;g++)d+="\n           xTexelC".concat(2*g," = vec4(0.0);\n           xTexelC").concat(2*g,"Ready = 0;\n           xTexelC").concat(2*g+1," = vec4(0.0);\n           xTexelC").concat(2*g+1,"Ready = 0;\n           xC").concat(g," = vec4(0.0);");d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(u+1)/2;g++){const t=2*g;if(d+="\n           xC = xCCorner + ".concat(t*s,";\n           "),1===i){if(t<l&&(o%2===1?(d+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),d+=1===s&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):d+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<l)){const e=o%2===0?Mm(s):s;s%2===0&&o%2===1||s%2!==0&&o%2!==1?(d+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),d+=s>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):d+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<l&&(o%2===1?(d+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<l&&(d+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(d+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<l&&(d+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<l&&(d+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<l&&(d+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=r?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):a?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(h,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(d,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class C${constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=NG(this.outputShape.length);const{dataFormat:n}=t,r=aG(),a="channelsLast"===n,o=a?1:2,i=a?2:3,s=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let c="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)c+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(l,";\n\n          ").concat(s,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(o,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(i,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(a,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c,"\n\n        ").concat(r.output," = result;\n      }\n    ")}}function I$(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function E$(e){let{x:t,filter:n,convInfo:r,backend:a,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:c=null}=e;const l=t.shape,u=a.texData.get(t.dataId),d=r.inChannels,h=l[0]*l[1]*l[2],p=r.outChannels,f="channelsLast"===r.dataFormat,g=!1;let m;const v=[];if(null!=i){const e=I$(i.shape,f);null!=e&&(i=BK({inputs:{x:i},backend:a,attrs:{shape:e}}),v.push(i))}if(null!=o){const e=I$(o.shape,f);null!=e&&(o=BK({inputs:{x:o},backend:a,attrs:{shape:e}}),v.push(o))}if(!((1===h||1===p)&&d>QK)&&u.isPacked&&f&&null!=u.texture&&l[2]%2!==0&&Um(u.shape.slice(-3),l.slice(-3))){const e=l[0]*l[1]*(l[2]+1),d={dataId:t.dataId,shape:[1,e,r.inChannels],dtype:t.dtype},h=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Lm($H(u.shape,d.shape),(()=>"packed reshape ".concat(u.shape," to ").concat(d.shape," isn't free")));const p=BK({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}});v.push(p);const f=ZK({a:d,b:p,backend:a,transposeA:false,transposeB:g,bias:o,activation:c,preluActivationWeights:i,leakyreluAlpha:s}),b=a.texData.get(f.dataId);Lm(b.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=h,b.shape=r.outShape,m=yK({inputs:{x:f},backend:a}),m.shape=r.outShape,v.push(f)}else{const e=r.outHeight*r.outWidth,l=BK({inputs:{x:t},backend:a,attrs:{shape:f?[r.batchSize,e,r.inChannels]:[r.batchSize,r.inChannels,e]}}),u=BK({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}}),d=ZK({a:f?l:u,b:f?u:l,transposeA:!f,transposeB:g,backend:a,bias:o,activation:c,preluActivationWeights:i,leakyreluAlpha:s});m=BK({inputs:{x:d},backend:a,attrs:{shape:r.outShape}}),v.push(l),v.push(u),v.push(d)}for(const b of v)a.disposeIntermediateTensorInfo(b);return m}function N$(e){let{x:t,filter:n,convInfo:r,backend:a,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:c=null}=e;const{filterWidth:l,filterHeight:u,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=r,g="channelsLast"===f,m=l*u*d,v=p*h,b=[r.batchSize,m,v],y=[];if(null!=i){const e=I$(i.shape,g);null!=e&&(i=BK({inputs:{x:i},backend:a,attrs:{shape:e}}),y.push(i))}if(null!=o){const e=I$(o.shape,g);null!=e&&(o=BK({inputs:{x:o},backend:a,attrs:{shape:e}}),y.push(o))}const x=BK({inputs:{x:n},backend:a,attrs:{shape:[1,m,Wm(n.shape)/m]}});y.push(x);const w=new C$(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(w,[t],"float32",k),C=BK({inputs:{x:S},backend:a,attrs:{shape:b}});y.push(S),y.push(C);const I=null!=o,E=null!=i,N="leakyrelu"===c,T=c?FK(c,!0):null,R=new _K(g?C.shape:x.shape,g?x.shape:C.shape,g?[r.batchSize,v,r.outChannels]:[r.batchSize,r.outChannels,v],!0,!1,I,T,E,N),A=g?[C,x]:[x,C];if(o&&A.push(o),E&&A.push(i),N){const e=a.makeTensorInfo([],"float32",aw(s,"float32"));A.push(e),y.push(e)}const O=a.runWebGLProgram(R,A,"float32"),F=BK({inputs:{x:O},backend:a,attrs:{shape:r.outShape}});y.push(O);for(const _ of y)a.disposeIntermediateTensorInfo(_);return F}const T$={kernelName:Qv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dataFormat:c,dilations:l,dimRoundingMode:u}=r,d=SC(c),h=pC(a.shape,o.shape,i,l,s,u,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&vv().getBool("WEBGL_EXP_CONV")){const e=new S$(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[a,o],"float32",t)}else if(vv().getBool("WEBGL_CONV_IM2COL"))p=N$({x:a,filter:o,convInfo:h,backend:n});else{const e=new w$(h);p=n.runWebGLProgram(e,[a,o],"float32")}else p=E$({x:a,filter:o,convInfo:h,backend:n});const f=BK({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class R${constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(a,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(o?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class A${constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,s=n-1-e.padInfo.left,c=o?1:2,l=o?2:3,u=o?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(o,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class O${constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,o=e.padInfo.top,i=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(a,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(o,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(r," - ").concat(i,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class F${constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,s=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(s,", ").concat(c,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(a,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(r,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(r," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const _$={kernelName:Zv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,pad:s,dataFormat:c,dimRoundingMode:l,filterShape:u}=r,d=SC(c),h=pC(a.shape,u,i,1,s,l,!1,d),p=new R$(h);return n.runWebGLProgram(p,[a,o],"float32")}};class D${constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=NG(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(r,", ").concat(a,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const M$={kernelName:Jv,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{inputShape:i,strides:s,pad:c,dataFormat:l,dimRoundingMode:u}=r,d=SC(l),h=pC(i,o.shape,s,1,c,u,!1,d);if(vv().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new D$(h);return n.runWebGLProgram(t,[a,o],"float32",e)}{const e=new A$(h);return n.runWebGLProgram(e,[a,o],"float32")}}};const P$={kernelName:eb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dilations:c}=r,l=fC(a.shape,o.shape,i,c,s),u=new k$(l);return n.runWebGLProgram(u,[a,o],"float32")}};const L$={kernelName:tb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,pad:s,filterShape:c}=r,l=fC(a.shape,c,i,1,s),u=new O$(l);return n.runWebGLProgram(u,[a,o],"float32")}};const z$={kernelName:nb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{pad:i,strides:s,inputShape:c}=r,l=fC(c,o.shape,s,1,i),u=new F$(l);return n.runWebGLProgram(u,[a,o],"float32")}},B$=AK({opSnippet:RK+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(vK,"\n  return result;\n")}),W$={kernelName:rb,backendName:"webgl",kernelFunc:B$},U$=AK({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),V$={kernelName:ab,backendName:"webgl",kernelFunc:U$};class j${constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,i,s,c]=e,[l]=t,[u,d]=n;this.outputShape=[l,u,d,c];const h="bilinear"===r?1:0,[p,f]=["".concat(i-1,".0"),"".concat(s-1,".0")],[g,m,v]=u>1?["".concat((i-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[b,y,x]=d>1?["".concat((s-1)/(d-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(g,");\n      const float width_ratio = float(").concat(b,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(o,") {\n          return;\n        }\n\n        float height_scale = ").concat(m,";\n        float width_scale = ").concat(y,";\n\n        float in_y = ").concat(v,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(a,"));\n          return;\n        }\n        float in_x = ").concat(x,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(a,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(h," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const H$={kernelName:sb,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:o,boxInd:i}=t,{cropSize:s,method:c,extrapolationValue:l}=r,u=new j$(a.shape,o.shape,s,c,l);return n.runWebGLProgram(u,[a,o,i],"float32")}};var G$;!function(e){e.Prod="*",e.Sum="+"}(G$||(G$={}));class q${constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,o=this.op===G$.Prod?"1.0":"0.0",i=n?o:"getX(".concat(K$(a,"coords",this.op),")"),s=this.outputShape[this.outputShape.length-1];let c="",l="";n?(c=r?"end != ".concat(s-1):"end != 0",l=r?"end + 1":"end - 1"):(c=r?"end + pow2 < ".concat(s):"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(xG(a)," coords = getOutputCoords();\n        int end = ").concat(X$(a,"coords",this.op),";\n        float val = ").concat(i,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(l,";\n          ").concat(X$(a,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(K$(a,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function K$(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function X$(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function $$(e,t,n,r,a,o){const i=t.shape.length,s=mI([r],i);let c=t;null!=s&&(c=$K({inputs:{x:t},backend:n,attrs:{perm:s}}));const l=bI(1,i)[0];if(l!==i-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(r));const u=c.shape[l];let d=yK({inputs:{x:c},backend:n});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){const t=new q$(e,c.shape,!1,o),r=[[h]],a=d;d=n.runWebGLProgram(t,[d],d.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){const t=new q$(e,c.shape,a,o),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=s){const e=$K({inputs:{x:d},backend:n,attrs:{perm:vI(s)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),e}return d}const Y$={kernelName:ob,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,exclusive:i,reverse:s}=r;return $$(G$.Prod,a,n,o,i,s)}};const Q$={kernelName:ib,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,exclusive:i,reverse:s}=r;return $$(G$.Sum,a,n,o,i,s)}};const Z$={kernelName:cb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:o}=t,{size:i,binaryOutput:s}=r;if(1===a.shape.length){const e=n.readSync(a.dataId),t=n.readSync(o.dataId),r=KG(e,t,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,r)}if(2===a.shape.length){const e=n.bufferSync(a),t=n.bufferSync(o),r=XG(e,t,i,s);return n.makeTensorInfo(r.shape,o.dtype,r.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(a.shape.length,"."))}};class J${constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const eY={kernelName:lb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:o,dataFormat:i}=r,s=a.shape[0],c=("NHWC"===i?a.shape[1]:a.shape[2])*o,l=("NHWC"===i?a.shape[2]:a.shape[3])*o,u=("NHWC"===i?a.shape[3]:a.shape[1])/(o*o),d=new J$("NHWC"===i?[s,c,l,u]:[s,u,c,l],o,i);return n.runWebGLProgram(d,[a],a.dtype)}};class tY{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=NG(this.outputShape.length);const o=e.filterHeight,i=e.filterWidth,s=e.outChannels/e.inChannels;let c="",l="";n&&(c=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),l="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(c,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(s,";\n        int q = d2 - d1 * ").concat(s,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(o,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(i,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(l,"\n        setOutput(result);\n      }\n    ")}}class nY{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=NG(this.outputShape.length);const o=e.outChannels/e.inChannels,i=e.padInfo.left,s=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,d=u;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)h+="\n          vec4 xTexelC".concat(2*m,";\n          int xTexelC").concat(2*m,"Ready;\n          vec4 xTexelC").concat(2*m+1,";\n          int xTexelC").concat(2*m+1,"Ready;\n          vec4 xC").concat(m,";");h+="\n    for (int r = 0; r < ".concat(l,"; r++) {\n      ");for(let m=0;m<u;m++)h+="\n          xTexelC".concat(2*m," = vec4(0.0);\n          xTexelC").concat(2*m,"Ready = 0;\n          xTexelC").concat(2*m+1," = vec4(0.0);\n          xTexelC").concat(2*m+1,"Ready = 0;\n          xC").concat(m," = vec4(0.0);");h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let m=0;m<(d+1)/2;m++){const e=2*m;if(h+="\n          xC = xCCorner + ".concat(e*c,";\n          "),1===s){if(e<u&&(i%2===1?(h+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),h+=1===c&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):h+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<u)){const t=i%2===0?Mm(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(h+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),h+=c>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):h+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<u&&(i%2===1?(h+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<u&&(h+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(h+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<u&&(h+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<u&&(h+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<u&&(h+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(h,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(g,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const rY={kernelName:ub,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dilations:c,dimRoundingMode:l}=r;let u=c;null==u&&(u=[1,1]),Lm(wC(i,u),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(i," and dilations '").concat(u,"'")));const d=pC(a.shape,o.shape,i,u,s,l,!0);let h;h=vv().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new nY(d):new tY(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[a,o],"float32",p)}};class aY{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(o," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(a,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class oY{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(s,"; dm++) {\n              int d2 = d1 * ").concat(s," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const iY={kernelName:db,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,dilations:s,pad:c,dimRoundingMode:l,filterShape:u}=r,d=pC(a.shape,u,i,s,c,l,!0),h=new aY(d);return n.runWebGLProgram(h,[a,o],"float32")}};const sY={kernelName:hb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{strides:i,dilations:s,pad:c,dimRoundingMode:l,inputShape:u}=r,d=pC(u,o.shape,i,s,c,l,!0),h=new oY(d);return n.runWebGLProgram(h,[a,o],"float32")}};class cY{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const lY={kernelName:pb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],o=Wm(r.shape),i=BK({inputs:{x:r},backend:n,attrs:{shape:[o]}}),s=new cY(o),c=n.runWebGLProgram(s,[i],i.dtype),l=BK({inputs:{x:c},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(c),l}};class uY{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:o,filterHeight:i,filterWidth:s,dilationHeight:c,dilationWidth:l}=e,{top:u,left:d}=r;this.userCode="\n      const ivec2 strides = ivec2(".concat(a,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(d,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(i,"; h++) {\n          int hIn = hBeg + h * ").concat(c,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(s,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const dY={kernelName:fb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dilations:c}=r,l=uC(a.shape,o.shape,i,s,"NHWC",c);let u;const d=new uY(l);u=n.runWebGLProgram(d,[a,o],"float32");const h=BK({inputs:{x:u},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(u),h}};const hY={kernelName:yb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,o=t,{allDims:i,summedDims:s,idDims:c}=nT(a,o.length);aT(i.length,c,o);const{path:l,steps:u}=oT(s,c),d=u.length;let h=null,p=i.length;const f=[];for(let g=0;g<d;++g){for(const e of u[g]){const{permutationIndices:t,expandDims:r}=rT(p,c[e]);let a;iT(t)?a=o[e]:(a=$K({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Um(a.shape,i)||(a=BK({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===h?h=a:(h=LK({inputs:{a:a,b:h},backend:n}),f.push(h))}g<d-1&&(l[g]>=0&&(h=KK({inputs:{x:h},backend:n,attrs:{axis:l[g]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const g of f)g!==h&&n.disposeIntermediateTensorInfo(g);return h}},pY=AK({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),fY={kernelName:xb,backendName:"webgl",kernelFunc:pY},gY={kernelName:wb,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:a}=t,o=vv().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bK("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new mK("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(o,[r,a],r.dtype)}},mY=OK({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:JG}),vY={kernelName:Sb,backendName:"webgl",kernelFunc:mY},bY=AK({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(zN,";\n  float a1 = ").concat(BN,";\n  float a2 = ").concat(WN,";\n  float a3 = ").concat(UN,";\n  float a4 = ").concat(VN,";\n  float a5 = ").concat(jN,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),yY={kernelName:kb,backendName:"webgl",kernelFunc:bY},xY=AK({opSnippet:RK+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:eq,dtype:"float32"}),wY={kernelName:Cb,backendName:"webgl",kernelFunc:xY};function kY(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:o}=t,i=o.shape.length,s=o.shape.slice();let c=a;return a<0&&(Lm(-(i+1)<=a,(()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]"))),c=i+a+1),s.splice(c,0,1),BK({inputs:{x:o},backend:r,attrs:{shape:s}})}const SY={kernelName:Ib,backendName:"webgl",kernelFunc:kY},CY="return exp(x) - 1.0;",IY=AK({opSnippet:CY,packedOpSnippet:CY,cpuKernelImpl:tq}),EY={kernelName:Eb,backendName:"webgl",kernelFunc:IY};class NY{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),o=n?"".concat(r,".0"):"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));i="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(a,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(i,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(r,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(o,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function TY(e,t,n){const r=n.texData.get(e.dataId),a=Wm(e.shape),o=e.shape[e.shape.length-1],i=BK({inputs:{x:e},backend:n,attrs:{shape:[a/o,o]}}),s=i.shape,c=new NY("real",s,t),l=new NY("imag",s,t),u=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:s},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:s}],d=n.runWebGLProgram(c,u,"float32"),h=n.runWebGLProgram(l,u,"float32"),p=wK({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=BK({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const RY={kernelName:Nb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return TY(r,!1,n)}};class AY{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function OY(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:o}=n;if(o=o||tv(a),"string"===o){const e=Ym(o,Wm(r));return e.fill(a),t.makeTensorInfo(r,o,e)}{const e=new AY(r,a),n=[[a]];return t.runWebGLProgram(e,[],o,n)}}const FY={kernelName:Tb,backendName:"webgl",kernelFunc:OY};class _Y{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const DY={kernelName:Rb,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:r}=t,a=n,o=new _Y(r.shape);return a.runWebGLProgram(o,[r],r.dtype)}},MY="return floor(x);",PY=AK({opSnippet:MY,packedOpSnippet:MY,cpuKernelImpl:nq}),LY={kernelName:Ab,backendName:"webgl",kernelFunc:PY},zY=OK({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),BY={kernelName:Ob,backendName:"webgl",kernelFunc:zY};class WY{constructor(e){this.variableNames=["A"];const t=aG(),[n,r]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(r,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class UY{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=aG(),[n,r]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(r,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const VY={kernelName:Tx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:o}=r,i="undefined"!==typeof HTMLVideoElement&&a instanceof HTMLVideoElement,s="undefined"!==typeof HTMLImageElement&&a instanceof HTMLImageElement,[c,l]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],u=[l,c],d=[l,c,o];if(s||i){const e=vv().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=jY&&e===HY||(HY=e,jY=document.createElement("canvas").getContext("2d",{willReadFrequently:HY})),jY.canvas.width=c,jY.canvas.height=l,jY.drawImage(a,0,0,c,l),a=jY.canvas}const h=n.makeTensorInfo(u,"int32");n.texData.get(h.dataId).usage=EH.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);const p=vv().getBool("WEBGL_PACK")?new UY(d):new WY(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let jY,HY=vv().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const GY={kernelName:Ox,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o,bias:i,preluActivationWeights:s}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,g=SC(u),m=pC(a.shape,o.shape,c,d,l,h,!1,g);let v;const b=[],y=null!=i,x=null!=s,w="leakyrelu"===p,k=()=>{const e=[a,o],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=BK({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(y&&e.push(t(i,u)),x&&e.push(t(s,u)),w){const t=n.makeTensorInfo([],"float32",aw(f,"float32"));e.push(t),b.push(t)}return e};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&vv().getBool("WEBGL_EXP_CONV")){const e=p?FK(p,!0):null,t=new S$(m,y,e,x,w),r=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],a=k();v=n.runWebGLProgram(t,a,"float32",r)}else if(vv().getBool("WEBGL_CONV_IM2COL"))v=N$({x:a,filter:o,convInfo:m,backend:n,bias:i,activation:p,preluActivationWeights:s,leakyreluAlpha:f});else{const e=p?FK(p,!1):null,t=new w$(m,y,e,x,w),r=k();v=n.runWebGLProgram(t,r,"float32")}else v=E$({x:a,filter:o,convInfo:m,backend:n,bias:i,activation:p,preluActivationWeights:s,leakyreluAlpha:f});const S=BK({inputs:{x:v},backend:n,attrs:{shape:m.outShape}});return b.push(v),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const qY={kernelName:Fx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o,bias:i,preluActivationWeights:s}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let g=u;null==g&&(g=[1,1]),Lm(wC(c,g),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(g,"'")));const m=pC(a.shape,o.shape,c,g,l,d,!0),v=vv().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,b=h?FK(h,v):null,y=[a,o],x=null!=i,w=null!=s,k="leakyrelu"===h;if(x&&y.push(i),w&&y.push(s),k){const e=n.makeTensorInfo([],"float32",aw(p,"float32"));y.push(e),f.push(e)}let S;S=v?new nY(m,x,b,w,k):new tY(m,x,b,w,k);const C=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],I=n.runWebGLProgram(S,y,"float32",C);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),I}};class KY{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=xG(n.length);let o="\n    int index;";for(let i=0;i<this.sliceDim;i++)o+="\n          index = round(getIndices(coords[0], ".concat(i,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[i],";\n          flattenIndex += index * ").concat(this.strides[i],";");this.userCode="\n         void main() {\n          ".concat(a," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(o,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const XY={kernelName:Db,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,o=a.shape,i=o[o.length-1],s=Wm(r.shape),[c,l,u,d]=FN(r,a),h=BK({inputs:{x:a},backend:n,attrs:{shape:[l,i]}}),p=BK({inputs:{x:r},backend:n,attrs:{shape:[Wm(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),o=rq(e,t,r.dtype,l,i,u,d,r.shape,s);return n.makeTensorInfo(c,r.dtype,o.values)}const f=new KY(i,d,[l,u],r.shape),g=n.runWebGLProgram(f,[p,h],p.dtype),m=BK({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),m}};class $Y{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=xG(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)2===a?r.push("index"):r.push("".concat(n[a]));return r.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(r,"));\n      }\n    ")}}function YY(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:o}=t,{axis:i,batchDims:s}=r,c=Km(i,a.shape)[0];if(vv().get("DEBUG")){const e=n.readSync(o.dataId),t=a.shape[c];for(let n=0;n<e.length;++n){const r=e[n];Lm(r<=t-1&&r>=0,(()=>"GatherV2: the index value ".concat(r," is not in [0, ").concat(t-1,"]")))}}const l=ST(a,o,c,s),u=Wm(o.shape),d=[],h=BK({inputs:{x:a},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=BK({inputs:{x:o},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});d.push(h),d.push(p);const f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([a,o])||"string"===a.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),r=aq(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l.outputShape,r.dtype,r.values)}const g=new $Y(h.shape,f),m=n.runWebGLProgram(g,[h,p],h.dtype);d.push(m);const v=BK({inputs:{x:m},backend:n,attrs:{shape:l.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),v}const QY={kernelName:_b,backendName:"webgl",kernelFunc:YY},ZY=OK({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:oq,dtype:"bool"}),JY={kernelName:Mb,backendName:"webgl",kernelFunc:ZY},eQ=OK({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:iq}),tQ={kernelName:Pb,backendName:"webgl",kernelFunc:eQ};const nQ={kernelName:zb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return TY(r,!0,n)}},rQ=AK({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),aQ={kernelName:Wb,backendName:"webgl",kernelFunc:rQ},oQ=AK({opSnippet:"return float(isinf(x));",dtype:"bool"}),iQ={kernelName:Ub,backendName:"webgl",kernelFunc:oQ},sQ=AK({opSnippet:"return float(isnan(x));",dtype:"bool"}),cQ={kernelName:Vb,backendName:"webgl",kernelFunc:sQ},lQ=OK({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:sq,dtype:"bool"}),uQ={kernelName:Hb,backendName:"webgl",kernelFunc:lQ},dQ=OK({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:cq,dtype:"bool"}),hQ={kernelName:Gb,backendName:"webgl",kernelFunc:dQ};const pQ={kernelName:qb,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:o}=n,i=lq(r,a,o);return t.makeTensorInfo([i.length],"float32",i)}},fQ=AK({opSnippet:RK+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:uq}),gQ={kernelName:Kb,backendName:"webgl",kernelFunc:fQ},mQ=AK({opSnippet:RK+"\n  return log(1.0 + x);\n"}),vQ={kernelName:Xb,backendName:"webgl",kernelFunc:mQ},bQ=OK({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),yQ={kernelName:$b,backendName:"webgl",kernelFunc:bQ},xQ=AK({opSnippet:"return float(!(x >= 1.0));"}),wQ={kernelName:Yb,backendName:"webgl",kernelFunc:xQ},kQ=OK({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),SQ={kernelName:Qb,backendName:"webgl",kernelFunc:kQ};class CQ{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];const o=t,i=e[3]-1;let s;this.outputShape=e;const c="float(".concat(n,") + float(").concat(r,") * sum");s=.5===a?"inversesqrt(".concat(c,")"):1===a?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(a,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(o,"; j <= ").concat(o,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(i,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(s,";\n        setOutput(val);\n      }\n    ")}}class IQ{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,i=e[3]-1;let s;this.outputShape=e;const c="float(".concat(n,") + float(").concat(r,") * sum");s=.5===a?"inversesqrt(".concat(c,")"):1===a?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(a,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(o,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(o,"; j <= ").concat(o,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(i,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(s,";\n        setOutput(result);\n      }\n    ")}}const EQ={kernelName:Zb,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:o,bias:i,alpha:s,beta:c}=r,l=vv().getBool("WEBGL_PACK_NORMALIZATION")?new IQ(a.shape,o,i,s,c):new CQ(a.shape,o,i,s,c);return n.runWebGLProgram(l,[a],a.dtype)}};class NQ{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(r,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(r,")\n                * float(").concat(a,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(a,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const TQ={kernelName:Jb,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a,y:o,dy:i}=t,{depthRadius:s,bias:c,alpha:l,beta:u}=r,d=new NQ(a.shape,s,c,l,u);return n.runWebGLProgram(d,[a,o,i],a.dtype)}};function RQ(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:o,keepDims:i}=r,s=a.shape.length,c=Km(o,a.shape);let l=c;const u=mI(l,s),d=null!=u,h=n.shouldExecuteOnCPU([a]);let p=a;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(s);for(let n=0;n<t.length;n++)t[n]=a.shape[u[n]];const r=Bq(e,a.shape,a.dtype,u,t);p=n.makeTensorInfo(t,a.dtype);n.texData.get(p.dataId).values=r}else p=qK(a,u,n);l=bI(l.length,s)}gI("max",l,s);const[f,g]=pI(p.shape,l);let m,v=f;if(i&&(v=fI(f,c)),h){const e=n.texData.get(p.dataId).values,t=dq(e,Wm(g),v,a.dtype);m=n.makeTensorInfo(v,a.dtype);n.texData.get(m.dataId).values=t}else m=function(e,t,n,r){const a=Wm(t),o=BK({inputs:{x:e},attrs:{shape:[Wm(e.shape)/a,a]},backend:r}),i=jK(o,e.dtype,"max",r),s=BK({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),s}(p,g,v,n);return d&&n.disposeIntermediateTensorInfo(p),m}const AQ={kernelName:ey,backendName:"webgl",kernelFunc:RQ},OQ=OK({opSnippet:gK+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+vK+"\n  return result;\n",cpuKernelImpl:hq}),FQ={kernelName:ty,backendName:"webgl",kernelFunc:OQ};const _Q={kernelName:ny,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;nG(a,"maxPool");const{filterSize:o,strides:i,pad:s,dimRoundingMode:c}=r;Lm(wC(i,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'")));const l=dC(a.shape,o,i,1,s,c);if(1===l.filterWidth&&1===l.filterHeight&&Um(l.inShape,l.outShape))return yK({inputs:{x:a},backend:n});const u=new OX(l,"max",!1);return n.runWebGLProgram(u,[a],a.dtype)}};const DQ={kernelName:ay,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:o,strides:i,pad:s,dataFormat:c,dimRoundingMode:l}=r,u=hC(a.shape,o,i,[1,1,1],s,l,c),d=new FX(u,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}};class MQ{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,o=e.effectiveFilterWidth,i=a-1-e.padInfo.top,s=o-1-e.padInfo.left,c=a*o-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(a,";\n          wR += ").concat(r,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(o," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class PQ{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=s-1-e.padInfo.front,d=c-1-e.padInfo.top,h=l-1-e.padInfo.left,p=s*c*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(d,", ").concat(h,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(s,";\n           wD += ").concat(a,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c,";\n              wR += ").concat(o,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(i,") {\n              float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const LQ={kernelName:oy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,i=o,{filterSize:s,strides:c,pad:l,dimRoundingMode:u}=r,d=hC(i.shape,s,c,[1,1,1],l,u),h=new FX(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new PQ(d),g=n.runWebGLProgram(f,[a,p],i.dtype);return n.disposeIntermediateTensorInfo(p),g}};const zQ={kernelName:ry,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o,output:i}=t,s=o;nG([o,i],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=r,h=dC(s.shape,c,l,1,u,d),p=new OX(h,"max",!0),f=n.runWebGLProgram(p,[s],s.dtype),g=new MQ(h),m=n.runWebGLProgram(g,[a,f],s.dtype);return n.disposeIntermediateTensorInfo(f),m}};const BQ={kernelName:iy,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:o,strides:i,pad:s,includeBatchInIndex:c}=n,l=r;Lm(4===a.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(a.shape.length,".")));const u=[1,1];Lm(wC(i,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(u,"'")));const d=dC(a.shape,o,i,u,s),[h,p]=function(e,t,n,r){let a=new OX(n,"max",!1);const o=r.runWebGLProgram(a,[e],"float32");return a=new OX(n,"max",!0,!0,t),[o,r.runWebGLProgram(a,[e],"float32")]}(a,c,d,l);return[h,p]}};const WQ={kernelName:sy,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{keepDims:o,axis:i}=n,s=r,c=a.shape.length,l=Km(i,a.shape);let u=l;const d=mI(u,c),h=null!=d,p=s.shouldExecuteOnCPU([a]),f=[];let g=a;if(h){if(p){const e=s.texData.get(g.dataId).values,t=new Array(c);for(let r=0;r<t.length;r++)t[r]=a.shape[d[r]];const n=Bq(e,a.shape,a.dtype,d,t);g=s.makeTensorInfo(t,a.dtype);s.texData.get(g.dataId).values=n}else g=qK(a,d,s);f.push(g),u=bI(u.length,c)}gI("sum",u,c);const[m,v]=pI(g.shape,u);let b=m;o&&(b=fI(m,l));const y=function(e,t,n,r){const a=Wm(t),o=BK({inputs:{x:e},attrs:{shape:[Wm(e.shape)/a,a]},backend:r}),i=jK(o,"float32","mean",r),s=BK({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),s}(g,v,b,s);for(const x of f)s.disposeIntermediateTensorInfo(x);return y}};const UQ={kernelName:cy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r,s=a.shape.length,c=Km(o,a.shape);let l=c;const u=mI(l,s);let d=a;null!=u&&(d=$K({inputs:{x:a},backend:n,attrs:{perm:u}}),l=bI(l.length,a.shape.length)),gI("min",l,s);const[h,p]=pI(d.shape,l),f=BK({inputs:{x:d},backend:n,attrs:{shape:[-1,Wm(p)]}}),g=jK(f,f.dtype,"min",n);let m;if(i){m=BK({inputs:{x:g},backend:n,attrs:{shape:fI(h,c)}})}else m=BK({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=u&&n.disposeIntermediateTensorInfo(d),m}},VQ=OK({opSnippet:gK+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+vK+"\n  return result;\n",cpuKernelImpl:pq}),jQ={kernelName:ly,backendName:"webgl",kernelFunc:VQ};class HQ{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=xG(r),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c="reflect"===n?0:1;this.userCode=1!==r?"\n      ".concat(a," start = ").concat(a,"(").concat(o,");\n      ").concat(a," end = ").concat(a,"(").concat(i,");\n\n      void main() {\n        ").concat(a," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(r,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c,";\n          }\n        }\n        ").concat(a," coords = outC - start;\n        setOutput(getX(").concat(s,"));\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class GQ{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=xG(r),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=Vq("rc",r),c=Vq("source",r),l="".concat(s[r-1]," < ").concat(this.outputShape[r-1]),u=1===r?"source":"vec2(".concat(c.slice(-2).join(),")"),d="reflect"===n?0:1;let h="";if(1===r){const e="\n        ".concat(a," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(d,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(d,";\n        }\n        source -= start;\n      ");h="\n        ".concat(a," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(s[r-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ")}else{const e="\n        ".concat(a," source = rc;\n        ").concat(a," lt = ").concat(a,"(lessThan(source, start));\n        ").concat(a," gte = ").concat(a,"(greaterThanEqual(source, end));\n        ").concat(a," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(d,") +\n                gte * ((end - 1) * 2 - source + ").concat(d,");\n        source -= start;\n      ");h="\n        ".concat(a," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(s[r-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(s[r-2]," += 1;\n        if(").concat(s[r-2]," < ").concat(this.outputShape[r-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          ").concat(s[r-1]," += 1;\n          if(").concat(l,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(a," start = ").concat(a,"(").concat(o,");\n      const ").concat(a," end = ").concat(a,"(").concat(i,");\n\n      void main() {\n        ").concat(a," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(h,"\n        setOutput(result);\n      }\n    ")}}const qQ={kernelName:uy,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a}=t,{paddings:o,mode:i}=r,s=vv().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new GQ(a.shape,o,i):new HQ(a.shape,o,i);return n.runWebGLProgram(s,[a],a.dtype)}},KQ=OK({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+vK+"\n  return result;\n"}),XQ={kernelName:dy,backendName:"webgl",kernelFunc:KQ};class $Q{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const YQ=OK({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),QQ={kernelName:bb,backendName:"webgl",kernelFunc:YQ},ZQ="return a - b;",JQ=OK({opSnippet:ZQ,packedOpSnippet:ZQ,supportsComplex:!0,cpuKernelImpl:Pq}),eZ={kernelName:mx,backendName:"webgl",kernelFunc:JQ};function tZ(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:o}=r,i=Km([o],a.shape),s=RQ({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),c=fI(s.shape,i),l=BK({inputs:{x:s},backend:n,attrs:{shape:c}}),u=JQ({inputs:{a:a,b:l},backend:n}),d=xY({inputs:{x:u},backend:n}),h=KK({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=BK({inputs:{x:h},backend:n,attrs:{shape:c}}),f=YQ({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const nZ={kernelName:rx,backendName:"webgl",kernelFunc:tZ};const rZ={kernelName:hy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:o,seed:i,normalized:s}=r,c=s?a:tZ({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),l=c.shape[0],u=c.shape[1],d=new $Q(l,u,o),h=[[i]],p=n.runWebGLProgram(d,[c],"int32",h);return s||n.disposeIntermediateTensorInfo(c),p}},aZ=Yq+"\n  return -x;\n";const oZ={kernelName:fy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,a]=gq(e.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,t)}let a;return a=vv().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new lK(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new $q(r.shape,aZ),n.runWebGLProgram(a,[r],r.dtype)}},iZ=zE;const sZ={kernelName:my,backendName:"webgl",kernelFunc:function(e){_x("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:c}=r,l=n.readSync(a.dataId),u=n.readSync(o.dataId),{selectedIndices:d}=iZ(l,u,i,s,c);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},cZ=BE;const lZ={kernelName:vy,backendName:"webgl",kernelFunc:function(e){_x("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:c,padToMaxOutputSize:l}=r,u=n.readSync(a.dataId),d=n.readSync(o.dataId),{selectedIndices:h,validOutputs:p}=cZ(u,d,i,s,c,l);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},uZ=WE;const dZ={kernelName:by,backendName:"webgl",kernelFunc:function(e){_x("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:c,softNmsSigma:l}=r,u=n.readSync(a.dataId),d=n.readSync(o.dataId),h=i,p=s,f=c,g=l,{selectedIndices:m,selectedScores:v}=uZ(u,d,h,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}};class hZ{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(r,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const pZ={kernelName:xy,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:o,depth:i,onValue:s,offValue:c}=r,l=Wm(a.shape),u=new hZ(l,i,s,c),d=BK({inputs:{x:a},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(u,[d],o);n.disposeIntermediateTensorInfo(d);const p=BK({inputs:{x:h},backend:n,attrs:{shape:[...a.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function fZ(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=e$({inputs:{input:r},backend:n}),t=fZ({inputs:{x:e},backend:n}),a=m$({inputs:{input:r},backend:n}),o=fZ({inputs:{x:a},backend:n}),i=wK({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),i}return OY({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const gZ={kernelName:Ex,backendName:"webgl",kernelFunc:fZ};const mZ={kernelName:yy,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const t=e$({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),o=m$({inputs:{input:a},backend:r}),i=fZ({inputs:{x:o},backend:r}),s=wK({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),s}return OY({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};const vZ={kernelName:wy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return kY({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const o=t[0].shape,i=t[0].dtype;t.forEach((e=>{zm(o,e.shape,"All tensors passed to stack must have matching shapes"),Lm(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const s=[],c=y$({inputs:t.map((e=>{const t=kY({inputs:{input:e},backend:n,attrs:{dim:a}});return s.push(t),t})),backend:n,attrs:{axis:a}});return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};class bZ{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=xG(r),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      ".concat(a," start = ").concat(a,"(").concat(o,");\n      ").concat(a," end = ").concat(a,"(").concat(i,");\n\n      void main() {\n        ").concat(a," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(a," coords = outC - start;\n          setOutput(getX(").concat(s,"));\n        }\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class yZ{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=xG(r),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=Vq("rc",r),c=Vq("source",r),l="".concat(s[r-1]," < ").concat(this.outputShape[r-1]),u=1===r?"source":"vec2(".concat(c.slice(-2).join(),")"),d=["".concat(a," rc = outputLoc;"),"".concat(s[r-1]," += 1;\n       if(").concat(l,") {\n      "),1===r?"":"}\n       rc = outputLoc;\n       ".concat(s[r-2]," += 1;\n       if(").concat(s[r-2]," < ").concat(this.outputShape[r-2],") {"),1===r?"":"  ".concat(s[r-1]," += 1;\n         if(").concat(l,") {")],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,g=1===r?2:4;f<g;f++)p+="\n        ".concat(d[f],"\n        if (").concat(h,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(a," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ");p+=1===r?"} ":"}}",this.userCode="\n      const ".concat(a," start = ").concat(a,"(").concat(o,");\n      const ").concat(a," end = ").concat(a,"(").concat(i,");\n\n      void main() {\n        ").concat(a," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const xZ=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:o,constantValue:i}=r;if(0===Wm(a.shape)){const e=o.map(((e,t)=>e[0]+a.shape[t]+e[1]));return OY({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}const s=vv().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yZ(a.shape,o,i):new bZ(a.shape,o,i),c=[[i]];return n.runWebGLProgram(s,[a],a.dtype,c)},wZ={kernelName:ky,backendName:"webgl",kernelFunc:xZ},kZ=OK({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+vK+"\n  return result;\n"}),SZ={kernelName:Sy,backendName:"webgl",kernelFunc:kZ};const CZ={kernelName:Iy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r,s=a.shape.length,c=[],l=Km(o,a.shape);let u=l;const d=mI(u,s);let h,p=a;if(null!=d&&(p=$K({inputs:{x:a},backend:n,attrs:{perm:d}}),u=bI(u.length,s),c.push(p)),gI("prod",u,s),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:a}=vq(p.shape,p.dtype,e,u);h=n.makeTensorInfo(r,a,t)}else{const[e,t]=pI(p.shape,u),r=Wm(t),o=BK({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=jK(o,Pw(a.dtype),"prod",n);h=BK({inputs:{x:i},backend:n,attrs:{shape:e}}),c.push(o),c.push(i)}if(i){c.push(h);const e=fI(h.shape,l);h=BK({inputs:{x:h},backend:n,attrs:{shape:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const IZ={kernelName:Ey,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:o,indices:i}=t,{outputRaggedRank:s}=r,c=a.map((e=>n.readSync(e.dataId))),l=a.map((e=>e.shape)),u=n.readSync(o.dataId),d=n.readSync(i.dataId),[h,p,f]=bq(c,l,u,o.shape,o.dtype,d,i.shape,s),g=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),m=n.makeTensorInfo(f,o.dtype,p);return g.concat([m])}};const EZ={kernelName:Ny,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:o}=t,i=n.readSync(r.dataId),s=n.readSync(a.dataId),c=n.readSync(o.dataId),[l,u]=yq(i,r.shape,r.dtype,s,a.shape,c,o.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],r.dtype,u)]}};const NZ={kernelName:Ty,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:o,defaultValue:i,rowPartitionTensors:s}=t,{rowPartitionTypes:c}=r,l=n.readSync(a.dataId),u=n.readSync(o.dataId),d=n.readSync(i.dataId),h=s.map((e=>n.readSync(e.dataId))),p=s.map((e=>e.shape)),[f,g]=xq(l,a.shape,u,o.shape,o.dtype,d,i.shape,h,p,c);return n.makeTensorInfo(f,o.dtype,g)}},TZ=e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:o,dtype:i}=n,s=wq(r,a,o,i);return t.makeTensorInfo([s.length],i,s)},RZ={kernelName:Ry,backendName:"webgl",kernelFunc:TZ},AZ=AK({opSnippet:"return 1.0 / x;"}),OZ={kernelName:Oy,backendName:"webgl",kernelFunc:AZ},FZ=AK({opSnippet:Yq+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),_Z={kernelName:Fy,backendName:"webgl",kernelFunc:FZ},DZ=AK({opSnippet:Yq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),MZ={kernelName:zy,backendName:"webgl",kernelFunc:DZ};class PZ{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[o,i,s,c]=e;this.outputShape=[o,t,n,c];const l=[r&&t>1?i-1:i,r&&n>1?s-1:s],u=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(s,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class LZ{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,s,c]=e;this.outputShape=[o,t,n,c];const l=[r&&t>1?i-1:i,r&&n>1?s-1:s],u=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(s,".0,\n                                     ").concat(s,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const zZ={kernelName:Py,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:o,halfPixelCenters:i,size:s}=r,[c,l]=s,u=vv().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new LZ(a.shape,c,l,o,i):new PZ(a.shape,c,l,o,i);return n.runWebGLProgram(u,[a],"float32")}};class BZ{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,o,i]=e,s=[n&&o>1?r-1:r,n&&i>1?a-1:a],c=[n&&o>1?o-1:o,n&&i>1?i-1:i],l=s[0]/c[0],u=s[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(r-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(a-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const WZ={kernelName:Ly,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:o}=t,{alignCorners:i}=r,s=new BZ(o.shape,a.shape,i);return n.runWebGLProgram(s,[o],o.dtype)}};class UZ{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[o,i,s,c]=e;this.outputShape=[o,t,n,c];const l=[r&&t>1?i-1:i,r&&n>1?s-1:s],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(s,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class VZ{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,s,c]=e;this.outputShape=[o,t,n,c];const l=[r&&t>1?i-1:i,r&&n>1?s-1:s],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(s,".0,\n                                     ").concat(s,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(d,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const jZ={kernelName:Dy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:o,halfPixelCenters:i,size:s}=r,[c,l]=s,u=vv().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new VZ(a.shape,c,l,o,i):new UZ(a.shape,c,l,o,i);return n.runWebGLProgram(u,[a],a.dtype)}};class HZ{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,o,i]=e,s=[n&&o>1?r-1:r,n&&i>1?a-1:a],c=[n&&o>1?o-1:o,n&&i>1?i-1:i],l=s[0]/c[0],u=s[1]/c[1],d=1/l,h=1/u,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(d,");\n        const float invWidthScale = float(").concat(h,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(s[0],") *\n                (float(dyR) / float(").concat(c[0],"));\n\n            float sourceFracCol =\n                float(").concat(s[1],") *\n                  (float(dyC) / float(").concat(c[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const GZ={kernelName:My,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:o}=t,{alignCorners:i}=r,s=new HZ(o.shape,a.shape,i);return n.runWebGLProgram(s,[o],o.dtype)}};class qZ{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(r))).join(","),a=xG(n);this.userCode="\n      void main() {\n        ".concat(a," coords = getOutputCoords();\n        setOutput(getX(").concat(r,"));\n      }\n    ")}}class KZ{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const r=Vq("rc",n),a="".concat(r[n-1]," + 1 < ").concat(this.outputShape[n-1]),o="".concat(r[n-2]," + 1 < ").concat(this.outputShape[n-2]),i=xG(n);function s(n){const r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(r[n]," - 1"):"".concat(r[n])}(a,n))),a=r.join(","),o=r.slice(-2).join(",");return"getChannel(getX(".concat(a,"), vec2(").concat(o,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(a,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(i," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return s(e)}(r.slice()),";\n          if(").concat(a,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",s(e)}(r.slice()),";\n          }\n          if(").concat(o,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",s(e)}(r.slice()),";\n            if(").concat(a,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",s(e)}(r.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const XZ={kernelName:By,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:o}=r,i=a.shape.length,s=Km(o,a.shape);if(0===i)return yK({inputs:{x:a},backend:n});const c=vv().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new KZ(a.shape,s):new qZ(a.shape,s);return n.runWebGLProgram(c,[a],a.dtype)}};class $Z{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let a="";a="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(a,"\n          if(coordX >= 0 && coordX < ").concat(r," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const YZ={kernelName:Rx,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:o,fillValue:i,center:s}=n,c=r,l=new $Z(a.shape,i),[u,d]=EN(s,a.shape[1],a.shape[2]),h=[[u,d,Math.sin(o),Math.cos(o)]];return c.runWebGLProgram(l,[a],a.dtype,h)}},QZ=AK({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),ZZ={kernelName:Wy,backendName:"webgl",kernelFunc:QZ},JZ=AK({opSnippet:"return inversesqrt(x);",cpuKernelImpl:kq}),eJ={kernelName:Uy,backendName:"webgl",kernelFunc:JZ};class tJ{constructor(e,t,n,r,a,o){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const s=xG(a.length),c=xG(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h="getUpdates(".concat(d,")");let p="";i&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),g=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(s," strides = ").concat(s,"(").concat(a,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(g,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(h,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class nJ{constructor(e,t,n,r,a,o){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const s=xG(a.length),c=xG(o.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h="getUpdates(".concat(d,")");let p="";i&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),g=t>1?"strides[j]":"strides",m=t>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(s," strides = ").concat(s,"(").concat(a,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(t,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(g,";\n              if (j + 1 < ").concat(t,") {\n                flattenedIndex += index.yw * ").concat(m,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(h,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const rJ={kernelName:Vy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:o}=t,{shape:i}=r,{sliceRank:s,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=MN(0,a,i),h=[d/l,l];if(0===d)return n.makeTensorInfo(i,a.dtype);const p=BK({inputs:{x:a},backend:n,attrs:{shape:[c,s]}}),f=BK({inputs:{x:o},backend:n,attrs:{shape:[c,l]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=vv().getBool("WEBGL_PACK")?new nJ(c,s,p.shape.length,f.shape.length,u,h):new tJ(c,s,p.shape.length,f.shape.length,u,h);const v=n.runWebGLProgram(m,[f,p,g],f.dtype),b=BK({inputs:{x:v},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(g),b}};class aJ{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const a="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),o=2===vv().getNumber("WEBGL_VERSION")?"while (left < right) {":a,i="left"===r?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(o,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(i," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const oJ={kernelName:Hy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:o}=t,{side:i}=r,s=new aJ(a.shape[0],a.shape[1],o.shape[1],i),c=[[a.shape[1]]];return n.runWebGLProgram(s,[a,o],"int32",c)}};class iJ{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[];for(let r=0;r<t.length;r++)i.push("".concat(n[r])),r<e&&o.push("".concat(n[r]));r=o.join(),a=i.join()}const o=xG(n);this.userCode="\n      void main() {\n        ".concat(o," resRC = getOutputCoords();\n        float cVal = getC(").concat(r,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(a,"));\n        } else {\n          setOutput(getB(").concat(a,"));\n        }\n      }\n    ")}}const sJ={kernelName:Gy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:o}=t,i=new iJ(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,o],Mw(a.dtype,o.dtype))}},cJ=AK({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(PN,";\n  float scale = ").concat(LN,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),lJ={kernelName:qy,backendName:"webgl",kernelFunc:cJ},uJ=AK({opSnippet:RK+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Cq}),dJ={kernelName:Qy,backendName:"webgl",kernelFunc:uJ},hJ=AK({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),pJ={kernelName:Yy,backendName:"webgl",kernelFunc:hJ},fJ=AK({opSnippet:RK+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(vK,"\n  return result;\n")}),gJ={kernelName:Xy,backendName:"webgl",kernelFunc:fJ},mJ=AK({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),vJ={kernelName:$y,backendName:"webgl",kernelFunc:mJ},bJ=AK({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),yJ={kernelName:Zy,backendName:"webgl",kernelFunc:bJ},xJ={kernelName:tx,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:o,paddings:i}=r;Lm(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const s=o.reduce(((e,t)=>e*t)),c=[[0,0]];c.push(...i);for(let v=1+o.length;v<a.shape.length;++v)c.push([0,0]);const l=[],u=xZ({inputs:{x:a},backend:n,attrs:{paddings:c,constantValue:0}}),d=NN(u.shape,o,s,!1),h=TN(d.length,o.length,!1),p=RN(u.shape,o,s,!1),f=BK({inputs:{x:u},backend:n,attrs:{shape:d}}),g=$K({inputs:{x:f},backend:n,attrs:{perm:h}}),m=BK({inputs:{x:g},backend:n,attrs:{shape:p}});return l.push(u),l.push(f),l.push(g),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}};const wJ={kernelName:ax,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(o.shape));if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(r.shape));if(1!==a.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(a.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));const s=n.readSync(r.dataId),c=n.readSync(a.dataId),l=n.readSync(o.dataId),u=n.readSync(i.dataId)[0],[d,h,p,f,g]=Nq(s,r.shape,r.dtype,c,a.dtype,l,u);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}};const kJ={kernelName:ox,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:o}=t;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(r.shape));if(1!==a.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(a.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const i=Array.from(n.readSync(a.dataId)),s=n.readSync(r.dataId),c=Array.from(n.readSync(o.dataId)),[l,u,d]=Tq(s,r.shape,r.dtype,i,c);return[n.makeTensorInfo(u,r.dtype,l),n.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};const SJ={kernelName:ix,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(a.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(o.shape));const i=n.readSync(r.dataId),s=n.readSync(a.dataId),c=n.readSync(o.dataId),[l,u]=Rq(i,r.shape,r.dtype,s,c,!0);return n.makeTensorInfo(u,r.dtype,l)}};const CJ={kernelName:sx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(a.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(o.shape));const i=n.readSync(r.dataId),s=n.readSync(a.dataId),c=n.readSync(o.dataId),[l,u]=Rq(i,r.shape,r.dtype,s,c);return n.makeTensorInfo(u,r.dtype,l)}};const IJ={kernelName:cx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:o,defaultValue:i}=t,{outputShape:s}=r,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:h}=MN(0,a,s),p=!1;if("string"===o.dtype){const e=n.bufferSync(a),t=n.bufferSync(o),r=cw(n.readSync(i.dataId)[0]),f=Sq(e,t,s,h,u,l,c,d,r,p);return n.makeTensorInfo(s,f.dtype,f.values)}const f=new tJ(l,c,a.shape.length,o.shape.length,d,[h,1],p),g=n.runWebGLProgram(f,[o,a,i],o.dtype),m=BK({inputs:{x:g},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(g),m}};const EJ={kernelName:nx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:o,axis:i}=r,s=Km(i,a.shape)[0],c=cT(a,o,s),l=a.shape.length,u=new Array(l).fill(0),d=a.shape.slice();return c.map((e=>{const t=[...d];t[s]=e;const r=qX({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[s]+=e,r}))}},NJ="return sqrt(x);",TJ=AK({opSnippet:NJ,packedOpSnippet:NJ,cpuKernelImpl:Aq}),RJ={kernelName:Jy,backendName:"webgl",kernelFunc:TJ},AJ={kernelName:ux,backendName:"webgl",kernelFunc:AK({opSnippet:"return x * x;"})},OJ="return (a - b) * (a - b);",FJ=OK({opSnippet:OJ,packedOpSnippet:OJ}),_J={kernelName:lx,backendName:"webgl",kernelFunc:FJ};const DJ={kernelName:dx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");const o=CT(n.readSync(a.dataId)),i=Oq(o,"string",r);return n.makeTensorInfo(a.shape,"string",i)}};const MJ={kernelName:Nx,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,o=Yq+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),i=new $q(a.shape,o);return r.runWebGLProgram(i,[a],a.dtype)}};class PJ{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=xG(n.length),o=xG(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?"coords * strides[".concat(r,"] + begin[").concat(r,"]"):"coords[".concat(e-1,"] * strides[").concat(r,"] + begin[").concat(r,"]")))).join(",")}this.userCode="\n      ".concat(a," begin = ").concat(a,"(").concat(e,");\n      ").concat(a," strides = ").concat(a,"(").concat(t,");\n\n      void main() {\n        ").concat(o," coords = getOutputCoords();\n        setOutput(getX(").concat(i,"));\n      }\n    ")}}const LJ={kernelName:hx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:o,end:i,strides:s,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:v,begin:b,end:y,strides:x}=oC(a.shape,o,i,s,c,l,u,d,h);let w;if(g)w=BK({inputs:{x:a},backend:n,attrs:{shape:f}});else if(m||v){Lm(a.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(a.shape.length)));const e=qS(b,y,x),t=qX({inputs:{x:a},backend:n,attrs:{begin:b,size:e}});w=BK({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=Jk(a.shape,a.dtype,e),r=Fq(p,t,x,b);w=n.makeTensorInfo(f,a.dtype,r.values)}else{const e=new PJ(b,x,p);w=n.runWebGLProgram(e,[a],a.dtype)}}const k=BK({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const zJ={kernelName:px,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:o,leftPad:i,rightPad:s,padWidth:c,preserveShortSequences:l}=r,{data:u,dataSplits:d}=t,h=n.readSync(u.dataId),p=n.readSync(d.dataId),[f,g]=_q(h,p,a,o,i,s,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",g)]}};const BJ={kernelName:fx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));const s=n.readSync(o.dataId),c=n.readSync(i.dataId)[0],[l,u,d]=Dq(s,c,a),h=u.length;return[n.makeTensorInfo([h,2],"int32",l),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const WJ={kernelName:gx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(o.dataId),s=Mq(i,a);return n.makeTensorInfo(o.shape,"int32",s)}},UJ=AK({opSnippet:"return tan(x);"}),VJ={kernelName:vx,backendName:"webgl",kernelFunc:UJ},jJ=AK({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),HJ={kernelName:bx,backendName:"webgl",kernelFunc:jJ};const GJ={kernelName:jy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:o,updates:i}=t,{}=r,{sliceRank:s,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=MN(0,o,a.shape),h=[d/l,l];if(0===d)return n.makeTensorInfo(a.shape,o.dtype);const p=BK({inputs:{x:o},backend:n,attrs:{shape:[c,s]}}),f=BK({inputs:{x:i},backend:n,attrs:{shape:[c,l]}}),g=BK({inputs:{x:a},backend:n,attrs:{shape:h}}),m=new tJ(c,s,p.shape.length,f.shape.length,u,h,!1,!0),v=n.runWebGLProgram(m,[f,p,g],g.dtype),b=BK({inputs:{x:v},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(v),b}};class qJ{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;const r=xG(this.rank),a=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push("imod(".concat(n[a],", ").concat(e[a],")"));return r.join()}(e);this.userCode="\n      void main() {\n        ".concat(r," resRC = getOutputCoords();\n        setOutput(getA(").concat(a,"));\n      }\n    ")}}function KJ(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:o}=r;if("string"===a.dtype||a.shape.length>5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>cw(e))):e,r=Jk(a.shape,a.dtype,t),i=Lq(r,o);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new qJ(a.shape,o);return n.runWebGLProgram(i,[a],a.dtype)}const XJ={kernelName:yx,backendName:"webgl",kernelFunc:KJ};class $J{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class YJ{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function QJ(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function ZJ(e){let t=1;for(;t<e;)t*=2;return t}const JJ={kernelName:xx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:o,sorted:i}=r,s=vv().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=vv().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=a.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([a])||u<s||o>c){const e=n.readSync(a.dataId),[t,r]=zq(e,l,a.dtype,o,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===o)return l[l.length-1]=0,[n.makeTensorInfo(l,a.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===u)return[a,OY({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const d=n.texData.get(a.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(a):a,f=Wm(l)/u,g=BK({inputs:{x:p},attrs:{shape:[f,u]},backend:n});h&&QJ(n,p);const m=ZJ(o),v=ZJ(u);let b=null;const y=()=>null===b?[g,g]:[g,b],x=(e,t,r)=>{const a=y(),o=new $J(r),i=[[u],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],s=b;b=n.runWebGLProgram(o,a,"int32",i),QJ(n,s)};for(let I=1;I<m;I*=2){const e=2*I;for(let t=I;t>=1;t/=2)x(e,t,[f,v])}for(let I=v;I>m;I/=2){const e=y(),t=new YJ([f,I/2]),r=[[u],[null===b?1:0],[m]],a=b;b=n.runWebGLProgram(t,e,"int32",r),QJ(n,a);const o=m/2,i=2*o;for(let n=o;n>=1;n/=2)x(i,n,b.shape)}let w=b;b=qX({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,o]}}),QJ(n,w);let k=YY({inputs:{x:g,indices:b},backend:n,attrs:{axis:1,batchDims:1}});QJ(n,g);const S=l.slice(0,-1);S.push(o),w=b,b=BK({inputs:{x:b},attrs:{shape:S},backend:n}),QJ(n,w);const C=k;return k=BK({inputs:{x:k},attrs:{shape:S},backend:n}),QJ(n,C),[k,b]}};class e0{constructor(e,t,n,r,a,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const i="nearest"===n?1:2;let s;switch(r){case"constant":default:s=1;break;case"reflect":s=2;break;case"wrap":s=3;break;case"nearest":s=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(s," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(s," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(s," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(a,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(a,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(i," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const t0={kernelName:wx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:o}=t,{interpolation:i,fillMode:s,fillValue:c,outputShape:l}=r,[u,d,h,p]=a.shape,[f,g]=null!=l?l:[d,h],m=new e0(d,h,i,s,c,[u,f,g,p]);return n.runWebGLProgram(m,[a,o],"float32")}};const n0={kernelName:Sx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:o}=t;nG(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:s,outputShape:c,indices:l}=Wq(i,a,o.shape,o.dtype);return[r.makeTensorInfo(c,o.dtype,s),r.makeTensorInfo([l.length],"int32",l)]}};const r0={kernelName:Cx,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:o}=r;o<0&&(o+=a.shape.length);const i=a,s=i.shape.length,c=a.shape[o],l=new Array(s-1);let u=0;for(let g=0;g<s;g++)g!==o&&(l[u++]=i.shape[g]);const d=[],h=new Array(s).fill(0),p=i.shape.slice();p[o]=1;const f=new Array(c);for(let g=0;g<f.length;g++){h[o]=g;const e=qX({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),t=BK({inputs:{x:e},backend:n,attrs:{shape:l}});f[g]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class a0{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,o=e.numSegments,i=o*Math.ceil(a/n);this.outputShape=[r,i];const s=4*Math.floor(n/4),c=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let u="";a%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return initializationValue;\n        }\n      "));let d="";a%n>0&&(d="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(d,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(o,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(o,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(s,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(s,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const o0={kernelName:Ix,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:o}=t,{numSegments:i}=r,s=a.shape.length,c=[];let l=0;const u=mI([l],s);let d=a;null!=u&&(d=$K({inputs:{x:a},backend:n,attrs:{perm:u}}),c.push(d),l=bI(1,s)[0]);const h=kT(d.shape,l,i),p=Wm([d.shape[l]]),f=BK({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});c.push(f);const g=Pw(a.dtype),m=(e,t,r,a,o)=>{const i=e.shape[0],s=e.shape[1],l=wT(s,o),u=new a0({windowSize:l,inSize:s,batchSize:i,numSegments:o},t),d=n.compileAndRun(u,[e,r],a);if(c.push(d),d.shape[1]===o)return d;const h=TZ({backend:n,attrs:{start:0,stop:o,step:1,dtype:"float32"}}),p=KJ({inputs:{x:h},backend:n,attrs:{reps:[s/l]}});c.push(h),c.push(p);return m(d,t,p,a,o)},v=BK({inputs:{x:m(f,"unsortedSegmentSum",o,g,i)},backend:n,attrs:{shape:h}});let b=v;if(null!=u){c.push(v);const e=vI(u);b=$K({inputs:{x:b},backend:n,attrs:{perm:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},i0=[JK,tX,rX,oX,cX,dX,hX,pX,yX,xX,kX,CX,EX,TX,AX,_X,DX,LX,zX,BX,VX,XX,$X,YX,QX,r$,i$,l$,kK,h$,x$,T$,_$,M$,P$,L$,z$,W$,V$,H$,Y$,Q$,Z$,eY,rY,iY,sY,lY,dY,hY,fY,gY,vY,yY,wY,SY,EY,RY,FY,DY,LY,BY,VY,GY,qY,XY,QY,JY,tQ,xK,nQ,v$,aQ,iQ,cQ,IK,uQ,hQ,pQ,gQ,vQ,yQ,wQ,SQ,EQ,TQ,AQ,FQ,_Q,DQ,LQ,zQ,BQ,WQ,UQ,jQ,qQ,XQ,rZ,zK,oZ,sZ,lZ,dZ,JX,pZ,mZ,vZ,wZ,SZ,TK,CZ,IZ,EZ,NZ,RZ,t$,QQ,OZ,_Z,MZ,WK,zZ,WZ,jZ,GZ,XZ,YZ,ZZ,eJ,rJ,oJ,sJ,lJ,dJ,pJ,gJ,vJ,KX,nZ,yJ,xJ,wJ,kJ,SJ,CJ,IJ,EJ,RJ,AJ,_J,DJ,MJ,LJ,zJ,BJ,WJ,eZ,XK,VJ,HJ,GJ,XJ,JJ,t0,YK,n0,r0,o0,gZ];for(const n of i0)Wx(n);const s0=function(){const e=sk([[1,2],[3,4]]),t=sk([[5,6],[7,8]]),n=e.add(t);return(0,Tm.jsxs)("div",{children:[(0,Tm.jsx)(vs,{children:(0,Tm.jsx)(ks,{span:24,style:{textAlign:"center"},children:(0,Tm.jsx)(Xf.Title,{level:2,children:"PROCTORING APP"})})}),(0,Tm.jsx)(vs,{children:(0,Tm.jsx)(ks,{span:24,style:{display:"flex",justifyContent:"center"},children:(0,Tm.jsx)(Rm,{})})}),(0,Tm.jsx)(vs,{children:(0,Tm.jsx)(ks,{span:24,style:{display:"flex",justifyContent:"center"},children:(0,Tm.jsx)(vs,{children:(0,Tm.jsxs)(ks,{span:12,style:{textAlign:"center"},children:[(0,Tm.jsx)(Xf.Title,{level:1,children:"Tensorflow.js"}),(0,Tm.jsxs)(Xf.Text,{children:["Result : ",n.toString()]})]})})})})]})};var c0;const l0=ir.div(c0||(c0=function(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}(["\n\tbackground-color: ",";\n\tcolor: ",";\n\tfont-family: ",";\n\tpadding: 1rem;\n"])),(e=>{let{theme:t}=e;return t.colors.light}),(e=>{let{theme:t}=e;return t.colors.dark}),(e=>{let{theme:t}=e;return t.fonts.primary}));const u0=function(){return(0,Tm.jsx)(l0,{children:(0,Tm.jsx)(de,{children:(0,Tm.jsxs)(ce,{children:[(0,Tm.jsx)(ie,{path:"/proctoring-app/",element:(0,Tm.jsx)(s0,{})}),(0,Tm.jsx)(ie,{path:"/proctoring-app/dashboard",element:(0,Tm.jsx)("div",{})})]})})})},d0=e=>{e&&e instanceof Function&&n.e(453).then(n.bind(n,453)).then((t=>{let{getCLS:n,getFID:r,getFCP:a,getLCP:o,getTTFB:i}=t;n(e),r(e),a(e),o(e),i(e)}))},h0={colors:{primary:"#007bff",secondary:"#6c757d",success:"#28a745",danger:"#dc3545",warning:"#ffc107",info:"#17a2b8",light:"#f8f9fa",dark:"#343a40"},fonts:{primary:"Roboto, sans-serif"},fontSizes:{small:"0.8rem",medium:"1rem",large:"1.2rem"}},p0=e=>{let{children:t}=e;return(0,Tm.jsx)(Zn,{theme:h0,children:t})};s.createRoot(document.getElementById("root")).render((0,Tm.jsx)(o.StrictMode,{children:(0,Tm.jsx)(p0,{children:(0,Tm.jsx)(u0,{})})})),d0()})()})();
//# sourceMappingURL=main.70faac01.js.map